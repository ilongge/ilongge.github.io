{"pages":[{"title":"404","text":"","link":"/404/index.html"},{"title":"about","text":"","link":"/about/index.html"},{"title":"friends","text":"","link":"/friends/index.html"},{"title":"contact","text":"","link":"/contact/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"CentOS7.2配置LNMP环境记录","text":"CentOS7.2配置LNMP环境记录1php 7.0+ nginx 1.10+ mysql 5.5+ LNMP是Linux、Nginx、MySQL(MariaDB)和PHP的缩写，这个组合是最常见的WEB服务器的运行环境之一。本文将带领大家在CentOS 7操作系统上搭建一套LNMP环境。 本教程适用于CentOS 7.x版本。 准备工作更新 yum 源,自带的源没有 PHP7:1rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm 1rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm 安装 epel:1yum install epel-release 升级系统1yum update 准备工作完成,开始安装! 安装NginxCentOS系统模板中配置了内网源，下载速度较快，推荐使用yum安装Nginx： 1sudo yum install nginx 按照提示，输入yes后开始安装。安装完毕后，Nginx的配置文件在/etc/nginx目录下。使用以下命令启动Nginx： 1sudo systemctl start nginx 检查系统中firewalld防火墙服务是否开启，如果已开启，我们需要修改防火墙配置，开启Nginx外网端口访问。 1sudo systemctl status firewalld 如果显示**active (running)**，则需要调整防火墙规则的配置。 修改/etc/firewalld/zones/public.xml文件，在zone一节中增加： 1234&lt;zone&gt; ... &lt;service name=&quot;nginx&quot;/&gt;&lt;zone&gt; 保存后重新加载firewalld服务： 1sudo systemctl restart firewalld 您可以通过浏览器访问 http://外网IP地址 来确定Nginx是否已经启动。 【注意：很重要！！！】部分童鞋发现按照教程操作最后无法访问，这是云服务器默认关闭了80端口。这个请移步云服务里控制台打开80端口的外网访问，如需步骤，请自行百度！ 最后将Nginx设置为开机启动： 1sudo systemctl enable nginx.service 这么Nginx就安装成功了！ 安装MySQL(MariaDB)MariaDB是MySQL的一个分支，主要由开源社区进行维护和升级，而MySQL被Oracle收购以后，发展较慢。在CentOS 7的软件仓库中，将MySQL更替为了MariaDB。 我们可以使用yum直接安装MariaDB： 1sudo yum install mariadb-server 安装完成之后，执行以下命令重启MariaDB服务： 1sudo systemctl restart mariadb MariaDB默认root密码为空，我们需要设置一下，执行脚本： 1sudo /usr/bin/mysql_secure_installation 这个脚本会经过一些列的交互问答来进行MariaDB的安全设置。 首先提示输入当前的root密码： Enter current password for root (enter for none): 初始root密码为空，我们直接敲回车进行下一步。* Set root password? [Y/n] 设置root密码，默认选项为Yes，我们直接回车，提示输入密码，在这里设置您的MariaDB的root账户密码。* Remove anonymous users? [Y/n] 是否移除匿名用户，默认选项为Yes，建议按默认设置，回车继续。 Disallow root login remotely? [Y/n] 是否禁止root用户远程登录？如果您只在本机内访问MariaDB，建议按默认设置，回车继续。 如果您还有其他云主机需要使用root账号访问该数据库，则需要选择n。* Remove test database and access to it? [Y/n] 是否删除测试用的数据库和权限？建议按照默认设置，回车继续。 Reload privilege tables now? [Y/n] 是否重新加载权限表？因为我们上面更新了root的密码，这里需要重新加载，回车。* 完成后你会看到Success!的提示，MariaDB的安全设置已经完成。我们可以使用以下命令登录MariaDB： 1mysql -uroot -p 按提示输入root密码，就会进入MariaDB的交互界面，说明已经安装成功。 最后我们将MariaDB设置为开机启动。 1sudo systemctl enable mariadb php70w 安装PHP我们可以直接使用yum安装PHP： 123sudo yum install php70w-fpm php70w-mysql php70w-mysqli php70w php70w-opcache php70w-gd php70w-intl php70w-mbstring php70w-exif php70w-mcrypt php70w-openssl//把该安装的一次性装到位 安装完成后我们将php-fpm启动： 1sudo systemctl start php-fpm 将php-fpm设置为开机启动： 1sudo systemctl enable php-fpm 接下来需要注意了！配置Nginx–多个站点我给大家提供一个范本作为参考： 12nginx.conf//里面我会详细的给予中文注释 12vi /etc/nginx/nginx.conf//编辑nginx.conf的命令 以下为conf文件内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104# For more information on configuration, see:# * Official English Documentation: http://nginx.org/en/docs/# * Official Russian Documentation: http://nginx.org/ru/docs/user nginx;worker_processes auto;error_log /var/log/nginx/error.log; #错误日志记录的位置pid /run/nginx.pid; #nginx.pid为记录nginx主进程pid文件；切勿修改、移动# Load dynamic modules. See /usr/share/nginx/README.dynamic.include /usr/share/nginx/modules/*.conf;#引入/usr/share/nginx/modules/ 目录下的所有以.conf结尾的文件events { worker_connections 1024;}http { log_format main '$remote_addr - $remote_user [$time_local] &quot;$request&quot; ' '$status $body_bytes_sent &quot;$http_referer&quot; ' '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;'; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; # Load modular configuration files from the /etc/nginx/conf.d directory. # See http://nginx.org/en/docs/ngx_core_module.html#include # for more information. include /etc/nginx/conf.d/*.conf; #这句很重要，引入所有etc/nginx/conf.d/目录下的.conf文件 #***etc/nginx/conf.d/目录存放的就是分站点的文件（下面会给出实例代码）*** server { #由于我们的nginx需要配置多站点，所以在此就需要注释一些东西 listen 80 default_server; listen [::]:80 default_server; #保留监听的端口 # server_name _; # root /usr/share/nginx/php; # Load configuration files for the default server block. # include /etc/nginx/default.d/*.conf; # location / { # } # error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } # location ~ \\.php$ { # root /usr/share/php; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; # include fastcgi_params; # } }# Settings for a TLS enabled server.## server {# listen 443 ssl http2 default_server;# listen [::]:443 ssl http2 default_server;# server_name _;# root /usr/share/nginx/html;## ssl_certificate &quot;/etc/pki/nginx/server.crt&quot;;# ssl_certificate_key &quot;/etc/pki/nginx/private/server.key&quot;;# ssl_session_cache shared:SSL:1m;# ssl_session_timeout 10m;# ssl_ciphers HIGH:!aNULL:!MD5;# ssl_prefer_server_ciphers on;## # Load configuration files for the default server block.# include /etc/nginx/default.d/*.conf;## location / {# }## error_page 404 /404.html;# location = /40x.html {# }## error_page 500 502 503 504 /50x.html;# location = /50x.html {# }# }}#注意：此份nginx.conf可以直接复制了去使用！~好用了就给博主打个赏钱！谢谢！ 配置完nginx之后我们该干啥、？当然是重启nginx呗 1sudo systemctl restart nginx #重启nginx 重启完毕，继续打开 http://外网IP地址 来确定Nginx是否已经启动。 此时，服务器启动的是nginx和apache。 而且php-fpm默认发送到apache。 所以咱们还得继续修改一下php-fpm。 配置 php-fpm123vi /etc/php-fpm.d/www.conf #编辑php-fpm配置文件 修改user和group （源代码为：user = apache group = apache） 12user = nginx group = nginx 修改完了之后，还是老样子，重启php-fpm服务 12systemctl restart php-fpm #重启php-fpm 最后，咱们需要为nginx添加站点了添加站点这我先给大家一个截图，以帮助大家迅速的了解是怎么回事 大家应该看的很清楚了，猜都可以猜到，博主这一共配置了三个站点，这三个站点是怎么被nginx引入的呢？ 1我给大家贴出nginx的配置文件的里面应该有这么一句(注意图中的红框，上面的是地址) 123include /etc/nginx/conf.d/*.conf;#这句很重要，引入所有etc/nginx/conf.d/目录下的.conf文件#***etc/nginx/conf.d/目录存放的就是分站点的文件（下面会给出实例代码）*** 好的，大家应该能准确理解了，如果还是理解不了的话只能缺你回去喝点三鹿了！ 下面我给大家贴出nginx站点配置文件的代码，修改修改就可以用看代码的时候请注意看里面的路径，当然我也还是会给一定的中文注释 123456789101112131415161718#这个文件是上面的qopmall.com.confserver { server_name qopmall.com www.qopmall.com;#这里就是你要绑定的域名了，空格分开 location / { root /usr/share/php/weixin; #这里是你站点存放的文件夹名称（也就是说，你当前这个站点的文件全部都丢在这个路径的weixin文件夹里面） index index.php index.html index.htm; #这里照抄即可 } # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # location ~ \\.php$ { root /usr/share/php/weixin; #这里的配置等同于上面的那个root配置 fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /usr/share/php/weixin/$fastcgi_script_name; #这里的配置也是和上面的root配置一样 include fastcgi_params; }} 代码非常简单，我没注释到的不用修改就行。 上面的路径，比如/usr/share/php/weixin 这就是你站点的根目录，我给大家截图参考： 各位童鞋，创建好站点了，先写个简单的php程序测试一下是否正常，比如info。 完","link":"/2017/12/31/centos7-pei-zhi-lnmp-huan-jing-ji-lu/"},{"title":"Centos7配置yum源","text":"Centos7配置yum源我们安装完成CentOS系统，默认都是系统自带的yum源，因为你懂得原因会导致国内用户用yum安装软件的时候比较慢，为了提高效率，一般我们会配置国内的yum源。 目前国内比较好的yum源有网易yum源、搜狐yum源等，现在介绍下怎么配置网易163yum源： 1、首先备份/etc/yum.repos.d/CentOS-Base.repo(不一定是这个名称 你可以看一下 具体叫啥) 1mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 2、根据CentOS不同版本选择下载对应的repo文件，放到/etc/yum.repos.d/ 目录首先进入yum.repos.d目录12cd /etc/yum.repos.d/ CentOS 5.x12wget http://mirrors.163.com/.help/CentOS5-Base-163.repo CentOS 6.x12wget http://mirrors.163.com/.help/CentOS6-Base-163.repo CentOS 7.x12wget http://mirrors.163.com/.help/CentOS7-Base-163.repo 3、最后，执行yum makecache生成缓存清除缓存1yum clean all 生成新缓存1yum makecache OK, 简单3步操作即可配置完成。","link":"/2018/01/12/centos7-pei-zhi-yum-yuan/"},{"title":"台式组装机简单故障的排查与清除","text":"台式组装机简单故障的排查与清除本文主要讲述台式机部分简单故障的排查与清除。 故障一：不能正常开机此故障在电脑使用中最为常见，原因也是五花八门，下面我给大家梳理一些常见的故障以及清除方法： 电脑开机，反复重启这种问题十有八九就是**内存**的问题，下图就是内存：目前主流内存有DDR3和DDR4 如果有空闲的内存插槽，请尝试调整内存安装位置；如不能解决下一条。 如果无法调整位置，请尝试使用橡皮擦蘸酒精擦拭内存金手指位置；如不能解决下一条。 如果无法调整位置，请尝试交换内存安装位置；如不能解决下一条。 如果无法调整位置，请尝试选择拆卸内存，然后每装一根开机一次看看问题是否得到解决，如果确定问题内存建议联系卖家；如不能解决下一条。 实在无法解决请更换内存； 此问题目前我多见于威刚内存 电脑开机主机启动正常，但显示器无反应 这种问题可能是内存的问题，也可能是**显卡问题，下图就是显卡：目前主流显卡很多，AMD的 RX 400、RX 500系列，Nvidia**的 GTX 9 、GTX 10系列； 如果是NVIDIA的10系显卡，请不要使用不带芯片的VGA转接头，尽量使用HDMI线连接显示器； 按照上个故障来排查；如不能解决下一条。 使用核显，将独立显卡从主板中拆除，将原先插在独立显卡上的视频线接到主板上，如果无相应插头建议自行寻找转换接口，如能正常开机则问题出在显卡上，建议联系卖家； 电脑开机自动进入**BIOS**这种问题基本就是电脑的启动项设置不对造成的。 进入电脑主板BIOS，进入启动设置：（没错的话叫 BOOT），选择自己系统所在的硬盘作为首选启动项，保存并退出。如不能解决下一条。 如出系统盘外还有其他硬盘请拆除后开机，看看是否正常。 电脑开机显示下面几张图：CPU Fan Error请尝试检查CPU散热风扇的接线柱，是否正确安装到了CPU_FAN位置，CPU_OPT安装的应该是副风扇（一体水冷的时候基本是水泵） Please enter Setup to recover BIOS setting这个问题基本出现在上了年纪的电脑上，也就是是两年以上的电脑，原因就是主板电池没电了，造成了主板的设置不能正常保存，去附近的电脑店里面一个就OK了，5块钱吧。 故障二：无法上网网络标志显示红叉或者根本没有网络标志这种问题基本就是**网卡**没有启动导致的可能的原因就是驱动没装好 去下载主板网卡在当前系统版本下的驱动，系统版本有32位（X86）和64位（X64）之分，请看清楚 能用部分聊天软件，就是不能打开网页基本**DNS的问题没的跑了,需要修改IP地址** 修改本机当前ip配置。如何修改这个就要看系统版本了，不一样的版本入口不一样 对于win7可以点击小电脑图标-&gt;打开网络与共享设置-&gt;然后左侧边栏更改适配器设置-&gt;找到目前在用的链接(本地连接或者是无线网络)-&gt;右键属性-&gt;选择ipV4-&gt;属性-&gt;勾选手动设置 其他的例如win8 win8.1，win10 基本都一样，如果找不到那么就去搜索控制面板，然后进入网络与Internet 进入网络与共享中心 进入网络适配器页面 进入连接属性 进入ipv4协议属性 手动填写IP地址 这里面的东西如何填写需要根据你的路由器来决定的，基本上家里的设置都是192.168.1.* (* 号填写100-254) 子网掩码 基本都是255.255.255.0 网关也是根据路由器来 192.168.1.1 DNS 第一行也可以根据路由器来：192.168.1.1 或者 指定固定的DNS，比如114.114.114.114 第二行随意 保存 如果上述方法不能解决建议重置网络服务 重置网络服务* 进入命令行工具（管理员模式）* 输入 netsh winsock reset 然后回车* 完成之后重启","link":"/2018/01/10/computer-normal-problem-check-and-fix/"},{"title":"Computer--U盘引导盘制作工具集合","text":"写作目的为了向电脑小白科普目前，使用人数较多的PE引导盘的制作工具软件，这玩意的用处真的是很大很大了。 千万不要说PE只能重装系统。 新硬盘无操作系统无分区，需要PE。 系统忘记登录密码不想重装，需要PE。 系统崩溃还有资料在桌面或者C盘，需要PE。 全盘数据恢复，需要PE。 重建主引导记录（MBR），重建分区表（修复分区表）、修复Windows系统引导，需要PE。 这么有用的东西到底有多少呢，我也不是很清楚，看看下面就知道了。（排名不分先后，想到哪个写哪个） 电脑店这个是我第一次用的制作工具，不知道怎么就给找到了。使用电脑店制作U盘PE系统比较的简单，基本上一键即可轻松制作，支持多种启动模式选择，支持个性化设置，别小看这个个性化设置，里边还隐藏着一些奥妙，为了测试的需要，我们采用默认设置进行PE系统的制作。 电脑店U盘启动盘制作工具，也是常称为的U盘启动制作工具的功能升格版，能更方便电脑技术人员装机、维护电脑使用的超强工具。此作品制作简单，支持所有U盘一键制作成启动盘；兼容多种机型；支持GHO、ISO系统文件，更支持原版系统安装，集成更全面工具，完全可以应对电脑技术人员常见的电脑故障维护工作。 主页：电脑店 - - &gt; http://u.diannaodian.com/ U深度这个是我比较喜欢里面的傲梅分区助手 主页：U深度 - - &gt; http://www.ushendu.info/ 大白菜基本和电脑店差不多，大白菜制作U盘PE系统同样简单，还是一键即可搞定，也支持多种启动模式选择，支持个性化设置，个性化设置里同样隐藏着一些东西，可以自己去研究。 老牌经典PE之一，同时集成服务器版的server 2003和win8PE，支持BIOS/UEFI双启，对古董机器兼容非常好。内置工具比微PE多。集成一键装机，硬盘数据恢复，密码破解，等等实用的程序。 但是个人觉得部分工具重复，工具版本偏老旧、且略为臃肿。另！大白菜PE制作时要事先取消360赞助，否则安装系统后将装上360，不介意用户请忽略。 我觉得大白菜亮点是支持读写苹果分区格式（注意是读写，不是读取！），非常适合黑苹果用户。我也是个黑苹果用户。 主页：大白菜 - - &gt; http://www.dabaicaipe.cn/dbcpe/ 老毛桃基本和电脑店差不多 主页：老毛桃 - - &gt; http://www.laomaotao.org/","link":"/2018/04/05/computer-pe-boot-usb-disk-tools-set/"},{"title":"多站点配置SSH-Key","text":"多站点配置SSH-Key相信很多用mac在开发的同学都会遇见一个问题：会根据业务不同往不同的git服务器上提交代码。这些库有私有的有公有的，这时候就需要配置SSH_Key了。 生成SSH-Key打开终端 （terminal） gitee(码云) · 秘钥对使用以下命令生成gitee的秘钥对【注意】emailaddress 填写自己的邮件地址 1ssh-keygen -t rsa -C &quot;emailaddress&quot; -f ~/.ssh/gitee_id_rsa github · 秘钥对使用以下命令生成github的秘钥对【注意】emailaddress 填写自己的邮件地址 1ssh-keygen -t rsa -C &quot;emailaddress&quot; -f ~/.ssh/github_id_rsa 添加私钥这个步骤是把私钥添加到当前设备，本地的不需要网络 添加 gitee 私钥 1ssh-add ~/.ssh/gitee_id_rsa 添加 github 私钥 1ssh-add ~/.ssh/github_id_rsa 添加公钥 和私钥不一样的是公钥是添加到git服务器的，所以这操作主要是在网页上进行的 添加 gitee 公钥显示出gitee的公钥 1cat ~/.ssh/gitee_id_rsa.pub 将展示出的以ssh-rsa开头，然后以刚才你输入的emailaddress结尾的内容全部复制 添加至gitee的SSHKey公钥 添加 github 公钥显示出github的公钥 1cat ~/.ssh/github_id_rsa.pub 将展示出的以ssh-rsa开头，然后以刚才你输入的emailaddress结尾的内容全部复制 添加至github的SSHKey公钥 创建Config在 ~/.ssh/目录下创建一个配置文件，来为秘钥使用做配置 1cd ~/.ssh/ 使用vim命令进行config文件的创建和编辑 1vim config 然后文件写入以下内容 添加以下内容1234567891011# giteeHost gitee.com HostName gitee.com PreferredAuthentications publickey IdentityFile ~/.ssh/gitee_id_rsa# githubHost github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/github_id_rsa 然后配对秘钥主要测试当前秘钥是否可用 配对gitee秘钥1ssh -T git@gitee.com gitee的测试会让输入 yes 连接gitee成功之后会显示以下信息 Welcome to Gitee.com, yourName! 配对github秘钥1ssh -T git@github.com 连接github成功之后会显示以下信息 Hi yourName! You’ve successfully authenticated, but GitHub does not provide shell access.","link":"/2018/03/14/multwwwconfigssh-key/"},{"title":"解除百度网盘下载限速","text":"众所周知的百度网盘为了迫使用户花钱，对用户的下载速度做出了限制。今天我就来分享一个破解限制的好办法，这个也是网上扒来的。 准备工作1、下载相关资料，也就是两个文件：http://pan.baidu.com/s/1nuPgpNN 2、安装chrome浏览器 3、安装下载的Aria2GUI 1.3.7.dmg 4、安装chrome插件BaiduExporter.zip 解压这个zip文件，然后打开chrome， 使用1、打开刚刚安装的Aria2GUI客户端 2、在chrome里面打开百度云网页,插件安装成功网页上就会多出一个“导出下载”的按钮 3、找到你要下载的文件，并且勾选文件（这里最好先把文件存入自己的网盘目录）,然后点击ARIA2 RPC下载任务就会被客户端执行 4、看一下速度 ATTENSION！！！本项目是MAC OS专用的，windows的目前不清楚安装chrome插件之后,插件原文件就不能移动位置,更不能删除,否则插件就会失效.","link":"/2017/08/09/release-baidunetdisk-downloading-speed-limit/"},{"title":"Windows--如何下载系统","text":"本文主要讲述如何下载原版系统，所谓的原版系统就是微软服务器上的系统镜像，而不是国内各大论坛的GHOST版本，个人并不推荐GHOST以及其他任何第三方封装过的系统。以下载win10 1511中文简体64位为例子 第1步 进入MSDN 网址为http://msdn.itellyou.cn/ 第2步 选择操作系统 第3步 选择你需要的系统版本 windows 10，Version 1511 中文-简体 64位 （X64） 第4步 复制ed2k链接 第5步 打开下载工具，新建一个下载任务，链接就是用刚才复制的链接 下载中最好不要暂停 下载完了之后记得验证SHA1值","link":"/2018/04/01/windows-download-windows-image/"},{"title":"Windows--如何修改IP地址","text":"Windows–如何修改IP地址本文主要讲述windows 7如何修改电脑的**IP地址**。其他的例如win8 win8.1，win10 基本都一样，如果找不到那么就去搜索控制面板，然后进入网络与Internet 进入网络与共享中心 进入网络适配器页面 进入连接属性 进入ipv4协议属性 手动填写IP地址 这里面的东西如何填写需要根据你的路由器来决定的，基本上家里的设置都是192.168.1.* (* 号填写100-254) 子网掩码 基本都是255.255.255.0 网关也是根据路由器来 192.168.1.1 DNS 第一行也可以根据路由器来：192.168.1.1 或者 指定固定的DNS，比如114.114.114.114 第二行随意 保存","link":"/2018/01/11/windows-how-to-change-ip-address/"},{"title":"Windows--验证SHA1 MD5值","text":"日常使用电脑过程中，难免会下载很多文件，比如游戏，软件等等，很多人在下载一个耗时长而又速度不稳定的文件之后，都可能遇见打开文件的时候显示文件被损坏的情况，这时候我们就需要在下载完成之后对文件就行数据完整性校验了。 举个例子，以验证系统的记事本程序的Hash值为例，程序文件的路径为C:\\Windows\\notepad.exe。如果我们想要校验它的MD5值，Win7 可运行： MD5 1certutil -hashfile C:\\Windows\\notepad.exe MD5 SHA1 1certutil -hashfile C:\\Windows\\notepad.exe SHA1 SHA256 1certutil -hashfile C:\\Windows\\notepad.exe SHA256 上面MD5 SHA1 SHA256请不要小写，除了文件路径，其他的要和上面一模一样 Win10 可运行如下命令： Get-FileHash C:\\Windows\\notepad.exe -Algorithm MD5| Format-List 如果想要校验它的SHA1值，则运行如下命令： Get-FileHash C:\\Windows\\notepad.exe -Algorithm SHA1| Format-List 如果想要校验SHA256值，则不需要带-Algorithm参数即可，命令如下： Get-FileHash C:\\Windows\\notepad.exe | Format-List 上面这个文件的路径是可以直接由鼠标拖进去的","link":"/2018/04/01/windows-how-to-verify-the-sha1-md5-value/"},{"title":"Windows--电脑U盘启动盘制作","text":"写在前面本文是博主鉴于当前任然后很大一部分电脑玩家经常为不会给爱机装系统而创作，本博主是一个精通电脑硬件性能以及软件使用的IT人士。 Windows的启动盘分为两类:(随便选择一种方法制作就OK了) 普通BIOS启动的PE类 UEFI启动的EFI类 无论是哪一类大家都不用担心，都有相对应的傻瓜式软件来帮我们完成，我们需要做的就是一下： 找一个U盘，最好是空的（因为无论是哪一种制作方式都可能会格式化这个U盘） U盘的大小最好是8GB左右的（第一种的方式大小无所谓，主要是第二种的方式会占用大量空间） 一台能联网的电脑（这个么有难度吧） 普通BIOS启动的PE类以下将简单介绍如何给Windows电脑制作一个普通BIOS启动的PE类U盘启动盘 准备工作下载U盘启动盘制作工具可以选的种类有很多个：老毛桃，U深度，大白菜，电脑店。。。。下面介绍的是电脑店。 下载地址：http://u.diannaodian.com/down 进入如图页面： 点击下载： 推荐点击本地下载： 然后就是等待下载完毕。。。。。。 在这个时候我们就可以开始对U盘做一些操作了(如果你的U盘不是空的话，如果里面没有东西，这一步可以跳过)，把U盘里面的所有东西都挪到电脑上（除了C盘的任何位置，只要你找的到就行）。 OK下载完了，开始安装：这个软件的安装很简单，就是单纯的吧这个下载的ZIP文件解压而已：我解压到了我的软件盘，盘符为D，如下图： 然后就是插上U盘，这时软件上面的U盘选择项就会出现你的U盘名称： 然后选择启动模式：（个人建议不要动保持USB-HDD模式） 然后选择U盘格式：（个人建议NTFS，因为Fat32有着文件大小的限制，单个文件的大小不得超过4GB） 都选择完了之后，那就点一下鼠标，点击全新制作：接下来就是等了。。。等。。。应该会很快完成之后：点击模拟启动，选择BIOS 至此，U盘启动盘已经制作完成。 UEFI启动的EFI类准备工作下载软碟通 百度就有： 安装： 接受协议，下一步。。。 注意改一下安装路径：（建议不要装在C盘，我的是在D盘） 一直下一步，知道结束 启动 选择继续试用： 选择上方工具栏的文件–打开：（选择你的系统镜像） 然后如图： 选择工具–写入磁盘镜像，插入U盘 点击写入：（没有合适的U盘 所以我这里是不能点的） 注意本类U盘启动盘只能以UEFI模式启动 请设置自己电脑的相关BIOS设置","link":"/2017/08/19/windows-make-pe-boot-usb-disk/"},{"title":"Windows--如何将硬盘分区表转换为GUID(GPT)分区表","text":"如何将硬盘分区表转换为GUID(GPT)分区表如果不知道自己的硬盘分区表类型可以参看 Windows–如何查看硬盘分区表类型 1、使用PE 制作U盘PE启动盘 进入PE 在PE里打开磁盘精灵 （DG） 右键磁盘 菜单中有转换为GUID分区表 2、在安装Win的时候 制作UEFI启动盘 进入UEFI安装的界面 shift + F10 （打开终端） 输入diskpart 回车 （进入diskpart） list disk (显示磁盘列表，注意这里你只能用大小来区分你的硬盘了) sel disk 0 (这个编号你自己看着你的来) clean （清除数据）（可选） convert gpt (转换为GPT分区表，好像是会清除磁盘上数据的) 同理，GPT转换至MBR上述方法同样适用","link":"/2018/02/26/windows-the-hard-disk-partition-table-type-changge-to-guid-gpt/"},{"title":"Windows--UEFI引导安装Win10","text":"Windows–UEFI引导安装Win10本文主要讲述如何使用普通U盘UEFI引导启动盘安装Windows系统 注意此方法只能安装于**GPT(GUID)**分区表的硬盘 准备工作 找一个8GB或更大的U盘 USB3.0更好 这样更快 下载官方ISO系统文件镜像（随便找一个不是C盘的目录放着就行，建议直接扔在D盘根目录） 然后新建一个文件夹叫 WindowsImage 解压这个ISO文件到 WindowsImage文件夹 首先制作UEFI启动盘 U盘格式化为Fat32文件系统（有些主板也支持NTFS，比如我的华硕Z170AR） 将解压好的 WindowsImage文件夹下面的所有文件放入U盘跟目录 注意现在的U盘打开之后应该有好几个文件夹，如下图 选择U盘启动 U盘插在需要装系统的电脑上，然后开机 笔记本：自己去百度你的这个型号如何从U盘启动 台式机：去百度你这个电脑主板的U盘启动方法 看图了正式安装系统下一步 现在安装 随便选一个版本 接受 （不然你还想怎样） 自定义 ： 分区自己看着选这一步建议大家把电脑上除了需要装系统的硬盘 其他的都拆下来 没区分的自己分区 没有引导分区会额外自动创建 点击确定 选择系统安装的盘符 基本就是第一个主分区 下一步 等 还是等 重启的时候就可以把U盘拔下来了，因为U盘的作用已经完了 重启 系统设置中国 随便选 我选拼音 随便 我选跳过 等 针对个人使用 下一步 如果不使用微软账号 就找到左下角 脱机账户 否 名字自己起 密码 填不填都可以 我不喜欢 我选否 我就这样配置 等咯 接着等 这不就OK了 完","link":"/2018/02/03/windows-uefi-boot-installation-win10/"},{"title":"Windows--如何使用PE安装官方ISO镜像","text":"Windows–如何使用PE安装官方ISO镜像本文主要讲述如何使用普通U盘启动盘安装Windows重装系统,注意此方法只能安装于MBR分区表的硬盘 准备工作 制作U盘启动盘–普通PE类 下载官方ISO系统文件镜像（随便找一个不是C盘的目录放着就行，建议直接扔在D盘根目录） 然后新建一个文件夹叫 WindowsImage 解压这个ISO文件到 WindowsImage文件夹 首先 将制作好的U盘插入电脑的usb接口，然后开机 选择U盘启动 笔记本：自己去百度你的这个型号如何从U盘启动 台式机：去百度你这个电脑主板的U盘启动方法 进入PE 出现如下图所示的界面 选择带有运行******x86 或者 *******x64 或者 windwos2003等字样的任何一个启动 进入PE 开始启动了 PE启动完成，现在可以操作了 安装windows系统 打开桌面上的windows安装器 点击install.wim文件的位置一项的选择 找到刚才解压的那个文件夹WindowsImage下的sources文件夹里面的install.wim文件（按大小排序按后最大的那个） 引导磁盘的位置—-选择C（最好自己去看看自己电脑现在在PE下的盘符，看一下你那个系统盘分区的盘符叫什么这里就选什么） 安装磁盘的位置—-选择C（最好自己去看看自己电脑现在在PE下的盘符，看一下你那个系统盘分区的盘符叫什么这里就选什么） 然后点击开始安装 如有对话框，则选择自动重新启动（对win10版本好像没用，需要手动重启）。不选保留原来的windows版本 确定 等待进度条完成 简书：http://www.jianshu.com/p/163b64432e97CSDN：http://blog.csdn.net/ZuoWeiXiaoDuZuoZuo/article/details/78958115 完","link":"/2018/01/03/windows-use-pe-installation-windwos-iso-image/"},{"title":"Windows--如何查看硬盘分区表类型","text":"如何查看硬盘分区表类型1、什么是硬盘分区表人们在使用电脑时，有时由于异常操作，有时由于病毒侵袭，会导致某个分区消失或硬盘无法启动。究其原因，就是硬盘分区表受损。硬盘分区表可以说是支持硬盘正常工作的骨架。操作系统正是通过它把硬盘划分为若干个分区，然后再在每个分区里面创建文件系统，写入数据文件。本文主要讲述的是分区表的位置，结构以及各个分区表是如何链接起来的。当掌握了这些知识后，即使分区表受到破坏，一样也可以根据残存的数据手工修复分区表，从而修复分区。 2、都有什么类型目前在用的 分区表类型主要有了两个： GUID （也叫 GPT）一种由基于 Itanium 计算机中的可扩展固件接口 (EFI) 使用的磁盘分区架构。与主启动记录(MBR) 分区方法相比，GPT 具有更多的优点，因为它允许每个磁盘有多达 128 个分区，支持高达 18 千兆兆字节的卷大小，允许将主磁盘分区表和备份磁盘分区表用于冗余，还支持唯一的磁盘和分区 ID (GUID）。与支持最大卷为 2 TB (terabytes) 并且每个磁盘最多有 4 个主分区（或 3 个主分区，1 个扩展分区和无限制的逻辑驱动器）的主启动记录(MBR)磁盘分区的样式相比，GUID分区表 (GPT) 磁盘分区样式支持最大卷为 18 EB (exabytes) 并且每磁盘最多有 128 个分区。与MBR分区的磁盘不同，至关重要的平台操作数据位于分区，而不是位于非分区或隐藏扇区。另外，GPT 分区磁盘有多余的主要及备份分区表来提高分区数据结构的完整性。 MBR传统的分区方案（称为MBR分区方案）是将分区信息保存到磁盘的第一个扇区（MBR扇区）中的64个字节中，每个分区项占用16个字节，这16个字节中存有活动状态标志、文件系统标识、起止柱面号、磁头号、扇区号、隐含扇区数目（4个字节）、分区总扇区数目（4个字节）等内容。由于MBR扇区只有64个字节用于分区表，所以只能记录4个分区的信息。这就是硬盘主分区数目不能超过4个的原因。后来为了支持更多的分区，引入了扩展分区及逻辑分区的概念。但每个分区项仍用16个字节存储。MBR分区方案不是用得好好的吗？为什么要提出新的方案呢？那就让我们看看MBR分区方案有什么问题。前面已经提到了主分区数目不能超过4个的限制，这是其一，很多时候，4个主分区并不能满足需要。另外最关键的是MBR分区方案无法支持超过2TB容量的磁盘。因为这一方案用4个字节存储分区的总扇区数，最大能表示2的32次方的扇区个数，按每扇区512字节计算，每个分区最大不能超过2TB。磁盘容量超过2TB以后，分区的起始位置也就无法表示了。在硬盘容量突飞猛进的今天，2TB的限制将很快被突破。由此可见，MBR分区方案已经无法满足需要了。 3、怎么查看自己的硬盘分区表桌面–&gt;计算机图标–&gt;右键–&gt;管理–&gt;磁盘管理–&gt;选择一个磁盘（注意是磁盘不是分区）–&gt;右键–&gt;属性–&gt;鼠标左键点击“卷”–&gt;查看“磁盘分区形式”","link":"/2018/02/24/windows-view-the-hard-disk-partition-table-type/"},{"title":"iOS--简单封装AFNetworking","text":"由于本人在工作中经常会进行网络请求，实在是不想一直写那段请求代码，就自己封装了一个LiynNet类。其中使用代理完成方法回调。 这里面涉及到了GET/POST方法。废话不多说直接上代码 下面是.h文件的内容:代理回调协议方法 1234@protocol LiynNetDelegate &lt;NSObject&gt;- (void)netFinsh:(id)object;- (void)netError:(id)errorMsg;@end 这里只有一个属性delegate，用于建立代理关系；这里向外暴露了五个方法，其中第一个类方法用来初始化一个网络请求类的实例化对象，这个对象是一个单例对象，因为网络请求对象，不存储数据，只作为一个单纯的工具类，所以这个对象只需要存在一个就可以。 12345678910@interface LiynNet : NSObject@property (nonatomic, weak) id&lt;LiynNetDelegate&gt; delegate;#pragma mark: method+ (LiynNet *)defaultNet;- (void)uploadPOST:(NSString *)URLString Parameters:(id)parameters UploadDictionary:(NSDictionary*)uploadInfo;- (void)POST:(NSString *)URLString Parameters:(id)parameters;- (void)GET:(NSString *)URLString Parameters:(id)parameters;- (void)GETPic:(NSString *)URLString Parameters:(id)parameters Path:(NSString *)path;@end 下面是.m文件的内容创建单例对象 123456789+(LiynNet *)defaultNet{ static LiynNet *net = nil; if (net == nil) { net = [[LiynNet alloc] init]; net.manager = [AFHTTPSessionManager manager]; net.manager.responseSerializer = [AFHTTPResponseSerializer serializer]; } return net;} 以下是网络请求在这里我就想了定制，因为有时候需要判断返回数据的类型，例如：当一个页面进行多种数据请求时，代理方法只有一个，那么我们就需要一个标记变量来区别这次返回的数据类型是什么。所以这里的parameters字典里需要一个字段msgType来区别。 一般POST下载请求1234567891011- (void)POST:(NSString *)URLString Parameters:(id)parameters{ NSString *msgType = parameters[@&quot;msgType&quot;]; NSLog(@&quot;{\\nmethod:POST \\nURL:%@ \\nParameters:%@&quot;,URLString,parameters); [self.manager POST:URLString parameters:parameters[@&quot;msg&quot;] progress:^(NSProgress * _Nonnull uploadProgress) { } success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { [self success:@{@&quot;msgType&quot;:msgType,@&quot;msg&quot;:responseObject}]; } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) { [self failure:@{@&quot;msgType&quot;:msgType,@&quot;error&quot;:error}]; }];} 一般的GET下载请求1234567891011- (void)GET:(NSString *)URLString Parameters:(id)parameters{ NSString *msgType = parameters[@&quot;msgType&quot;]; NSLog(@&quot;method:GET URL:%@ Parameters:%@&quot;,URLString,parameters); [self.manager GET:URLString parameters:parameters progress:^(NSProgress * _Nonnull downloadProgress) { } success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { [self success:responseObject]; } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) { [self failure:@{@&quot;msgType&quot;:msgType,@&quot;error&quot;:error}]; }];} 一般的POST上传请求注意上传的字段是服务器给定的，传入的字典uploadInfo内@”uploadParameter”对应的值。 123456789101112131415161718192021222324- (void)uploadPOST:(NSString *)URLString Parameters:(id)parameters UploadDictionary:(NSDictionary*)uploadInfo{ NSString *msgType = parameters[@&quot;msgType&quot;]; NSLog(@&quot;{\\nmethod:POST \\nURL:%@ \\nParametersCid:%@&quot;,URLString,parameters[@&quot;msg&quot;]); NSDictionary *dict = parameters[@&quot;msg&quot;]; [self.manager POST: URLString parameters:dict constructingBodyWithBlock:^(id _Nonnull formData) { NSData *rightData = UIImageJPEGRepresentation(uploadInfo[@&quot;image&quot;], 0.7); [formData appendPartWithFileData:rightData name: uploadInfo[@&quot;uploadParameter&quot;] fileName:@&quot;IDRight.png&quot; mimeType:@&quot;image/jpeg&quot;]; } progress:^(NSProgress * _Nonnull uploadProgress) { NSLog(@&quot;%f&quot;,1.0 * uploadProgress.completedUnitCount/uploadProgress.totalUnitCount); } success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { NSDictionary *dict = [NSJSONSerialization JSONObjectWithData:responseObject options:NSJSONReadingMutableContainers error:nil]; [self success:@{@&quot;msgType&quot;:msgType,@&quot;msg&quot;:dict}]; } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) { [self failure:@{@&quot;msgType&quot;:msgType,@&quot;error&quot;:error}]; }];} 两个私有方法请求数据成功12345- (void)success:(id)responseObject{ if (_delegate &amp;&amp; [_delegate respondsToSelector:@selector(netFinsh:)]) { [_delegate netFinsh:responseObject]; }} 请求数据失败12345- (void)failure:(id)error{ if (_delegate &amp;&amp; [_delegate respondsToSelector:@selector(netError:)]) { [_delegate netError:error]; }} 这个类是基于AFNetworking的，所以在使用的时候必须要先倒入AFNetworking的第三方库，建议使用CocoaPods来导入，如果有人不会使用的可以自行百度。 1pod 'AFNetworking', '~&gt; 3.1.0' 首先在使用的类里遵循协议 1&lt;LiynNetDelegate&gt; 声明一个全局的LiynNet类的对象（这个全局只是建议 不全局也可以） 123{ LiynNet *_net;} 或者定义一个属性 1@property (nonatomic, strong) LiynNet *net; 实例化这个LiynNet对象并建立代理关系 12345678#pragma mark - 懒加载-(LiynNet *)net{ if (_net == nil) { _net = [LiynNet defaultNet]; _net.delegate = self; } return _net;} 实现协议的方法在这里你就可以操作返回的数据了 123- (void)netFinsh:(id)object{ NSLog(@&quot;msgType %@\\n msg %@&quot;,object[@&quot;msgType&quot;],object[@&quot;msg&quot;]);} 这里你就需要慢慢查找原因了 1234- (void)netError:(id)errorMsg{ NSLog(@&quot;msgType %@\\n msg %@&quot;, errorMsg[@&quot;msgType&quot;], errorMsg[@&quot;msg&quot;]);}","link":"/2017/07/14/ios-custom-afnetworking/"},{"title":"iOS--自定义多选相册","text":"自定义多选相册一个项目需要类似于安卓的多选相册，而iOS自带的Piker只能单选，所以就想到了自定义，自定义的过程是辛苦的，结果出来之后是高兴的。 写在前面本代码只展示了iOS默认的相册内容，如果读者有其他想法的欢迎再本代码基础上修改。 获取系统默认的相册1234567-(PHFetchResult *)smartAlbums{ if (_smartAlbums == nil) { _smartAlbums = [PHAssetCollection fetchAssetCollectionsWithType:PHAssetCollectionTypeSmartAlbum subtype:PHAssetCollectionSubtypeSmartAlbumUserLibrary options:nil]; } return _smartAlbums;} 获取系统相册中的相片默认的照片排序是时间先后顺序，这里我也规定了按照文件创建的先后顺序来排序呢，为了避免同时引用过多的image导致内存暴增，这里使用的都是缩略图，而且只允许引用前20项。 1234567891011121314151617181920212223242526272829303132333435- (void)initPhotoData{ [self.photoArray removeAllObjects]; __weak typeof(self) weakSelf = self; for (PHCollection * obj in self.smartAlbums) { if ([obj isKindOfClass:[PHAssetCollection class]]) { PHAssetCollection *collection = (PHAssetCollection *)obj; PHFetchOptions *options = [[PHFetchOptions alloc] init]; options.sortDescriptors = @[[NSSortDescriptor sortDescriptorWithKey:@&quot;creationDate&quot; ascending:NO]]; PHFetchResult *fetchReuslt = [PHAsset fetchAssetsInAssetCollection:collection options:options]; NSLog(@&quot;count - %ld&quot;,(unsigned long)fetchReuslt.count); if (fetchReuslt.count == 0) { continue; } NSInteger count = 20&lt;fetchReuslt.count?20:fetchReuslt.count; __block NSInteger _index = 0; for (NSInteger i = 0 ;i&lt;count;i++) { PHAsset *asset = fetchReuslt[i]; //使用PHImageManager从PHAsset中请求图片 NSInteger index = _index; MyImageManager *imageManager = [MyImageManager defaultManager]; [imageManager requestImageForAsset:asset targetSize:CGSizeMake(ItemWidth()*2-2, ItemHieght()*2-2) contentMode:PHImageContentModeAspectFill options:self.requestOption Index:index resultHandler:^(UIImage *result, NSDictionary *info, NSInteger index) { NSInteger IDKey = [info[@&quot;PHImageResultRequestIDKey&quot;] integerValue]; NSLog(@&quot;%@,%ld,%ld,%ld&quot;,result,(long)IDKey,index,IDKey-index); [weakSelf.photoArray addObject:result]; }]; _index++; } }else{ NSLog(@&quot;NO&quot;); NSAssert1(NO, @&quot;Fetch Collect Not PHCollection:%@&quot;, obj); } } NSLog(@&quot;initPhotoDataDone&quot;);} 将获取到的缩略图展示到CollectionView上 这个项目在码云的git库上有，地址为https://git.oschina.net/LiynXu/PhotoDemo.git。 如果有任何意见或者建议，或者发现bug(应该是有的),请移步值git库下给予指导，3Q。","link":"/2017/08/18/ios-custom-ablum/"},{"title":"iOS--实例化对象转换为JSON数据","text":"如何将自定义类的实例化对象转换为JSON数据 我所用的方法是通过Runtime的相关方法，先后两步来实现的。具体往下看： 新建一个类命名为《UserClass》 展示.h文件UserClass.h 1234567891011121314// UserClass.h// MyPickerView// Created by LiynXu on 16/3/7.// Copyright © 2016年 LiynXu. All rights reserved.#import &lt;Foundation/Foundation.h&gt;@interface UserClass : NSObject@property (nonatomic,strong) NSString *name;@property (nonatomic,strong) NSString *password;@property (nonatomic,assign) NSInteger age;@property (nonatomic,strong) NSString *sex;- (instancetype)initWithName:(NSString *)name Password:(NSString *)password;- (NSDictionary *)convertToDictWithObject:(NSObject *)object;//主要使用这个方法得到一个字典@end 由上面的头文件可以看出我所建立的类有4个属性：name，password，age，sex。并且包含一个初始化方法，和对象转字典的方法(了解过Runtime，所以知道了Runtime可以在运行时某个对象的所有属性，以及属性的相关值) 具体实现方法 第一步将自定义类的实例化对象转为字典，这一步需要结合Runtime进行，所以我们需要做一个操作就是导入一个头文件 #import &lt;objc/runtime.h&gt;//当前需要使用使用运行时库 第二步使用第一部得到的字典转为JSON数据 1234567891011121314151617// UserClass.m// MyPickerView// Created by LiynXu on 16/3/7.// Copyright © 2016年 LiynXu. All rights reserved.#import &quot;UserClass.h&quot;#import &lt;objc/runtime.h&gt;//当前需要使用使用运行时库@implementation UserClass-(instancetype)initWithName:(NSString *)name Password:(NSString *)password{ self= [super init]; if (self) { _name = name; _password = password; } return self;} 上面的主要是一个初始化方法，重要的是下面，下面，下面！ 123456789101112131415161718- (NSDictionary *)convertToDictWithObject:(NSObject *)object{//获取当前对象的所有属性以及属性的值 NSMutableDictionary *Dict = [NSMutableDictionary dictionary]; unsigned int outCount, i; objc_property_t *properties = class_copyPropertyList([object class], &amp;outCount); //获取所有属性以及属性的值,并且转换为一个字典 for (i = 0; i&lt;outCount; i++){ objc_property_t property = properties[i]; const char* char_f =property_getName(property); NSString *propertyName = [NSString stringWithUTF8String:char_f]; id propertyValue = [self valueForKey:(NSString *)propertyName]; if (propertyValue) [Dict setObject:propertyValue forKey:propertyName]; } free(properties); return Dict;}@end 程序入口main.m 包含具体示例代码 123456789101112131415161718192021222324252627282930313233//// main.m// JsonCode//// Created by LiynXu on 16/3/7.// Copyright © 2016年 LiynXu. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;#import &quot;UserClass.h&quot;int main(int argc, const char * argv[]) { @autoreleasepool { UserClass *user = [[UserClass alloc] initWithName:@&quot;name&quot; Password:@&quot;password&quot;]; NSDictionary *codeDict = [user convertToDictWithObject:user];//对象转字典， NSLog(@&quot;%@&quot;,codeDict); NSData *jsonData = [NSJSONSerialization dataWithJSONObject:codeDict options:NSJSONWritingPrettyPrinted error:nil];//字典转json code NSLog(@&quot;%@&quot;,jsonData); NSFileManager *fileManager = [NSFileManager defaultManager]; NSString *path = [NSString stringWithFormat:@&quot;%@/Document/jsonData.json&quot;,NSHomeDirectory()]; BOOL res=[fileManager createFileAtPath:path contents:nil attributes:nil]; if (res) { NSLog(@&quot;文件创建成功: %@&quot; ,path); }else NSLog(@&quot;文件创建失败: %@&quot; ,path); NSString *jsonStrong = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding]; //json转字符串 NSLog(@&quot;%@&quot;,jsonStrong); NSDictionary *decodeDict = [NSJSONSerialization JSONObjectWithData:jsonData options:NSJSONReadingMutableContainers error:nil]; //json Decode NSLog(@&quot;%@&quot;,decodeDict); } return 0;}","link":"/2017/08/18/ios-custom-object-to-json-runtime/"},{"title":"获取iOS设备型号，目前所有iOS设备","text":"简介获取iOS设备型号，目前所有iOS设备皆可识别 下面是.h文件 声明这个返回值为NSString的类方法 1234567891011121314151617// GetDeviceModel.h// Created by LiynXu on 15/11/10.// Copyright © 2015年 LiynXu. All rights reserved.// xxl652170427@163.com#import &lt;Foundation/Foundation.h&gt;@interface GetDeviceModel : NSObject/* 获取设备描述 */+ (NSString *)getCurrentDeviceModelDescription;/* 由获取到的设备描述，来匹配设备型号 */+ (NSString *)getCurrentDeviceModel;@end 返回值为NSString的类方法 获取设备描述 12345678910111213141516+ (NSString *)getCurrentDeviceModelDescription{ int mib[2]; size_t len; char *machine; mib[0] = CTL_HW; mib[1] = HW_MACHINE; sysctl(mib, 2, NULL, &amp;len, NULL, 0); machine = malloc(len); sysctl(mib, 2, machine, &amp;len, NULL, 0); NSString *platform = [NSString stringWithCString:machine encoding:NSASCIIStringEncoding]; free(machine); return platform;} 由获取到的设备描述，来匹配设备型号 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485+ (NSString *)getCurrentDeviceModel{ NSString *platform = [GetDeviceModel getCurrentDeviceModelDescription]; if ([platform isEqualToString:@&quot;iPhone1,1&quot;]) return @&quot;iPhone 2G&quot;; if ([platform isEqualToString:@&quot;iPhone1,2&quot;]) return @&quot;iPhone 3G&quot;; if ([platform isEqualToString:@&quot;iPhone2,1&quot;]) return @&quot;iPhone 3GS&quot;; if ([platform isEqualToString:@&quot;iPhone3,1&quot;]) return @&quot;iPhone 4&quot;; if ([platform isEqualToString:@&quot;iPhone3,2&quot;]) return @&quot;iPhone 4&quot;; if ([platform isEqualToString:@&quot;iPhone3,3&quot;]) return @&quot;iPhone 4&quot;; if ([platform isEqualToString:@&quot;iPhone4,1&quot;]) return @&quot;iPhone 4S&quot;; if ([platform isEqualToString:@&quot;iPhone5,1&quot;]) return @&quot;iPhone 5&quot;; if ([platform isEqualToString:@&quot;iPhone5,2&quot;]) return @&quot;iPhone 5&quot;; if ([platform isEqualToString:@&quot;iPhone5,3&quot;]) return @&quot;iPhone 5c&quot;; if ([platform isEqualToString:@&quot;iPhone5,4&quot;]) return @&quot;iPhone 5c&quot;; if ([platform isEqualToString:@&quot;iPhone6,1&quot;]) return @&quot;iPhone 5s&quot;; if ([platform isEqualToString:@&quot;iPhone6,2&quot;]) return @&quot;iPhone 5s&quot;; if ([platform isEqualToString:@&quot;iPhone7,1&quot;]) return @&quot;iPhone 6 Plus&quot;; if ([platform isEqualToString:@&quot;iPhone7,2&quot;]) return @&quot;iPhone 6&quot;; if ([platform isEqualToString:@&quot;iPhone8,1&quot;]) return @&quot;iPhone 6S&quot;; if ([platform isEqualToString:@&quot;iPhone8,2&quot;]) return @&quot;iPhone 6S Plus&quot;; if ([platform isEqualToString:@&quot;iPhone9,1&quot;]) return @&quot;iPhone 7 A1660&quot;; if ([platform isEqualToString:@&quot;iPhone9,2&quot;]) return @&quot;iPhone 7 Plus A1661&quot;; if ([platform isEqualToString:@&quot;iPhone9,3&quot;]) return @&quot;iPhone 7 A1778&quot;; if ([platform isEqualToString:@&quot;iPhone9,4&quot;]) return @&quot;iPhone 7 Plus A1784&quot;; if ([platform isEqualToString:@&quot;iPod1,1&quot;]) return @&quot;iPod Touch 1G&quot;; if ([platform isEqualToString:@&quot;iPod2,1&quot;]) return @&quot;iPod Touch 2G&quot;; if ([platform isEqualToString:@&quot;iPod3,1&quot;]) return @&quot;iPod Touch 3G&quot;; if ([platform isEqualToString:@&quot;iPod4,1&quot;]) return @&quot;iPod Touch 4G&quot;; if ([platform isEqualToString:@&quot;iPod5,1&quot;]) return @&quot;iPod Touch 5G&quot;; if ([platform isEqualToString:@&quot;iPad1,1&quot;]) return @&quot;iPad 1G&quot;; if ([platform isEqualToString:@&quot;iPad2,1&quot;]) return @&quot;iPad 2&quot;; if ([platform isEqualToString:@&quot;iPad2,2&quot;]) return @&quot;iPad 2&quot;; if ([platform isEqualToString:@&quot;iPad2,3&quot;]) return @&quot;iPad 2&quot;; if ([platform isEqualToString:@&quot;iPad2,4&quot;]) return @&quot;iPad 2&quot;; if ([platform isEqualToString:@&quot;iPad2,5&quot;]) return @&quot;iPad Mini 1G&quot;; if ([platform isEqualToString:@&quot;iPad2,6&quot;]) return @&quot;iPad Mini 1G&quot;; if ([platform isEqualToString:@&quot;iPad2,7&quot;]) return @&quot;iPad Mini 1G&quot;; if ([platform isEqualToString:@&quot;iPad3,1&quot;]) return @&quot;iPad 3&quot;; if ([platform isEqualToString:@&quot;iPad3,2&quot;]) return @&quot;iPad 3&quot;; if ([platform isEqualToString:@&quot;iPad3,3&quot;]) return @&quot;iPad 3&quot;; if ([platform isEqualToString:@&quot;iPad3,4&quot;]) return @&quot;iPad 4&quot;; if ([platform isEqualToString:@&quot;iPad3,5&quot;]) return @&quot;iPad 4&quot;; if ([platform isEqualToString:@&quot;iPad3,6&quot;]) return @&quot;iPad 4&quot;; if ([platform isEqualToString:@&quot;iPad4,1&quot;]) return @&quot;iPad Air&quot;; if ([platform isEqualToString:@&quot;iPad4,2&quot;]) return @&quot;iPad Air&quot;; if ([platform isEqualToString:@&quot;iPad4,3&quot;]) return @&quot;iPad Air&quot;; if ([platform isEqualToString:@&quot;iPad4,4&quot;]) return @&quot;iPad Mini 2G &quot;; if ([platform isEqualToString:@&quot;iPad4,5&quot;]) return @&quot;iPad Mini 2G &quot;; if ([platform isEqualToString:@&quot;iPad4,6&quot;]) return @&quot;iPad Mini 2G &quot;; if ([platform isEqualToString:@&quot;iPad4,7&quot;]) return @&quot;iPad Mini 3 &quot;; if ([platform isEqualToString:@&quot;iPad4,8&quot;]) return @&quot;iPad Mini 3 &quot;; if ([platform isEqualToString:@&quot;iPad4,9&quot;]) return @&quot;iPad Mini 3 &quot;; if ([platform isEqualToString:@&quot;iPad5,1&quot;]) return @&quot;iPad Mini 4 WiFi &quot;; if ([platform isEqualToString:@&quot;iPad5,2&quot;]) return @&quot;iPad Mini 4 WiFi+Cellular &quot;; if ([platform isEqualToString:@&quot;iPad5,3&quot;]) return @&quot;iPad Air2 &quot;; if ([platform isEqualToString:@&quot;iPad5,4&quot;]) return @&quot;iPad Air2 &quot;; if ([platform isEqualToString:@&quot;iPad6,7&quot;]) return @&quot;iPad Pro WiFi 12.7-inch&quot;; if ([platform isEqualToString:@&quot;iPad6,8&quot;]) return @&quot;iPad Pro WiFi+Cellular 12.7-inch&quot;; if ([platform isEqualToString:@&quot;iPad6,3&quot;]) return @&quot;iPad Pro WiFi 9.7-inch&quot;; if ([platform isEqualToString:@&quot;iPad6,4&quot;]) return @&quot;iPad Pro WiFi+Cellular 9.7-inch&quot;; if ([platform isEqualToString:@&quot;i386&quot;]) return @&quot;iPhone Simulator&quot;; if ([platform isEqualToString:@&quot;x86_64&quot;]) return @&quot;iPhone Simulator&quot;; return platform;} 如何使用首先在.m文件中导入以下两个头文件 12#import &quot;GetDeviceModel.h&quot;#import &lt;sys/sysctl.h&gt; 然后在需要获取设备型号地方这样写,用一个NSString类型的对象接收 12NSString *string = [GetDeviceModel getCurrentDeviceModel];NSLog(@&quot;设备型号:%@&quot;,string); 也可以给当前app的AppDelegate添加一个DeviceModel属性,一下是AppDelegate的.h文件内容 1234567#import &lt;UIKit/UIKit.h&gt;@interface AppDelegate : UIResponder &lt;UIApplicationDelegate&gt;@property (strong, nonatomic) UIWindow *window;@property (nonatomic,copy) NSString *DeviceModel;@end 然后直接想下面这样用就行了 1self.DeviceModel = [GetDeviceModel getCurrentDeviceModel]; 完整代码演示：https://git.oschina.net/LiynXu/GetDeviceModel.git 欢迎访问！效果展示：","link":"/2017/08/18/ios-get-ios-device-model/"},{"title":"iOS HealthKit简单介绍","text":"HealthKit简单介绍目前很多App都会有访问健康数据的需求，那么我们就不得不使用HealthKit。HealthKit框架提供了一个结构，应用可以使用它来分享健康和健身数据。HealthKit管理从不同来源获得的数据，并根据用户的偏好设置，自动将不同来源的所有数据合并起来。应用还可以获取每个来源的原始数据，然后执行自己的数据合并。 如何在项目中集成HealthKit这一个部分我们将一步一步的在项目中集成HealthKit。 第一步添加HealthKit1、进入项目设置–&gt;Capabilities–&gt;HealthKit，然后如下图打开就可以了，如果下面几个选项前都打上了勾的话，那么就代表OK了，一般也不会出现X。 2、如果上面的步骤完成了的话那么在工程目录下会多一个文件，这个文件以工程名命名，后缀名为entitlements，如下图： 3、并且在Frameworks目录下会多一个HealthKit.framework文件： 项目中的使用首先要在需要访问健康数据的地方，使用import导入HealthKit头文件： 1#import &lt;HealthKit/HealthKit.h&gt; 然后写一个属性： 1@property (nonatomic, strong) HKHealthStore *healthStore; 1、这一步为你的应用实例化一个 HKHealthStore 对象。每个应用只需要一个HealthKit存储实例。这个存储实例就是你和HealthKit数据库交互的主要接口。 1self.healthStore = [[HKHealthStore alloc] init]; 2、 调用 isHealthDataAvailable 方法来查看HealthKit在该设备上是否可用。HealthKit在iPad上不可用。 123if ([HKHealthStore isHealthDataAvailable]) { NSLog(@&quot;HealthDataAvailable&quot;); } 3、在项目中具体代码： 123456789101112131415161718192021222324//创建想要获取的数据类型 HKObjectType *stepCpunt = [HKObjectType quantityTypeForIdentifier:HKQuantityTypeIdentifierStepCount];//步数 HKObjectType *Height = [HKObjectType quantityTypeForIdentifier:HKQuantityTypeIdentifierHeight];//身高 HKObjectType *BodyMass = [HKObjectType quantityTypeForIdentifier:HKQuantityTypeIdentifierBodyMass];//体重 HKObjectType *DistanceWalkingRunning = [HKObjectType quantityTypeForIdentifier:HKQuantityTypeIdentifierDistanceWalkingRunning];//步行+跑步距离 HKObjectType *DistanceCycling = [HKObjectType quantityTypeForIdentifier:HKQuantityTypeIdentifierDistanceCycling];//骑行距离 //一个集合，数据类型 NSSet *healthSet = [NSSet setWithObjects:stepCpunt,Height,BodyMass,DistanceWalkingRunning,DistanceCycling,nil]; //[self.healthStore requestAuthorizationToShareTypes:nil readTypes:healthSet completion:nil]; //向系统的健康APP请求数据，并回调结果 [self.healthStore requestAuthorizationToShareTypes:nil readTypes:healthSet completion:^(BOOL success, NSError * _Nullable error) { if (success) { NSLog(@&quot;requestAuthorization success&quot;); [self readHealthData:HKQuantityTypeIdentifierStepCount]; [self readHealthData:HKQuantityTypeIdentifierDistanceWalkingRunning]; [self readHealthData:HKQuantityTypeIdentifierDistanceCycling]; [self readHealthData:HKQuantityTypeIdentifierHeight]; [self readHealthData:HKQuantityTypeIdentifierBodyMass]; }else{ NSLog(@&quot;requestAuthorization error&quot;); } }]; 具体的数据获的操作 123456789101112131415161718192021222324252627282930313233//查询数据- (void)readHealthData:(NSString* )HKQuantityTypeIdentifierType{ //查询采样信息 HKSampleType *sampleType = [HKQuantityType quantityTypeForIdentifier:HKQuantityTypeIdentifierType]; //NSSortDescriptors用来告诉healthStore怎么样将结果排序。 NSSortDescriptor *start = [NSSortDescriptor sortDescriptorWithKey:HKSampleSortIdentifierStartDate ascending:NO]; NSSortDescriptor *end = [NSSortDescriptor sortDescriptorWithKey:HKSampleSortIdentifierEndDate ascending:NO]; /* 查询的基类是HKQuery，这是一个抽象类，能够实现每一种查询目标，这里我们需要查询的步数是一个 HKSample类所以对应的查询类就是HKSampleQuery。 下面的limit参数传1表示查询最近一条数据,查询多条数据只要设置limit的参数值就可以了 在这里我们需要定义block里面执行哪些语句 */ HKSampleQuery *sampleQuery = [[HKSampleQuery alloc] initWithSampleType:sampleType predicate:nil limit:2 sortDescriptors:@[start,end] resultsHandler:^(HKSampleQuery * _Nonnull query, NSArray&lt;__kindof HKSample *&gt; * _Nullable results, NSError * _Nullable error) { //打印查询结果 NSLog(@&quot;resultCount = %ld result = %@&quot;,results.count,results); //把结果装换成字符串类型 if (results.count!=0) { HKQuantitySample *result = results[0]; HKQuantity *quantity = result.quantity; NSString *stepStr = (NSString *)quantity; [[NSOperationQueue mainQueue] addOperationWithBlock:^{ //查询是在多线程中进行的，如果要对UI进行刷新，要回到主线程中 NSLog(@&quot;最新数据：%@&quot;,stepStr); }]; }else{ NSLog(@&quot;没有健康数据&quot;); } }]; //执行查询 [self.healthStore executeQuery:sampleQuery];} 运行结果在这里","link":"/2017/08/18/ios-healthkit/"},{"title":"通过assetURL获取到视频","text":"首先导入头文件 1#import &lt;Photos/Photos.h&gt; iOS中assetURL样式： 1assets-library://asset/asset.mov?id=F2E6E143-4343-4B57-87F9-346936E0EDB3&amp;ext=mov 使用当前的URL过滤到我们想要的数据 1234567891011121314151617181920212223242526272829303132PHFetchResult *result = [PHAsset fetchAssetsWithALAssetURLs:@[assetUrl] options:nil]; PHAsset * PHAsset = result.firstObject; /// 包含该视频的基础信息 PHAssetResource * resource = [[PHAssetResource assetResourcesForAsset: PHAsset] firstObject]; NSLog(@&quot;%@&quot;,resource); /* type: originalFilename: */ PHImageRequestOptions * options = [[PHImageRequestOptions alloc] init]; options.version = PHImageRequestOptionsVersionCurrent; options.deliveryMode = PHImageRequestOptionsDeliveryModeHighQualityFormat; options.synchronous = YES; __block NSData *videoData = nil; [[PHImageManager defaultManager] requestImageDataForAsset: PHAsset options: options resultHandler: ^(NSData * imageData, NSString * dataUTI, UIImageOrientation orientation, NSDictionary * info) { NSLog(@&quot;%@&quot;,imageData); //这里的imageData就是视频数据; }];","link":"/2017/12/14/ios-use-asseturl-get-vedio/"},{"title":"水波纹-OC-iOS","text":"简介使用iOS原生CoreGraphic框架完成，主要内容就是在给定的路径上绘制出图形，水波纹的实现是按照三角函数的sin函数来实现的，利用sin函数计算出大量的点，然后做颜色填充。 实现方法首先一个波纹需要一个layer来进行渲染，越底层的波纹要越早绘制，本Demo只实现了双波纹交错。水波纹基本属性： 不需要对外暴露的属性 12345678@interface WaterRippleView(){ float _currentLinePointY;}@property (nonatomic, strong)CADisplayLink *rippleDisplayLink;//苹果的垂直同步@property (nonatomic, strong)CAShapeLayer *mainRippleLayer;//主波图层@property (nonatomic, strong)CAShapeLayer *minorRippleLayer;//次波图层@property (nonatomic, assign)CGFloat rippleWidth;//波浪宽度@end 可以对外暴露的属性 1234567@property (nonatomic, strong)UIColor *mainRippleColor;//主波填充颜色@property (nonatomic, strong)UIColor *minorRippleColor;//次波填充颜色@property (nonatomic, assign)CGFloat mainRippleoffsetX;//主波偏移量@property (nonatomic, assign)CGFloat minorRippleoffsetX;//次波偏移量@property (nonatomic, assign)CGFloat rippleSpeed;//波浪速度@property (nonatomic, assign)CGFloat ripplePosition;//波浪Y轴位置@property (nonatomic, assign)float rippleAmplitude;//波浪振幅 各属性的默认值设置 12345678self.mainRippleColor = [UIColor colorWithRed:255/255.0f green:127/255.0f blue:80/255.0f alpha:1];self.minorRippleColor = [UIColor whiteColor];self.mainRippleoffsetX = 1;self.minorRippleoffsetX = 2;self.rippleSpeed = .5f;self.rippleWidth = frame.size.width;self.ripplePosition = frame.size.height-10.0f;self.rippleAmplitude = 5; 对外暴露的方法 1234//设置frame 主波填充颜色 次波填充颜色- (instancetype)initWithFrame:(CGRect)frame mainRippleColor:(UIColor *)mainRippleColor minorRippleColor:(UIColor *)minorRippleColor;//设置frame 主波填充颜色 次波填充颜色 主波偏移量 次波偏移量 波浪速度 波浪Y轴位置 波浪振幅- (instancetype)initWithFrame:(CGRect)frame mainRippleColor:(UIColor *)mainRippleColor minorRippleColor:(UIColor *)minorRippleColor mainRippleoffsetX:(float)mainRippleoffsetX minorRippleoffsetX:(float)minorRippleoffsetX rippleSpeed:(float)rippleSpeed ripplePosition:(float)ripplePosition rippleAmplitude:(float)rippleAmplitude; 在view中需要绘制图形时，要在自带的dramRect：方法中编写相关代码 123456789101112131415- (void)drawRect:(CGRect)rect { /* *创建两个layer */ self.mainRippleLayer = [CAShapeLayer layer]; self.mainRippleLayer.fillColor = self.mainRippleColor.CGColor; [self.layer addSublayer:self.mainRippleLayer]; self.minorRippleLayer = [CAShapeLayer layer]; self.minorRippleLayer.fillColor = self.minorRippleColor.CGColor; [self.layer addSublayer:self.minorRippleLayer]; self.rippleDisplayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(getCurrentRipple)]; [self.rippleDisplayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];} 下面是绘制代码：主波 123456789101112131415- (void)drawMainRipple{ self.mainRippleoffsetX += self.rippleSpeed; CGMutablePathRef path = CGPathCreateMutable(); CGPathMoveToPoint(path, nil, 0, self.ripplePosition); CGFloat y = 0.f; for (float x = 0.f; x &lt;= self.rippleWidth ; x++) { y = self.rippleAmplitude * sin(1.2 * M_PI/ self.rippleWidth * x - self.mainRippleoffsetX *M_PI/180) + self.ripplePosition; CGPathAddLineToPoint(path, nil, x, y); } CGPathAddLineToPoint(path, nil, self.rippleWidth, self.frame.size.height); CGPathAddLineToPoint(path, nil, 0, self.frame.size.height); CGPathCloseSubpath(path); self.mainRippleLayer.path = path; CGPathRelease(path);} 次波 12345678910111213141516- (void)drawMinorRipple{ self.minorRippleoffsetX += self.rippleSpeed+0.1f; CGMutablePathRef minorRipple = CGPathCreateMutable(); CGPathMoveToPoint(minorRipple, nil, 0, self.ripplePosition); CGFloat y = 0.f; for (float x = 0.f; x &lt;= self.rippleWidth ; x++) { y = self.rippleAmplitude * sin(1.2 * M_PI/ self.rippleWidth * x - self.minorRippleoffsetX*M_PI/360 ) + self.ripplePosition; CGPathAddLineToPoint(minorRipple, nil, x, y); } CGPathAddLineToPoint(minorRipple, nil, self.rippleWidth, self.frame.size.height); CGPathAddLineToPoint(minorRipple, nil, 0, self.frame.size.height); CGPathCloseSubpath(minorRipple); self.minorRippleLayer.path = minorRipple; CGPathRelease(minorRipple);} 实现效果 最后本Demo的git库地址：https://git.oschina.net/LiynXu/waterripple.git欢迎访问","link":"/2017/07/14/ios-water-ripple-oc/"},{"title":"斐讯K2刷华硕固件","text":"写在前面斐讯K2是一款处于1200Mbps(300+867Mbps)无线速率段的双频802.11ac路由器，2.4G+5G双频并发，PA+LNA强强组合，智能管理轻松控制，斐讯K2完美诠释了“家再大，隔墙再多，WiFi信号不受阻隔”的上网体验。斐讯K2路由器可以在京东免费撸，很多朋友撸回家发现固件太垃圾，各种不好用，因此想把斐讯K2刷成华硕固件。 中关村斐讯K2 重要说明 据说，这种方法支持斐讯K2的固件版本为： 22.3.15.128 22.3.15.232 22.3.17.148 22.4.2.8 22.4.2.9 如果目前你的斐讯K2路由器的固件版本高于或者低于这几个版本，可以进行升级或者降级操作，然后按照。下面我会提供相关文件的下载地址，方便大家下载后进行升级和降级操作。点击 百度网盘或者复制链接: https://pan.baidu.com/s/1gfssXUz 密码: qdke 第一步：——自带固件降级—–降级分为两个版本，一个是老版本22.5.9，另外一个是22.5.11，因为在.11版本降级会出现提示，非法固件而不允许刷机，那么我们就是用另外一种方法来进行刷机 首先22.5.9版本降级第1步a、进入系统设置，找到手动升级，选择k2_163_v11_breed.bin ，然后升级 第2步a、升级完成后，断开路由器电源。 b、按住复位键，插上电源，等待7秒钟后松开复位键。 第3步 a、进入breed web设置页面 22.5.11版本降级第1步1、安装Firefox浏览器。 2、用网线连接电脑和路由器的Lan口（WAN口无所谓，联不联网无所谓），K1、K2默认登录密码修改为admin。 第2步、开启telnet工作1、打开Firefox浏览器登陆斐讯路由器，选择右上角的“定时重启路由器”，如图。 2、点击指定重启时间，将鼠标箭头放到05上，右键选择“查看元素”。注意一定要放在05上； 3、在查看器中将鼠标移到”05”上（找不到05的话刷新一下网页），点击鼠标右键，选择“编程HTML”。 4、将”05”改成”01:00 | telnetd -l /bin/login.sh”（复制粘贴即可），然后鼠标移动到黑框之外的空白处点击鼠标左键，就可以完成编辑了。 5、在定时重启路由器页面上选择05之后（注意现在回变成1：00…..），点击“保存”。 那么现在就完成了开启K2路由器telnet服务的工作。6、下载目录内breed Web助手（3.4版本）–&gt;关闭防火墙，退出杀毒软件–&gt;找到这个文件“路由器刷breed Web助手通用版v3.0”–&gt;右键以管理员身份运行 7、如图刷机方案选择：”通用方案[需要开启路由器telnet或ssh]”，然后点击开始刷机； 8、完成后这样就完成了斐讯路由器刷入不死Breed。 第二步： a、进入breed界面 b、在菜单固件更新中，选择文件哪一行，选择SW_K2_703004657_V22.4.2.8.bin 固件 c、等待上传完成 e、请等待升级完成，自动重启后。然后按住复位键7秒，等待重启后。 到此你的路由器固件成功降级到了22.4.2.8 f、注意右下角的固件版本号 ——刷入华硕固件—–第1步–刷入breed和ssh a、点击“高级设置”——&gt;“备份恢复”——&gt;“浏览”找到刚才下载的：tianbaoha_breed_ssh.dat文件——&gt;“恢复备份”。 b、路由器会自动重启，等待重启完成 c、验证 斐讯K2重启完成后，重新在浏览器中输入p.to或者192.168.2.1，打开登录界面，管理密码用：tianbaoha 。如果可以登录到设置界面，说明breed和ssh已经刷入成功。 第2步a、管理密码用：tianbaoha 登录到K2的设置界面后，点击“高级设置”——&gt;“系统设置”——&gt;“手动升级”——&gt;点击 下载备份EEPROM，如下图所示。 第3步–刷写华硕固件**登录地址：192.168.123.1 ****管理账号：admin/admin **默认wifi密码：1234567890 a、点击“高级设置”——&gt;“系统设置”——&gt;“手动升级”——&gt;点击“浏览”，找到刚才下载的华硕固件:RT-AC54U-GPIO-1-PSG1208-64M_3.4.3.9-099.trx b、点击“升级”。 第4步 a、等待路由器重启。 b、在浏览器中输入：192.168.123.1 打开登录界面——&gt;用户名和密码用：admin/admin，登录到界面了 结束","link":"/2017/08/18/fei-xun-k2-shua-hua-shuo-gu-jian/"},{"title":"iOS--富文本推送NotificationContentExtension","text":"NotificationContentExtension文件根据以下ContentExtension Info.plist文件中的配置决定category的设置，两者必须一致： NSExtensionPrincipalClass对应的值是你展示视图的controller（这里就是NotificationViewController） 宏定义采用下列代码： 12345678910111213141516//推送相关设置#define Action_Category_Identifier_Image @&quot;Image_Category&quot; //图片类别标识符#define Action_Category_Identifier_Audio @&quot;Audio_Category&quot; //音频类别标识符#define Action_Category_Identifier_Movie @&quot;Movie_Category&quot; //视频类别标识符#define Action_Identifier_Image_Confirm @&quot;imageConfirmAction&quot; //图片确认按钮#define Action_Identifier_Image_Concel @&quot;imageConcelAction&quot; //图片取消按钮#define Action_Identifier_Audio_Confirm @&quot;audioConfirmAction&quot; //音频确认按钮#define Action_Identifier_Audio_Concel @&quot;audioConcelAction&quot; //音频取消按钮#define Action_Identifier_Movie_Confirm @&quot;movieConfirmAction&quot; //视频确认按钮#define Action_Identifier_Movie_Concel @&quot;movieConcelAction&quot; //视频取消按钮#define Action_Title_Image_Confirm @&quot;查看&quot; //图片确认按钮标题#define Action_Title_Image_Concel @&quot;忽略&quot; //图片取消按钮标题#define Action_Title_Audio_Confirm @&quot;查看&quot; //音频确认按钮标题#define Action_Title_Audio_Concel @&quot;忽略&quot; //音频取消按钮标题#define Action_Title_Movie_Confirm @&quot;查看&quot; //视频确认按钮标题#define Action_Title_Movie_Concel @&quot;忽略&quot; //视频取消按钮标题 采用的是自定义布局，注意如果想使用这个布局的话，你必须提前在service里面设置好categoryIdentifier，它的值是你plist文件里面的任何一个 1234@interface NotificationViewController () &lt;UNNotificationContentExtension&gt;@property (nonatomic, strong)UIImageView *imageView;@property (nonatomic,strong)UILabel *label;@end LazyLoad 1234567-(UIImageView *)imageView{ if (_imageView == nil) { _imageView = [[UIImageView alloc] init]; _imageView.contentMode = UIViewContentModeScaleAspectFit; } return _imageView;} AddView 123456- (void)viewDidLoad { [super viewDidLoad]; [self.view addSubview:self.imageView]; // Do any required interface initialization here.} 取出多媒体资料并展示到视图上，下面为image 123456789101112131415161718- (void)didReceiveNotification:(UNNotification *)notification { NSLog(@&quot;notification.request.content.userInfo%@&quot;,notification.request.content.userInfo); UNNotificationContent * content = notification.request.content; CGFloat widthTime = 2; if ([UIScreen mainScreen].bounds.size.width&gt;375) { widthTime = 3.0; } UIImage *image = nil; if (content.attachments.count) { UNNotificationAttachment * attachment_img = content.attachments[0]; if (attachment_img.URL.startAccessingSecurityScopedResource) { image = [UIImage imageWithContentsOfFile:attachment_img.URL.path]; self.imageView.image = image; } } self.imageView.frame = self.view.frame; self.label.text = notification.request.content.body;} 响应相关Action 12345678910111213141516171819202122232425-(void)didReceiveNotificationResponse:(UNNotificationResponse *)response completionHandler:(void (^)(UNNotificationContentExtensionResponseOption))completion{ UNNotificationContent *content = [response.notification.request.content mutableCopy]; NSString *category = content.categoryIdentifier; NSString *actionIdentifier = [response.actionIdentifier copy]; if ([category isEqualToString:Action_Category_Identifier_Image]) { if ([actionIdentifier isEqualToString:Action_Identifier_Image_Confirm]) { completion(UNNotificationContentExtensionResponseOptionDismissAndForwardAction); }else{ completion(UNNotificationContentExtensionResponseOptionDismiss); } }else if ([category isEqualToString:Action_Category_Identifier_Audio]){ if ([actionIdentifier isEqualToString:Action_Identifier_Audio_Confirm]) { completion(UNNotificationContentExtensionResponseOptionDismissAndForwardAction); }else{ completion(UNNotificationContentExtensionResponseOptionDismiss); } }else{ if ([actionIdentifier isEqualToString:Action_Identifier_Movie_Confirm]) { completion(UNNotificationContentExtensionResponseOptionDismissAndForwardAction); }else{ completion(UNNotificationContentExtensionResponseOptionDismiss); } }}","link":"/2017/07/18/ios-notificationcontentextension/"},{"title":"iOS--富文本推送NotificationServiceExtension","text":"添加http协议支持，没错，这里是支持http协议的，不像其他文章说的不支持配置在另外基础篇文章里面有，info.plist文件里修改一下就行了 NotificationService文件额外添加了一个文件管理器的字段，用来存储数据 123456789101112@interface NotificationService ()@property (nonatomic, strong) void (^contentHandler)(UNNotificationContent *contentToDeliver);@property (nonatomic, strong) UNMutableNotificationContent *bestAttemptContent;@property (nonatomic, strong) NSFileManager *fileMgr;@property (nonatomic, strong) NSURLSessionDownloadTask *download;@property (nonatomic, strong) NSURLSession *session;@property (nonatomic, strong) NSDictionary *userInfo;@property (nonatomic, strong) NSURL *attchUrl;@property (nonatomic, strong) NSString *imageExtension;@end 1@implementation NotificationService LazyLoad 123-(NSFileManager *)fileMgr{ return [NSFileManager defaultManager];} 网络session 123456-(NSURLSession *)session{ if (_session == nil) { _session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]]; } return _session;} 下载任务 123456789101112131415161718192021222324-(NSURLSessionDownloadTask *)download{ if (!_download) { _download = [self.session downloadTaskWithURL:self.attchUrl completionHandler:^(NSURL * _Nullable tempLocation, NSURLResponse * _Nullable response, NSError * _Nullable error) { if (!error) { NSURL *localURL = [NSURL fileURLWithPath:[tempLocation.path stringByAppendingString:self.imageExtension]]; [self.fileMgr moveItemAtURL:tempLocation toURL:localURL error:&amp;error]; NSError *attachmentError = nil; UNNotificationAttachment * attachment = [UNNotificationAttachment attachmentWithIdentifier:@&quot;photo&quot; URL:localURL options:nil error:&amp;attachmentError]; if (attachmentError) { NSLog(@&quot;attachmentError %@&quot;,attachmentError); }else if (attachment){ self.bestAttemptContent.attachments = @[attachment]; }else{ } }else{ NSLog(@&quot;downloadTaskerror %@&quot;,error.localizedDescription); } self.bestAttemptContent.categoryIdentifier = self.userInfo[@&quot;aps&quot;][@&quot;category&quot;]; self.contentHandler(self.bestAttemptContent); }]; } return _download;} 收到远程通知之后，在当前方法内进行处理，并生成attchment，最终回调给系统 12345678910111213- (void)didReceiveNotificationRequest:(UNNotificationRequest *)request withContentHandler:(void (^)(UNNotificationContent * _Nonnull))contentHandler { self.contentHandler = contentHandler; self.bestAttemptContent = [request.content mutableCopy]; self.resumeTime = 0; self.userInfo = [request.content.userInfo copy]; NSString * attchUrl = self.userInfo[@&quot;image&quot;]; self.imageExtension = [NSString stringWithFormat:@&quot;.%@&quot;,[[attchUrl componentsSeparatedByString:@&quot;.&quot;] lastObject]]; if (attchUrl) { self.attchUrl = [NSURL URLWithString:attchUrl]; [self resumeSession]; }} 开始执行下载多媒体资源任务 1234- (void)resumeSession{ [self.download resume];} 超时，异常时调用 123456789- (void)serviceExtensionTimeWillExpire { // Called just before the extension will be terminated by the system. // Use this as an opportunity to deliver your &quot;best attempt&quot; at modified content, otherwise the original push payload will be used. self.contentHandler(self.bestAttemptContent);}@end","link":"/2017/07/18/ios-notificationserviceextension/"},{"title":"iOS--富文本推送UIMutableUserNotificationAction","text":"iOS10富文本推送–UIMutableUserNotificationAction AppDelagate文件添加action根据以下ContentExtension Info.plist文件中的配置决定category的设置，两者必须一致 宏定义采用下列代码： 12345678910111213141516//推送相关设置#define Action_Category_Identifier_Image @&quot;Image_Category&quot; //图片类别标识符#define Action_Category_Identifier_Audio @&quot;Audio_Category&quot; //音频类别标识符#define Action_Category_Identifier_Movie @&quot;Movie_Category&quot; //视频类别标识符#define Action_Identifier_Image_Confirm @&quot;imageConfirmAction&quot; //图片确认按钮#define Action_Identifier_Image_Concel @&quot;imageConcelAction&quot; //图片取消按钮#define Action_Identifier_Audio_Confirm @&quot;audioConfirmAction&quot; //音频确认按钮#define Action_Identifier_Audio_Concel @&quot;audioConcelAction&quot; //音频取消按钮#define Action_Identifier_Movie_Confirm @&quot;movieConfirmAction&quot; //视频确认按钮#define Action_Identifier_Movie_Concel @&quot;movieConcelAction&quot; //视频取消按钮#define Action_Title_Image_Confirm @&quot;查看&quot; //图片确认按钮标题#define Action_Title_Image_Concel @&quot;忽略&quot; //图片取消按钮标题#define Action_Title_Audio_Confirm @&quot;查看&quot; //音频确认按钮标题#define Action_Title_Audio_Concel @&quot;忽略&quot; //音频取消按钮标题#define Action_Title_Movie_Confirm @&quot;查看&quot; //视频确认按钮标题#define Action_Title_Movie_Concel @&quot;忽略&quot; //视频取消按钮标题 添加相应类别的aciton，一个类别必须对应一个category，在下面这个方法里面执行, 1- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//添加相应类别的aciton，一个类别必须对应一个category- (void)addNotificationAction{ //Image_Category UIMutableUserNotificationAction *imageConfirmAction = [self creatNotificationActionIdentifier:Action_Identifier_Image_Confirm title:Action_Title_Image_Confirm activationMode:UIUserNotificationActivationModeForeground]; imageConfirmAction.authenticationRequired = YES; imageConfirmAction.destructive = YES; UIMutableUserNotificationAction *imageConcelAction = [self creatNotificationActionIdentifier:Action_Identifier_Image_Concel title:Action_Title_Image_Concel activationMode:UIUserNotificationActivationModeBackground]; UIMutableUserNotificationCategory *ImageCategory = [self creatNotificationCategoryIdentifier:Action_Category_Identifier_Image setActions:@[imageConfirmAction,imageConcelAction] forContext:UIUserNotificationActionContextDefault]; //Audio_Category UIMutableUserNotificationAction *audioConfirmAction = [self creatNotificationActionIdentifier:Action_Identifier_Audio_Confirm title:Action_Title_Audio_Confirm activationMode:UIUserNotificationActivationModeForeground]; audioConfirmAction.authenticationRequired = YES; audioConfirmAction.destructive = YES; UIMutableUserNotificationAction *audioConcelAction = [self creatNotificationActionIdentifier:Action_Identifier_Audio_Concel title:Action_Title_Audio_Concel activationMode:UIUserNotificationActivationModeBackground]; UIMutableUserNotificationCategory *audioCategory = [self creatNotificationCategoryIdentifier:Action_Category_Identifier_Audio setActions:@[audioConfirmAction,audioConcelAction] forContext:UIUserNotificationActionContextDefault]; //Movie_Category UIMutableUserNotificationAction *movieConfirmAction = [self creatNotificationActionIdentifier:Action_Identifier_Movie_Confirm title:Action_Title_Movie_Confirm activationMode:UIUserNotificationActivationModeForeground]; movieConfirmAction.authenticationRequired = YES; movieConfirmAction.destructive = YES; UIMutableUserNotificationAction *movieConcelAction = [self creatNotificationActionIdentifier:Action_Identifier_Movie_Concel title:Action_Title_Movie_Concel activationMode:UIUserNotificationActivationModeBackground]; UIMutableUserNotificationCategory *movieCategory = [self creatNotificationCategoryIdentifier:Action_Category_Identifier_Movie setActions:@[movieConfirmAction,movieConcelAction] forContext:UIUserNotificationActionContextDefault]; NSSet *categories = [NSSet setWithObjects:ImageCategory,audioCategory,movieCategory,nil]; UIUserNotificationType types = (UIUserNotificationTypeAlert| UIUserNotificationTypeSound| UIUserNotificationTypeBadge); UIUserNotificationSettings *settings; settings = [UIUserNotificationSettings settingsForTypes:types categories:categories]; [[UIApplication sharedApplication] registerUserNotificationSettings:settings]; } 创建一个category 12345678910//创建一个category- (UIMutableUserNotificationCategory*)creatNotificationCategoryIdentifier:(NSString *)identifier setActions:(nullable NSArray&lt;UIUserNotificationAction *&gt; *)actions forContext:(UIUserNotificationActionContext)context{ UIMutableUserNotificationCategory *category = [[UIMutableUserNotificationCategory alloc] init]; category.identifier = identifier;//这组动作的唯一标示 [category setActions:actions forContext:context]; return category;} 创建一个action 123456789101112//创建一个action-(UIMutableUserNotificationAction *)creatNotificationActionIdentifier:(NSString *)identifier title:(NSString *)title activationMode:(UIUserNotificationActivationMode)activationMode{ UIMutableUserNotificationAction *action = [[UIMutableUserNotificationAction alloc] init]; //第二按钮 action.identifier = identifier; action.title = title; action.activationMode = activationMode; return action;}","link":"/2017/07/18/ios-uimutableusernotificationaction/"},{"title":"iOS 如何加载本地html文件","text":"iOS 如何加载本地html文件???? 其实很简单 如下图所示 1234-(void)loadLocalHtml{ NSURL *url = [[NSBundle mainBundle] URLForResource:@&quot;/sfa/html/index.html&quot; withExtension:nil]; [self.webView loadRequest:[NSURLRequest requestWithURL:url]];} 其中 1@&quot;/sfa/html/index.html&quot; 部分是你的html文件相对于整个工程的路径例如下面这个工程构成图： 相关文件最好以文件方式导入而不是group CSDN: iOS 如何加载本地html文件 简书: iOS 如何加载本地html文件","link":"/2017/12/18/ios-ru-he-jia-zai-ben-di-html-wen-jian/"},{"title":"iOS--如何计算出今天是周几","text":"iOS–如何计算出今天是周几？？ 很简单： 123456789NSCalendar *cal = [[NSCalendar alloc] initWithCalendarIdentifier:NSCalendarIdentifierRepublicOfChina];NSInteger comp = [cal component:NSCalendarUnitWeekday fromDate:[NSDate date]];NSLog(@&quot;%ld&quot;,comp);NSDateComponents *comps = [cal components:NSCalendarUnitWeekday fromDate:[NSDate date]];NSLog(@&quot;%@&quot;,comps);","link":"/2017/08/23/ios-ru-he-ji-suan-chu-jin-tian-shi-zhou-ji/"},{"title":"iOS时间工具类","text":"iOS时间工具类工作之余写的一个关于Unix时间的工具 1234567891011121314151617181920@interface UnixTime : NSObject@property (nonatomic,assign) double unixTimeInterval;//GMT时间戳 微秒级@property (nonatomic,strong) NSDate *unixDate;//GMT时间 2016-01-04 8:55:46 +0000@property (nonatomic,strong) NSString *LocalTimeZone;//本地时区 GMT-12 GMT+12@property (nonatomic,assign) NSInteger timeOffset;//时间偏移量 @property (nonatomic,assign) double unixTimestamp;//GMT+0 毫秒@property (nonatomic,assign) NSInteger unixZeroTimestamp;//当天零点 GMT+0 秒+ (UnixTime *)shareUnixTime;//单例 类方法- (void)getUnixTimestampAtNow;//Unix时间戳 若要获取某天的零时刻 必须先执行找个方法- (void)getSystemTimeZone;//本地时区- (NSString *)getTimeStringWithTime:(double)time;//字符串输出时间 设置日期格式带毫秒的 2016-01-04 16:55:46- (NSInteger)getUnixTimeWithDay:(NSInteger)day;// 某天的零时Unix时间戳- (NSInteger)getUnixTimeWithDay:(NSInteger)day AndClock:(NSInteger)clock; // 某天的特定时刻Unix时间戳- (NSInteger)gettimestampWithDateFormatString:(NSString *)dateFormatString;- (NSString *)formatTimeWithTime:(NSNumber *)time;//根据传入时间数值 返回hh:mm:ss格式的时间 这个是表示时间点的- (NSString *)formatHMWithTime:(NSNumber *)time;//根据传入时间数值 返回hh:mm格式的时间 这个时用来表示时间长短的- (NSString *)getTravelTimeWithStartTime:(NSNumber *)startTime andEndTime:(NSNumber *)endTime;//根据传入时间数值返回时间差值分钟 这个时用来表示时间长短的- (NSString *)getDayHourMinWithTimeStamp:(NSNumber *)time;@end UnixTime.m文件包含方法的具体实现，用法都在.h文件里写了 1234567891011121314#import &quot;UnixTime.h&quot;@implementation UnixTime+ (UnixTime *)shareUnixTime{ static UnixTime *unixTime = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ unixTime = [[UnixTime alloc]init]; }); return unixTime;} 123456789101112131415161718- (void)getUnixTimestampAtNow{ self.unixDate = [NSDate date]; NSLog(@&quot;GMT %@&quot;,self.unixDate); NSTimeInterval time=[self.unixDate timeIntervalSince1970]; self.unixTimeInterval =time; NSString *timeIntervalString = [NSString stringWithFormat:@&quot;%f&quot;,self.unixTimeInterval]; NSLog(@&quot;GMTTimeInterval %@&quot;,timeIntervalString); NSString *micSecondString = [timeIntervalString substringWithRange:NSMakeRange(timeIntervalString.length-6, 3)]; //NSLog(@&quot;micSec %@&quot;,micSecondString); NSInteger micSec = [micSecondString integerValue]; self.unixTimestamp = (NSInteger)time+micSec/1000.000; NSLog(@&quot;GMTTimestamp %ld&quot;,(long)self.unixTimestamp); [self getUnixZeroTimestamp]; [self getSystemTimeZone]; [self getTimeOffset];} 12345678910111213- (void)getSystemTimeZone{ NSTimeZone *timezone = [NSTimeZone systemTimeZone]; //NSLog(@&quot;timeZone%@&quot;,timezone); NSString *timeAbbreviation = timezone.abbreviation; self.LocalTimeZone = timeAbbreviation; if ([timeAbbreviation isEqualToString:@&quot;GMT&quot;]) { self.LocalTimeZone = @&quot;GMT+0&quot;; } // NSLog(@&quot;TimeZone.abb: %@&quot;,self.LocalTimeZone);} 12345678910111213- (void)getTimeOffset{ NSString *str1 = [self.LocalTimeZone substringWithRange:NSMakeRange(3, 1)]; NSString *str2 = [self.LocalTimeZone substringWithRange:NSMakeRange(4, self.LocalTimeZone.length-4)]; NSInteger timeZoneOffset = [str2 integerValue]; if ([str1 isEqualToString:@&quot;+&quot;]) { self.timeOffset = timeZoneOffset*3600; }else if ([str1 isEqualToString:@&quot;-&quot;]){ self.timeOffset = -timeZoneOffset*3600; } //NSLog(@&quot;timeOffSet %ld&quot;,(long)self.timeOffset);} 123456789- (void)getUnixZeroTimestamp{ self.unixZeroTimestamp = (NSInteger)(self.unixTimestamp/86400)*86400; NSInteger days = self.unixZeroTimestamp/86400 ; NSLog(@&quot;GMTZeroTimestamp %ld&quot;,self.unixZeroTimestamp); NSLog(@&quot;days %ld&quot;,days);} 123456789101112- (NSString *)getTimeStringWithTime:(double)time{ NSDate *date = [NSDate dateWithTimeIntervalSince1970:time]; NSDateFormatter *dateFormat = [[NSDateFormatter alloc] init]; [dateFormat setDateFormat:@&quot;YYYY-MM-dd HH:mm:ss&quot;]; // 设置日期格式带秒的 2016-01-04 16:55:46 //NSLog(@&quot;date %@&quot;,date); NSString *timeString = [dateFormat stringFromDate:date]; //NSLog(@&quot;time %@&quot;,timeString); return timeString;} 12345678910- (NSInteger)gettimestampWithDateFormatString:(NSString *)dateFormatString{ NSDateFormatter *dateFormat = [[NSDateFormatter alloc] init]; [dateFormat setDateFormat:@&quot;YYYY-MM-dd HH:mm:ss&quot;]; NSDate *date = [dateFormat dateFromString:dateFormatString]; NSInteger time= [date timeIntervalSince1970]; NSLog(@&quot;time %ld&quot;,time); return time;} 12345678- (NSInteger)getUnixTimeWithDay:(NSInteger)day{ NSInteger unixTime = self.unixZeroTimestamp-(day-1)*86400-self.timeOffset; NSLog(@&quot;unixTime %ld&quot;,unixTime); NSLog(@&quot;%@&quot;,[self getTimeStringWithTime:unixTime]); return unixTime;} 12345678910111213141516171819- (NSInteger)getUnixTimeWithDay:(NSInteger)day AndClock:(NSInteger)clock{//特定时刻的Unix时间戳 if (clock&lt;0||clock&gt;24) {//为了避免传入数据不正确 进行换算 增强可靠性 clock = clock%24; if (clock&lt;0) { clock=clock+24; }else{ clock=clock; } }else{ clock=clock; } NSInteger unixTime = self.unixZeroTimestamp-(day-1)*86400+3600*clock;//-self.timeOffset; //NSLog(@&quot;unixTime %ld&quot;,unixTime); return unixTime;} 123456789101112131415161718192021- (NSString *)formatTimeWithTime:(NSNumber *)time{ float _time_2 = [time floatValue]; NSInteger _time_1 = [time integerValue]; NSInteger sec = (NSInteger)((_time_2-_time_1)*60); NSInteger hour; NSInteger min; if (_time_1&gt;=1 &amp;&amp; _time_1&lt;60) { min = _time_1%60; return [NSString stringWithFormat:@&quot;%ld:%.2ld&quot;,min,sec]; } if (_time_1&gt;=60) { hour = _time_1/60; min = _time_1%60; return [NSString stringWithFormat:@&quot;%ld:%.2ld:%.2ld&quot;,hour,min,sec]; } return [NSString stringWithFormat:@&quot;0:%.2ld&quot;,sec];} 1234567891011121314- (NSString *)formatHMWithTime:(NSNumber *)time{ UnixTime *unixtime = [UnixTime shareUnixTime]; NSString *string = [unixtime getTimeStringWithTime:[time integerValue]]; NSArray *firArray = [string componentsSeparatedByString:@&quot; &quot;]; NSString *firstring = firArray[1]; NSMutableArray *secArray = [NSMutableArray arrayWithArray:[firstring componentsSeparatedByString:@&quot;:&quot;]]; [secArray removeLastObject]; return [secArray componentsJoinedByString:@&quot;:&quot;]; } 1234567891011- (NSString *)getTravelTimeWithStartTime:(NSNumber *)startTime andEndTime:(NSNumber *)endTime{ NSInteger _startTime = [startTime integerValue]; NSInteger _endTime = [endTime integerValue]; NSInteger travelTime = (_endTime - _startTime)/60+1; return [NSString stringWithFormat:@&quot;%ld&quot;,travelTime];} 12345678910111213141516- (NSString *)getDayHourMinWithTimeStamp:(NSNumber *)time{ NSInteger _time = [time integerValue]; NSDate *date = [NSDate dateWithTimeIntervalSince1970:_time]; NSDateFormatter *dateFormat = [[NSDateFormatter alloc] init]; [dateFormat setDateFormat:@&quot;YYYY-MM-dd HH:mm&quot;]; // 设置日期格式 2016-01-04 16:55:46 //NSLog(@&quot;date %@&quot;,date); NSString *timeString = [dateFormat stringFromDate:date]; //NSLog(@&quot;time %@&quot;,timeString); return timeString;}@end","link":"/2017/07/14/ios-shi-jian-gong-ju-lei/"},{"title":"iOS自定义相机的实现","text":"iOS自定义相机的实现本文主要介绍iOS系统上的自定义相机的实现，其实并不难主要包含了，拍摄设备，输入端，输出端，以及抓取图像，保存图像的操作。 ###简单介绍组要控件 上方功能区 取消按钮 闪光灯按钮 相机切换按钮 下方功能区 拍照按钮 重新拍照按钮 选择照片按钮 图像展示视图 主要代码展示头文件内容展示 定了一个block，用于传输照片信息 1234567#import &lt;UIKit/UIKit.h&gt;typedef void(^ImageBlock)(NSDictionary *imageDictionary);@interface CameraViewController : UIViewController@property (nonatomic, copy) ImageBlock imageblock;-(void)setImageblock:(void(^)(NSDictionary *imageDictionary))imageblock;@end 视图控件代码，逻辑代码展示 当前视图需要的主要空控件，为了方便操作全部定义为属性 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@interface CameraViewController ()&lt;AVCaptureMetadataOutputObjectsDelegate,UIAlertViewDelegate,CAAnimationDelegate&gt;//捕获设备，通常是前置摄像头，后置摄像头，麦克风（音频输入）@property(nonatomic)AVCaptureDevice *device;//AVCaptureDeviceInput 代表输入设备，他使用AVCaptureDevice 来初始化@property(nonatomic)AVCaptureDeviceInput *input;//当启动摄像头开始捕获输入@property(nonatomic)AVCaptureMetadataOutput *output;//输出@property (nonatomic)AVCaptureStillImageOutput *ImageOutPut;//session：由他把输入输出结合在一起，并开始启动捕获设备（摄像头）@property(nonatomic)AVCaptureSession *session;//图像预览层，实时显示捕获的图像@property(nonatomic)AVCaptureVideoPreviewLayer *previewLayer;//设备@property (nonatomic, strong)AVCaptureDevice *deveice;//拍照@property (nonatomic, strong) UIButton *PhotoButton;//闪光灯@property (nonatomic, strong) UIButton *flashButton;//取消@property (nonatomic, strong) UIButton *cancleButton;//切换摄像头@property (nonatomic, strong) UIButton *changeButton;//确定选择当前照片@property (nonatomic, strong) UIButton *selectButton;//重新拍照@property (nonatomic, strong) UIButton *reCamButton;//照片加载视图@property (nonatomic, strong) UIImageView *imageView;//对焦区域@property (nonatomic, strong) UIImageView *focusView;//上方功能区@property (nonatomic, strong) UIView *topView;//下方功能区@property (nonatomic, strong) UIView *bottomView;//闪光灯状态@property (nonatomic, assign) BOOL isflashOn;//拍到的照片@property (nonatomic, strong) UIImage *image;//照片的信息@property (nonatomic, strong) NSDictionary *imageDict;//是否可以拍照@property (nonatomic, assign) BOOL canCa;//闪光灯模式@property (nonatomic, assign) AVCaptureFlashMode flahMode;//前后摄像头@property (nonatomic, assign) AVCaptureDevicePosition cameraPosition;//模糊视图@property (nonatomic, strong) UIVisualEffectView *effectView;@end 使用懒加载，减少主要函数中的代码，看起来更为清爽。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164@implementation CameraViewController#pragma mark - 更改摄像头-(UIVisualEffectView *)effectView{ if (_effectView == nil) { UIBlurEffect *effect = [UIBlurEffect effectWithStyle:UIBlurEffectStyleLight]; _effectView = [[UIVisualEffectView alloc] initWithEffect:effect]; _effectView.frame = CGRectMake(0, 0, ScreenWidth(), ScreenHieght()); _effectView.alpha = 1; } return _effectView;} #pragma mark - 更改闪光灯状态-(void)setIsflashOn:(BOOL)isflashOn{ _isflashOn = isflashOn; [[NSUserDefaults standardUserDefaults] setObject:@(_isflashOn) forKey:@&quot;flashMode&quot;]; if (_isflashOn) { [self.flashButton setBackgroundImage:[UIImage imageNamed:@&quot;flash_on&quot;] forState:UIControlStateNormal]; }else{ [self.flashButton setBackgroundImage:[UIImage imageNamed:@&quot;flash_off&quot;] forState:UIControlStateNormal]; }}#pragma mark - 上方功能区-(UIView *)topView{ if (!_topView ) { _topView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, ScreenWidth(), 50)]; _topView.backgroundColor = [UIColor colorWithRed:1 green:1 blue:1 alpha:0.2]; [_topView addSubview:self.cancleButton]; [_topView addSubview:self.flashButton]; [_topView addSubview:self.changeButton]; } return _topView;}#pragma mark - 取消-(UIButton *)cancleButton{ if (_cancleButton == nil) { _cancleButton = [UIButton buttonWithType:UIButtonTypeCustom]; _cancleButton.frame = CGRectMake(20, 10, 60, 30); [_cancleButton setTitle:@&quot;取消&quot; forState:UIControlStateNormal]; [_cancleButton addTarget:self action:@selector(cancle) forControlEvents:UIControlEventTouchUpInside]; } return _cancleButton ;}#pragma mark - 闪光灯-(UIButton *)flashButton{ if (_flashButton == nil) { _flashButton = [UIButton buttonWithType:UIButtonTypeCustom]; _flashButton.frame = CGRectMake((ScreenWidth()-30)/2.0, 10, 30, 30); [_flashButton addTarget:self action:@selector(FlashOn) forControlEvents:UIControlEventTouchUpInside]; } return _flashButton;}#pragma mark - 切换摄像头-(UIButton *)changeButton{ if (_changeButton == nil) { _changeButton = [UIButton buttonWithType:UIButtonTypeCustom]; _changeButton.frame = CGRectMake(ScreenWidth()-40, 10, 30, 30); [_changeButton setBackgroundImage:[UIImage imageNamed:@&quot;cam&quot;] forState:UIControlStateNormal]; [_changeButton addTarget:self action:@selector(changeCamera) forControlEvents:UIControlEventTouchUpInside]; } return _changeButton;}#pragma mark - 下方功能区-(UIView *)bottomView{ if (!_bottomView) { _bottomView = [[UIView alloc] initWithFrame:CGRectMake(0, ScreenHieght()-80, ScreenWidth(), 80)]; _bottomView.backgroundColor = [UIColor colorWithRed:1 green:1 blue:1 alpha:0.4]; [_bottomView addSubview:self.reCamButton]; [_bottomView addSubview:self.PhotoButton]; [_bottomView addSubview:self.selectButton]; } return _bottomView;}-(UIButton *)reCamButton{ if (_reCamButton == nil) { _reCamButton = [UIButton buttonWithType:UIButtonTypeCustom]; _reCamButton.frame = CGRectMake(40, 25, 80, 30); [_reCamButton addTarget:self action:@selector(reCam) forControlEvents:UIControlEventTouchUpInside]; [_reCamButton setTitle:@&quot;重新拍照&quot; forState:UIControlStateNormal]; [_reCamButton setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal]; _reCamButton.alpha = 0; } return _reCamButton;}-(UIButton *)PhotoButton{ if (_PhotoButton == nil) { _PhotoButton = [UIButton buttonWithType:UIButtonTypeCustom]; _PhotoButton.frame = CGRectMake(ScreenWidth()/2.0-30, 10, 60, 60); [_PhotoButton setImage:[UIImage imageNamed:@&quot;photograph&quot;] forState: UIControlStateNormal]; [_PhotoButton setImage:[UIImage imageNamed:@&quot;photograph_Select&quot;] forState:UIControlStateNormal]; [_PhotoButton addTarget:self action:@selector(shutterCamera) forControlEvents:UIControlEventTouchUpInside]; } return _PhotoButton;}-(UIButton *)selectButton{ if (_selectButton == nil) { _selectButton = [UIButton buttonWithType:UIButtonTypeCustom]; _selectButton.frame = CGRectMake(ScreenWidth()-120, 25, 80, 30); [_selectButton addTarget:self action:@selector(selectImage) forControlEvents:UIControlEventTouchUpInside]; [_selectButton setTitle:@&quot;选择照片&quot; forState:UIControlStateNormal]; [_selectButton setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal]; _selectButton.alpha = 0; } return _selectButton;}#pragma mark - 加载照片的视图-(UIImageView *)imageView{ if (_imageView == nil) { _imageView = [[UIImageView alloc]initWithFrame:self.previewLayer.frame]; _imageView.layer.masksToBounds = YES; _imageView.image = _image; } return _imageView;}#pragma mark - 对焦区域-(UIImageView *)focusView{ if (_focusView == nil) { _focusView = [[UIImageView alloc]initWithFrame:CGRectMake(0, 0, 80, 80)]; _focusView.backgroundColor = [UIColor clearColor]; _focusView.image = [UIImage imageNamed:@&quot;foucs80pt&quot;]; } return _focusView;}#pragma mark - 使用self.session，初始化预览层，self.session负责驱动input进行信息的采集，layer负责把图像渲染显示-(AVCaptureVideoPreviewLayer *)previewLayer{ if (_previewLayer == nil) { _previewLayer = [[AVCaptureVideoPreviewLayer alloc]initWithSession:self.session]; _previewLayer.frame = CGRectMake(0, 0, ScreenWidth(), ScreenHieght()); _previewLayer.videoGravity = AVLayerVideoGravityResizeAspectFill; } return _previewLayer;}-(AVCaptureStillImageOutput *)ImageOutPut{ if (_ImageOutPut == nil) { _ImageOutPut = [[AVCaptureStillImageOutput alloc] init]; } return _ImageOutPut;}#pragma mark - 初始化输入-(AVCaptureDeviceInput *)input{ if (_input == nil) { _input = [[AVCaptureDeviceInput alloc]initWithDevice:self.device error:nil]; } return _input;}#pragma mark - 初始化输出-(AVCaptureMetadataOutput *)output{ if (_output == nil) { _output = [[AVCaptureMetadataOutput alloc]init]; } return _output;}#pragma mark - 使用AVMediaTypeVideo 指明self.device代表视频，默认使用后置摄像头进行初始化-(AVCaptureDevice *)device{ if (_device == nil) { _device = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo]; } return _device;} 主要逻辑代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#pragma mark - 当前视图控制器的初始化- (instancetype)init{ self = [super init]; if (self) { _canCa = [self canUserCamear]; } return self;}-(void)setImageblock:(void (^)(NSDictionary *))imageblock{ _imageblock = imageblock;}#pragma mark - 检查相机权限- (BOOL)canUserCamear{ AVAuthorizationStatus authStatus = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeVideo]; if (authStatus == AVAuthorizationStatusDenied) { UIAlertView *alertView = [[UIAlertView alloc]initWithTitle:@&quot;请打开相机权限&quot; message:@&quot;设置-隐私-相机&quot; delegate:self cancelButtonTitle:@&quot;确定&quot; otherButtonTitles:@&quot;取消&quot;, nil]; alertView.tag = 100; [alertView show]; return NO; } else{ return YES; } return YES;}#pragma mark - 视图加载- (void)viewDidLoad { [super viewDidLoad]; self.view.backgroundColor = [UIColor clearColor]; if (_canCa) { [self customCamera]; [self customUI]; [self FlashOn]; }else{ return; } // Do any additional setup after loading the view, typically from a nib.}#pragma mark - 自定义视图- (void)customUI{ [self.view addSubview:self.topView]; [self.view addSubview:self.bottomView]; [self.view addSubview:self.focusView]; UITapGestureRecognizer *tapGesture = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(focusGesture:)]; [self.view addGestureRecognizer:tapGesture]; }#pragma mark - 自定义相机- (void)customCamera{ //生成会话，用来结合输入输出 self.session = [[AVCaptureSession alloc]init]; if ([self.session canSetSessionPreset:AVCaptureSessionPresetPhoto]) { self.session.sessionPreset = AVCaptureSessionPresetPhoto; } if ([self.session canAddInput:self.input]) { [self.session addInput:self.input]; } if ([self.session canAddOutput:self.ImageOutPut]) { [self.session addOutput:self.ImageOutPut]; } [self.view.layer addSublayer:self.previewLayer]; //开始启动 [self.session startRunning]; if ([self.device lockForConfiguration:nil]) { if ([self.device isFlashModeSupported:AVCaptureFlashModeAuto]) { [self.device setFlashMode:AVCaptureFlashModeAuto]; } //自动白平衡 if ([self.device isWhiteBalanceModeSupported:AVCaptureWhiteBalanceModeAutoWhiteBalance]) { [self.device setWhiteBalanceMode:AVCaptureWhiteBalanceModeAutoWhiteBalance]; } [self.device unlockForConfiguration]; } [self focusAtPoint:self.view.center];} *闪光灯 1234567891011121314151617181920#pragma 闪光灯- (void)FlashOn{ if ([self.device lockForConfiguration:nil]) { if (self.isflashOn) { if ([self.device isFlashModeSupported:AVCaptureFlashModeOff]) { [self.device setFlashMode:AVCaptureFlashModeOff]; self.isflashOn = NO; //[self.flashButton setTitle:@&quot;关&quot; forState:UIControlStateNormal]; } }else{ if ([self.device isFlashModeSupported:AVCaptureFlashModeAuto]) { [self.device setFlashMode:AVCaptureFlashModeAuto]; self.isflashOn = YES; //[self.flashButton setTitle:@&quot;开&quot; forState:UIControlStateNormal]; } } [self.device unlockForConfiguration]; }} 双摄像头切换，切换时使用高斯模糊对试图进行处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#pragma mark - 相机切换- (void)changeCamera{ NSUInteger cameraCount = [[AVCaptureDevice devicesWithMediaType:AVMediaTypeVideo] count]; if (cameraCount &gt; 1) { self.changeButton.userInteractionEnabled = NO; [self cutoff]; NSError *error; CATransition *animation = [CATransition animation]; animation.duration = 1; animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]; animation.type = @&quot;oglFlip&quot;; animation.delegate = self; AVCaptureDevice *newCamera = nil; AVCaptureDeviceInput *newInput = nil; AVCaptureDevicePosition position = [[self.input device] position]; if (position == AVCaptureDevicePositionFront){ newCamera = [self cameraWithPosition:AVCaptureDevicePositionBack]; animation.subtype = kCATransitionFromLeft; self.cameraPosition = AVCaptureDevicePositionBack; }else { newCamera = [self cameraWithPosition:AVCaptureDevicePositionFront]; animation.subtype = kCATransitionFromRight; self.cameraPosition = AVCaptureDevicePositionFront; } newInput = [AVCaptureDeviceInput deviceInputWithDevice:newCamera error:nil]; [self.previewLayer addAnimation:animation forKey:nil]; /* 高斯模糊 */ [self.imageView addSubview:self.effectView]; [self.view insertSubview:self.imageView belowSubview:self.topView]; // if (newInput != nil) { [self.session beginConfiguration]; [self.session removeInput:self.input]; if ([self.session canAddInput:newInput]) { [self.session addInput:newInput]; self.input = newInput; } else { [self.session addInput:self.input]; } [self.session commitConfiguration]; } else if (error) { NSLog(@&quot;toggle carema failed, error = %@&quot;, error); } //[self.session startRunning]; }}- (AVCaptureDevice *)cameraWithPosition:(AVCaptureDevicePosition)position{ NSArray *devices = [AVCaptureDevice devicesWithMediaType:AVMediaTypeVideo]; for ( AVCaptureDevice *device in devices ) if ( device.position == position ) return device; return nil;}-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag{ self.changeButton.userInteractionEnabled = YES; [self.effectView removeFromSuperview]; [self.imageView removeFromSuperview]; if (self.cameraPosition == AVCaptureDevicePositionFront) { self.flashButton.alpha = 0; }else if (self.cameraPosition == AVCaptureDevicePositionBack){ self.flashButton.alpha = 1; } [self.session startRunning];} 摄像头对焦 1234567891011121314151617181920212223242526272829303132333435363738#pragma mark - 聚焦- (void)focusGesture:(UITapGestureRecognizer*)gesture{ CGPoint point = [gesture locationInView:gesture.view]; [self focusAtPoint:point];}- (void)focusAtPoint:(CGPoint)point{ CGSize size = self.view.bounds.size; CGPoint focusPoint = CGPointMake( point.y /size.height ,1-point.x/size.width ); NSError *error; if ([self.device lockForConfiguration:&amp;error]) { if ([self.device isFocusModeSupported:AVCaptureFocusModeAutoFocus]) { [self.device setFocusPointOfInterest:focusPoint]; [self.device setFocusMode:AVCaptureFocusModeAutoFocus]; } if ([self.device isExposureModeSupported:AVCaptureExposureModeAutoExpose ]) { [self.device setExposurePointOfInterest:focusPoint]; [self.device setExposureMode:AVCaptureExposureModeAutoExpose]; } [self.device unlockForConfiguration]; self.focusView.center = point; //[self startFocusAnimation]; self.focusView.alpha = 1; [UIView animateWithDuration:0.2 animations:^{ self.focusView.transform = CGAffineTransformMakeScale(1.25f, 1.25f); } completion:^(BOOL finished) { [UIView animateWithDuration:0.3 animations:^{ self.focusView.transform = CGAffineTransformMakeScale(1.0f, 1.0f); } completion:^(BOOL finished) { [self hiddenFocusAnimation]; }]; }]; } } 主要功能按钮 拍照按钮123456789101112131415161718192021222324252627#pragma mark - 拍照- (void)shutterCamera{ AVCaptureConnection * videoConnection = [self.ImageOutPut connectionWithMediaType:AVMediaTypeVideo]; if (!videoConnection) { NSLog(@&quot;take photo failed!&quot;); return; } [self.ImageOutPut captureStillImageAsynchronouslyFromConnection:videoConnection completionHandler:^(CMSampleBufferRef imageDataSampleBuffer, NSError *error) { if (imageDataSampleBuffer == NULL) { return; } NSData * imageData = [AVCaptureStillImageOutput jpegStillImageNSDataRepresentation:imageDataSampleBuffer]; self.image = [UIImage imageWithData:imageData]; self.imageDict = @{@&quot;image&quot;:self.image,@&quot;info&quot;:@{@&quot;PHImageFileUTIKey&quot;:@&quot;.jpeg&quot;}}; [self.session stopRunning]; //[self.view insertSubview:self.imageView belowSubview:self.PhotoButton]; [self.view insertSubview:self.imageView aboveSubview:self.topView]; NSLog(@&quot;image size = %@&quot;,NSStringFromCGSize(self.image.size)); self.topView.alpha = 0; self.PhotoButton.alpha = 0; self.reCamButton.alpha = 1; self.selectButton.alpha = 1; }];} 保存至相册 12345678910111213141516171819#pragma - 保存至相册- (void)saveImageToPhotoAlbum:(UIImage*)savedImage{ UIImageWriteToSavedPhotosAlbum(savedImage, self, @selector(image:didFinishSavingWithError:contextInfo:), NULL); }// 指定回调方法- (void)image: (UIImage *) image didFinishSavingWithError: (NSError *) error contextInfo: (void *) contextInfo{ if(error != NULL){ UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;保存图片结果提示&quot; message:@&quot;保存图片失败&quot; delegate:self cancelButtonTitle:@&quot;确定&quot; otherButtonTitles:nil]; [alert show]; }} 取消 返回上级 12345678910111213141516171819#pragma mark - 取消 返回上级-(void)cancle{ [self.imageView removeFromSuperview]; [self.session stopRunning]; [self.navigationController popViewControllerAnimated:YES];}- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex{ if (buttonIndex == 0 &amp;&amp; alertView.tag == 100) { NSURL * url = [NSURL URLWithString:UIApplicationOpenSettingsURLString]; if([[UIApplication sharedApplication] canOpenURL:url]) { [[UIApplication sharedApplication] openURL:url]; } }} 重新拍照 12345678910#pragma mark - 重新拍照- (void)reCam{ self.imageView.image = nil; [self.imageView removeFromSuperview]; [self.session startRunning]; self.topView.alpha = 1; self.PhotoButton.alpha = 1; self.reCamButton.alpha = 0; self.selectButton.alpha = 0;} 选择照片 返回上级 123456789101112131415#pragma mark - 选择照片 返回上级- (void)selectImage{ [self saveImageToPhotoAlbum:self.image]; self.imageblock(self.image); [self.navigationController popViewControllerAnimated:YES];}-(void)viewDidDisappear:(BOOL)animated{ }- (void)focusDidFinsh{ self.focusView.hidden = YES; self.focusView.transform = CGAffineTransformMakeScale(1.0f, 1.0f); //self.focusView.transform=CGAffineTransformMakeScale(0.7f, 0.7f);} 对焦框动画123456789101112131415161718192021222324252627- (void)startFocusAnimation{ self.focusView.hidden = NO; self.focusView.transform = CGAffineTransformMakeScale(1.25f, 1.25f);//将要显示的view按照正常比例显示出来 [UIView beginAnimations:nil context:UIGraphicsGetCurrentContext()]; //[UIView setAnimationCurve:UIViewAnimationCurveEaseInOut]; //InOut 表示进入和出去时都启动动画 //[UIView setAnimationWillStartSelector:@selector(hiddenFoucsView)]; [UIView setAnimationDidStopSelector:@selector(hiddenFocusAnimation)]; [UIView setAnimationDuration:0.5f];//动画时间 self.focusView.transform = CGAffineTransformIdentity;//先让要显示的view最小直至消失 [UIView commitAnimations]; //启动动画 //相反如果想要从小到大的显示效果，则将比例调换 }- (void)hiddenFocusAnimation{ [UIView beginAnimations:nil context:UIGraphicsGetCurrentContext()]; //NSDate *DATE = [NSDate date]; //[UIView setAnimationStartDate:[NSDate date]]; [UIView setAnimationDelay:3]; self.focusView.alpha = 0; [UIView setAnimationDuration:0.5f];//动画时间 [UIView commitAnimations]; }- (void)hiddenFoucsView{ self.focusView.alpha = !self.focusView.alpha;} 写在最后 第一次自定义一个相机，代码写的可能不太好理解。 这个项目在码云的git库上有，地址为https://git.oschina.net/LiynXu/PhotoDemo.git。 如果有任何意见或者建议，或者发现bug(应该是有的),请移步值git库下给予指导，3Q。","link":"/2017/08/18/ios-zi-ding-yi-xiang-ji-de-shi-xian/"},{"title":"iOS--富文本推送UNNotificationExtension基础篇","text":"本文主要讲述如何集成富文本推送的相关扩展，另外还会有文章来详细展开 简介本地推送和远程推送同时都可支持附带Media Attachments。不过远程通知需要实现通知服务扩展（UNNotificationServiceExtension），在service extension里面去下载attachment，但是需要注意，service extension会限制下载的时间（30s），并且下载的文件大小也会同样被限制。这里毕竟是一个推送，而不是把所有的内容都推送给用户。所以你应该去推送一些缩小比例之后的版本。比如图片，推送里面附带缩略图，当用户打开app之后，再去下载完整的高清图。视频就附带视频的关键帧或者开头的几秒，当用户打开app之后再去下载完整视频。attachment支持图片，音频，视频，附件支持的类型及大小 准备工作添加Notification Service Extension在当前工程项目中添加新的Target–&gt; Notification Service先在Xcode 打开你的工程，File–&gt;New–&gt;Target然后添加这个Notification Service Extension： 添加Notification Content Extension在当前工程项目中添加新的Target–&gt; Notification Content先在Xcode 打开你的工程，File–&gt;New–&gt;Target然后添加这个Notification Content Extension： 添加扩展完成这样你的项目中就会有两个Extension Target 设置ServiceExtension Info.plist 添加http协议支持，没错，这里是支持http协议的，不像其他文章说的不支持 ContentExtension Info.plist 设置可以改变 如果不想使用故事版把NSExtensionMainStoryboard替换为NSExtensionPrincipalClass（我这里已经） ServiceExtension基本设置 当前Target的BundleID根据项目主Target的BundleID自动生成 格式”项目主Target的BundleID.-当前Target名称” 例如当前项目BundleID为 com.apple.NotificationDemo，ServiceExtension的名字是NotificationService 那么ServiceExtension的BundleID就是com.apple.NotificationDemo.-NotificationService Automatically manages signing 官方建议勾选 Deployment Target 必须设置为10.0以上，不能设置为10.0以下 ContentExtension基本设置 当前Target的BundleID根据项目主Target的BundleID自动生成 格式”项目主Target的BundleID.-当前Target名称” 例如当前项目BundleID为 com.apple.NotificationDemo，ContentExtension的名字是NotificationContent 那么ServiceExtension的BundleID就是com.apple.NotificationDemo.-NotificationContent Automatically manages signing 官方建议勾选 Deployment Target 必须设置为10.0以上，不能设置为10.0以下 如何使用 首先当前应用需要支持APNS,不支持的自己集成去吧服务器向设备发送通知这个通知消息的格式是有要求的，有以下几点需要注意： aps字段必须要有，不然收不到通知 aps字段下alert字段必须要有，不然也收不到通知 alert字段的值是字符串的时候，不可为空，不然的话你虽然收的到通知，但是是手机除了震动或者声音，没有任何提示 alert字段的值是字典的时候，下面这三个字段必须要有一个，不然和上面一样。就是一句话alert的值必须是可以使用的 mutable-content字段值最好是1，目前没见过其他值 如果你想在iOS10上展示位富文本的推送格式，category字段必须带，值必须在info.plist文件中能找的到的 1234567891011121314 { &quot;aps&quot;:{ &quot;alert&quot; : { &quot;title&quot; : &quot;iOS远程消息主标题！-title&quot;, &quot;subtitle&quot; : &quot;iOS远程消息副标题！-Subtitle&quot;, &quot;body&quot; : &quot;longge -body&quot; }, &quot;sound&quot; : &quot;default&quot;, &quot;badge&quot; : &quot;1&quot;, &quot;mutable-content&quot; : &quot;1&quot;, &quot;category&quot; : &quot;Image_Category&quot;, }, &quot;image&quot; : &quot;http://ot260qjni.bkt.clouddn.com/testOne.jpeg&quot;} 上面的测试图片好像不能用了（具体能不能用你们最好测试一下，直接浏览器打开能看到就可以用），我也不知道为啥 你们可以自己去找找先关的图床。","link":"/2017/07/14/ios-unnotificationextension/"},{"title":"macOS--Cocoapods的安装","text":"重新配置gem源替换1gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/ 查看1gem sources -l 请确保只有一个gem源—“https://gems.ruby-china.org/” 123*** CURRENT SOURCES ***https://gems.ruby-china.org/","link":"/2017/07/14/macos-cocoapods-de-an-zhuang/"},{"title":"macOS--制作Mac引导盘","text":"如何制作Mac引导盘制作mac的引导盘方法不止这一种，请严格按照要求来操作，出毛病我是不负责的哦。 准备工作 8GB U盘一个（这个是容量下限，最低8GB，最好是USB3.0或者以上） 一个正常使用的macOS 下载原版系统 (已下载可以忽略) 打开AppStore 看AppStore窗口右侧 macOS ······ 点击 下载 等（这个看网速的） 制作引导盘【注意】每个输入都和之前的一句隔着一个 空格 打开终端（terminal） 输入 “sudo” 1sudo 打开Finder（新版系统叫访达） 进入应用程序 点击刚刚下载的系统 右键–显示包内容 找到路径**”Contents/Resources/createinstallmedia”**，直接拖至终端,然后代码应该是下面这种 123sudo /Applications/Install\\ macOS\\ High\\ Sierra.app/Contents/Resources/createinstallmedia 注意 sudo 后有 空格 接着输入以下代码 12--volume 语句现在是这样的 123sudo /Applications/Install\\ macOS\\ High\\ Sierra.app/Contents/Resources/createinstallmedia --volume 然后输入你的U盘盘符 123/Volumes/macOS 语句现在是这样的 123sudo /Applications/Install\\ macOS\\ High\\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/macOS 下一步 123--applicationpath 语句现在是这样的 123sudo /Applications/Install\\ macOS\\ High\\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/macOS --applicationpath 下一步 直接把应用程序内的“安装macOS High Sierra.app”拖进终端 语句现在是这样的 123sudo /Applications/Install\\ macOS\\ High\\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/macOS --applicationpath /Applications/Install\\ macOS\\ High\\ Sierra.app 下一步 123--nointeraction 语句现在是这样的 123sudo /Applications/Install\\ macOS\\ High\\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/macOS --applicationpath /Applications/Install\\ macOS\\ High\\ Sierra.app --nointeraction 回车 （提示输入密码） 123Password: 输入管理员密码 回车 正在格式化磁盘 123Erasing Disk: 0%... 10%... 20%... 30%...100%... 正在拷贝安装器文件 123Copying installer files to disk... 这个时候你就可以看到你的U盘名称变了，而且里面多了一个系统，不过这个时候并没有完成 大概需要等待5-10分钟，这个时间长短主要取决于你U盘的写入速率 当显示下面信息是就代表制作完成 1234567Copy complete.Making disk bootable...Copying boot files...Copy complete.Done.","link":"/2018/04/07/macos-make-boot-usb-disk-for-mac/"},{"title":"macOS--苹果笔记本安装Win","text":"Mac–苹果笔记本安装Win(价值200块)为什么说是价值200块呢？ 是因为你拿着你的mac去任何一个电脑店让老板给您装Windows系统，应该会找你要200。 另外本文主要讲述的Windows系统为最新版的Win10 1709版本。 1、因为他们都觉得买得起mac的不差这200块钱。 2、还有一个原因就是因为mac贵，所以我提供的服务也贵。 3、以上两条都是为了坑点钱，其实给mac装Win系统很简单。 比我给windows装mac简单多了。 首先下载一个Windows的ISO镜像文件如果不会参看如何下载Windows系统 使用bootcamp把系统写入到U盘 请注意，下载好的系统最好放在mac上 这里你需要一个最小8GB的U盘，里面要是空的，因为要格式化，有数据的注意备份。 然后插U盘到MAC上。 打开bootcamp(新版系统叫 启动转换助理 ) 继续 勾选三个钩（win7第一个可以不钩） 继续 选择你刚才下载好的ISO系统文件 继续 等 分区，大小可以用鼠标挪动 重启就开始安装了 安装Windows具体步骤参看【UEFI引导安装Win10】 注意 选择安装盘的这一步具体操作如下： 选择带有bootcamp的分区，应该是第三个 或者 第四个（选择完成之后下方会有警告提示：不能安装到当前分区。。。。。。） 然后点击下方格式化（请确认上一步硬盘是否选错） 格式化之后，第一步的警告提示就应该消失了 下一步 其他步骤基本无异 再次重启进入Windows之后，打开U盘中的bootcamp.exe安装上去。这个文件是苹果电脑的驱动支持软件，不装的话估计你连网都没有哦。 是不是很简单完！","link":"/2018/03/11/macos-ping-guo-bi-ji-ben-an-zhuang-win/"},{"title":"Windows--远程桌面账号密码输入正确却显示凭据失败","text":"Windows–远程桌面账号密码输入正确却显示凭据失败的解决方法Windows A电脑 通过自带的远程桌面连接 Windows B电脑 A电脑：客户端 B电脑：服务器 一般来说客户端不需要什么操作 下面来说一下服务器端 第一步：Win+R 第二步：输入gpedit.msc 然后回车 进入计算机策略配置 依次点开“计算机配置”→“Window设置”→“安全设置”→“本地策略”→“安全选项” 找到“网络访问：本地账户的共享和安全模型” 按下图更改为“经典-对本地用户进行身份验证，不改变其本来身份”","link":"/2021/10/11/windows-remotedestopone/"},{"title":"iOS--AES加密","text":"密码学中的高级加密标准（Advanced Encryption Standard，AES），又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。加密代码都在这里 AES加密方法 1234567891011121314151617181920212223242526272829303132333435363738/** * AES加密 * aesKey 加密Key */+(NSData *)AESParmEncryptWithKey:(NSString *)AES_Key andEncryptData:(NSData *)encryptData //加密{ NSString * kInitVector = [AES_Key copy]; //16位偏移，CBC模式才有 NSData *initVector = [kInitVector dataUsingEncoding:NSUTF8StringEncoding]; //公钥 char keyPtr[kCCKeySizeAES128+1]; memset(keyPtr, 0, sizeof(keyPtr)); [AES_Key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding]; //数据长度 NSUInteger dataLength = encryptData.length; //加密输出缓冲区大小 size_t bufferSize = dataLength + kCCBlockSizeAES128; //加密输出缓冲区 void *buffer = malloc(bufferSize); //实际输出大小 size_t numBytesEncrypted = 0; CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt,//kCCEncrypt 代表加密 kCCDecrypt代表解密 kCCAlgorithmAES,//加密算法 kCCOptionPKCS7Padding,//CBC -&gt; PKCS7Padding，ECB -&gt; kCCOptionPKCS7Padding|kCCOptionECBMode keyPtr, kCCBlockSizeAES128,//密钥长度128 initVector.bytes,//偏移字符串, ECB模式传NULL encryptData.bytes,//编码内容 dataLength, buffer, bufferSize, &amp;numBytesEncrypted); if (cryptStatus == kCCSuccess) { return [NSData dataWithBytesNoCopy:buffer length:numBytesEncrypted]; } free(buffer); return nil;} 12345678910111213141516171819202122/** * AES加密 * aesKey 加密Key */+ (NSString *)AES_EncryptWithKey:(NSString *)AES_Key andEncryptText:(NSString *)encryptText{ AES_Key = [AESUtils checkAESKey:AES_Key]; const char *cstr = [encryptText cStringUsingEncoding:NSUTF8StringEncoding]; NSData *data = [NSData dataWithBytes:cstr length:encryptText.length]; //对数据进行加密 NSData *result = [AESUtils AESParmEncryptWithKey:AES_Key andEncryptData:data]; //转换为2进制字符串 if (result &amp;&amp; result.length &gt; 0) { Byte *datas = (Byte*)[result bytes]; NSMutableString *output = [NSMutableString stringWithCapacity:result.length * 2]; for(int i = 0; i &lt; result.length; i++){ [output appendFormat:@&quot;%02x&quot;, datas[i]]; } return output; } return nil;} AES解密方法 12345678910111213141516171819202122232425262728293031323334353637/** * AES解密 * aesKey 加密Key */+ (NSData *)AESParmDecryptWithKey:(NSString *)AES_Key andDecryptData:(NSData *)decryptData //解密{ NSString * kInitVector = [AES_Key copy]; //16位偏移，CBC模式才有 NSData *initVector = [kInitVector dataUsingEncoding:NSUTF8StringEncoding]; //公钥 char keyPtr[kCCKeySizeAES128+1]; memset(keyPtr, 0, sizeof(keyPtr)); [AES_Key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding]; //数据长度 NSUInteger dataLength = decryptData.length; //加密输出缓冲区大小 size_t bufferSize = dataLength + kCCBlockSizeAES128; //加密输出缓冲区 void *buffer = malloc(bufferSize); //实际输出大小 size_t numBytesDecrypted = 0; CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt,//kCCEncrypt 代表加密 kCCDecrypt代表解密 kCCAlgorithmAES,//加密算法 kCCOptionPKCS7Padding,//CBC -&gt; PKCS7Padding，ECB -&gt; kCCOptionPKCS7Padding|kCCOptionECBMode keyPtr, kCCBlockSizeAES128,//密钥长度128 initVector.bytes,//偏移字符串,, ECB模式传NULL decryptData.bytes,//编码内容 dataLength, buffer, bufferSize, &amp;numBytesDecrypted); if (cryptStatus == kCCSuccess) { return [NSData dataWithBytesNoCopy:buffer length:numBytesDecrypted]; } free(buffer); return nil;} 1234567891011121314151617181920212223242526/** * AES解密 * aesKey 加密Key */+ (NSString *)AES_DecryptWithKey:(NSString *)AES_Key andDecryptText:(NSString *)decryptText{ AES_Key = [AESUtils checkAESKey:AES_Key]; //转换为2进制Data NSMutableData *data = [NSMutableData dataWithCapacity:decryptText.length / 2]; unsigned char whole_byte; char byte_chars[3] = {'\\0','\\0','\\0'}; int i; for (i=0; i &lt; [decryptText length] / 2; i++) { byte_chars[0] = [decryptText characterAtIndex:i*2]; byte_chars[1] = [decryptText characterAtIndex:i*2+1]; whole_byte = strtol(byte_chars, NULL, 16); [data appendBytes:&amp;whole_byte length:1]; } //对数据进行解密 NSData* result = [AESUtils AESParmDecryptWithKey:AES_Key andDecryptData:data]; if (result &amp;&amp; result.length &gt; 0) { return [[NSString alloc] initWithData:result encoding:NSUTF8StringEncoding]; } return nil;} 123456789101112131415/** * 加密key检查 * aesKey 加密Key */+ (NSString *)checkAESKey:(NSString *)AES_Key{ if (AES_Key.length &lt; 16) { NSMutableArray *array = [NSMutableArray arrayWithArray:@[AES_Key]]; while (array.count &lt;= 16 - AES_Key.length) { [array insertObject:@&quot;0&quot; atIndex:0]; } AES_Key = [array componentsJoinedByString:@&quot;&quot;]; } return AES_Key;} Demo地址Demo如有错误请指出。","link":"/2021/07/29/ios-aes-encrypt/"},{"title":"iOS--浅谈生成一个单例","text":"浅谈生成一个单例单例作为非常常用的一个设计模式来说，是每个Coder必备的技能之一，但是还有很多人可能写了个假单例，就是我换种实例化方法可能就生成了一个新的对象。 1、为什么要生成一个单例对象 为了确保在整个应用期间只有一个实例，以达到用户的特定的使用目的。 对于频繁使用的对象，可以把多次创建对象所花费的时间节省下来，提高运行效率。 如果对象所占用的空间大，那么就可以节省大量不必要的空间，降了内存压力。 2、生成单例需要注意的问题 不同实例化方法可能返回不同的对象 3、如何生成一个单例首先在当前类文件中声明一个全局静态对象 123@implementation TestObjectClassstatic TestObjectClass *_testClass = nil; 写一个类方法，初始化全局静态对象 123456+ (instancetype)shareObject{ if (_testClass == nil) { _testClass = [[super alloc]init]; } return _testClass;} 重写allocWithZone方法，拦截alloc方法，防止生成新对象（使用synchronized，并优化同步锁） 12345678910+ (instancetype)allocWithZone:(struct _NSZone *)zone { if (_testClass == nil) { @synchronized (self) { if (_testClass == nil) { _testClass = [super allocWithZone:zone]; } } } return _testClass;} 重写allocWithZone方法，拦截alloc方法，防止生成新对象（使用dispatch_once） 12345678910+ (instancetype)allocWithZone:(struct _NSZone *)zone { static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ if (_testClass == nil) { _testClass = [super allocWithZone:zone]; } }); return _testClass;} 重写copyWithZone方法，拦截copy方法，防止生成新对象 123- (id)copyWithZone:(nullable NSZone *)zone { return _testClass;} 重写mutableCopyWithZone方法，拦截mutableCopy方法，防止生成新对象 123- (id)mutableCopyWithZone:(nullable NSZone *)zone { return _testClass;} 如有纰漏请多多指教。 简书：https://www.jianshu.com/p/03eb4f2203bdCSDN：https://blog.csdn.net/ZuoWeiXiaoDuZuoZuo/article/details/116001644","link":"/2021/04/22/ios-qian-tan-sheng-cheng-yi-ge-dan-li/"},{"title":"macOS--cocoapodsPackager编译动态库","text":"cocoapods-packager编译动态库失败的解决由于近期在研究私有库打包，发现此问题。 起因一开始运行此段代码pod package *******.podspec --force --no-mangle毫无问题。然后就开始尝试生成一个动态库，于是加上了--dynamic，此时出现了下面一大串代码。 12345678910111213 CocoaPods : 1.9.3 Ruby : ruby 2.6.3p62 (2019-04-16 revision 67580) [universal.x86_64-darwin19] RubyGems : 3.0.3 Host : Mac OS X 10.15 (19A582a) Xcode : 11.3.1 (11C504) Git : git version 2.21.1 (Apple Git-122.3)Ruby lib dir : /System/Library/Frameworks/Ruby.framework/Versions/2.6/usr/libRepositories : ARSpecRepo - git - git@gitlab.allride-ai.cn:infra/ios-common.git @ b1f3805d2a766c9509bde74f4574270917dce669 cocoa-local - file system master - git - https://github.com/CocoaPods/Specs.git @ 163b8a8c3e6980b42c623bc76f6b136f8c68d19c trunk - CDN - https://cdn.cocoapods.org/ 12345678cocoapods-art : 1.0.4cocoapods-deintegrate : 1.0.4cocoapods-packager : 1.5.0cocoapods-plugins : 1.0.0cocoapods-search : 1.0.0cocoapods-stats : 1.1.0cocoapods-trunk : 1.4.1cocoapods-try : 1.1.0 123456789101112131415ArgumentError - wrong number of arguments (given 3, expected 7..10)/usr/local/lib/ruby/gems/2.6.0/gems/cocoapods-1.9.3/lib/cocoapods/target/pod_target.rb:137:in `initialize'/usr/local/lib/ruby/gems/2.6.0/gems/cocoapods-packager-1.5.0/lib/cocoapods-packager/pod_utils.rb:161:in `new'/usr/local/lib/ruby/gems/2.6.0/gems/cocoapods-packager-1.5.0/lib/cocoapods-packager/pod_utils.rb:161:in `build_dynamic_target'/usr/local/lib/ruby/gems/2.6.0/gems/cocoapods-packager-1.5.0/lib/cocoapods-packager/pod_utils.rb:131:in `install_dynamic_pod'/usr/local/lib/ruby/gems/2.6.0/gems/cocoapods-packager-1.5.0/lib/pod/command/package.rb:83:in `build_in_sandbox'/usr/local/lib/ruby/gems/2.6.0/gems/cocoapods-packager-1.5.0/lib/pod/command/package.rb:100:in `block in build_package'/usr/local/lib/ruby/gems/2.6.0/gems/cocoapods-packager-1.5.0/lib/pod/command/package.rb:99:in `each'/usr/local/lib/ruby/gems/2.6.0/gems/cocoapods-packager-1.5.0/lib/pod/command/package.rb:99:in `build_package'/usr/local/lib/ruby/gems/2.6.0/gems/cocoapods-packager-1.5.0/lib/pod/command/package.rb:66:in `run'/usr/local/lib/ruby/gems/2.6.0/gems/claide-1.0.3/lib/claide/command.rb:334:in `run'/usr/local/lib/ruby/gems/2.6.0/gems/cocoapods-1.9.3/lib/cocoapods/command.rb:52:in `run'/usr/local/lib/ruby/gems/2.6.0/gems/cocoapods-1.9.3/bin/pod:55:in `&lt;top (required)&gt;'/usr/local/lib/ruby/gems/2.6.0/bin/pod:24:in `load'/usr/local/lib/ruby/gems/2.6.0/bin/pod:24:in `&lt;main&gt;' 然后同事的电脑可以正常打包，我查看了他的电脑环境，发现ruby是2.3.7，我以为是此处发生问题，于是开始了降级Ruby，然而。。。。。。事情并没有这么简单。 我以为降级就会成功因为我的系统已经更新到了10.15 Catalina，默认的Ruby版本就是2.6.3。 降级Ruby就得降级系统，但是降级系统到10.14总是不成功，总是提示 更新固件时发生错误。退出安装器以重新启动电脑，然后再次尝试。 然后我想起来这可能是联网验证的结果，于是我关闭wifi，调整时间到15年，然而。。。。。。。。。。还是会出现 更新固件时发生错误。退出安装器以重新启动电脑，然后再次尝试。 看来断了wifi还是没有用，最后发现安装过程中会重启几次，重启的时候wifi会自动开启然后连上我的路由器，于是我就把路由器的网线拔了，wifi让你连有网算我输！ 然后。。。。。。。。居然成功了。哎。我太难了。 进入系统后一顿初始化， * 下载Xcode * 安装cocoapods * 安装cocoapods-packager * 拉代码 等啊等，个把小时搞定这些事。 package *******.podspec --force --dynamic --no-mangle```打包ing123456789101112131415161718192021然后。。。。。。啊。。。。。。。还是报错啊！！！！！！！！！！！和之前除了工具版本不一致。其他基本一模一样。看来不是Ruby版本的问题。### 刚才方向不对，再来于是我就想是不是cocoapods-packager自己的锅。迅速去Github上的cocoapods-packager项目看issues。发现了一个问题： [**issues#257** Fail to build a pod into dynamic framework](https://github.com/CocoaPods/cocoapods-packager/issues/257)细心的我发现了一句话```Look at the master branch, the calling to Pod::PodTarget.new has changed.```我马不停蹄的查看了cocoapods-packager本机的代码，目录在这```cocoapods-packager/lib/cocoapods-packager/pod_utils.rb``` file_accessors = create_file_accessors(static_target, dynamic_sandbox) archs = [] dynamic_target = Pod::PodTarget.new(dynamic_sandbox, true, static_target.user_build_configurations, archs, platform, static_target.specs, static_target.target_definitions, file_accessors) dynamic_target end 123Githu上现存的master分支 dynamic_target = Pod::PodTarget.new(static_target.specs, static_target.target_definitions, dynamic_sandbox) dynamic_target.host_requires_frameworks = true dynamic_target.user_build_configurations = static_target.user_build_configurations dynamic_target end 对比发现这一段代码不一样，虽然我看不懂、、、、、、我是真的不会ruby。 问题到这里差不多就解决了一大半，因为我已经找到了原因。 ### 发现解决方法 这个时候我```sudo gem uninstall cocoapods-packager```，卸载掉cocoapods-packager。 开始源码安装cocoapods-packager。 首先拉取源代码 ```git clone https://github.com/CocoaPods/cocoapods-packager.git``` 完毕之后进入目录 ```cocoapods-packager``` * 查看bundler是否安装```gem list bundler ```(没有出现bundler的话就```gem install bundler```) * 安装依赖项```bundler install``` * 执行```sudo gem build cocoapods-packager.gemspec ```语句后会生成cocoapods-packager-1.5.0.gem文件 * 将生成的cocoapods-packager-1.5.0.gem 文件执行本地安装```sudo gem install cocoapods-packager-1.5.0.gem -l``` 为了更稳我重启了终端。 接着 ```pod package *******.podspec --force --dynamic --no-mangle```打包ing 出现了 ```Building dynamic framework **** (****) with configuration Release``` 成功了。。。。。。 太难了。 此时我的编译环境是 * macOS 10.14.6 * Xcode 11.3 下面就想，新系统上行不行的通，现在验证之前又不能升级。。。。 emmmm。。。。。 我还有个blackApple。 ### 最新编译环境验证 另外一个设备的编译环境是 * macOS 10.15.7 * Xcode 12.0.1 都是最新的。 卸载掉gem安装的cocoapods-packager。 源码安装cocoapods-packager。 接着 ```pod package *******.podspec --force --dynamic --no-mangle```打包ing 出现了 ```Building dynamic framework **** (****) with configuration Release``` 哎。又成功了。Happy。。。。 马上把我笔记本的东西都升级了。美滋滋。。。 特此记录。。。。。。。。。。。 ### 完","link":"/2020/09/28/macos-cocoapodspackager-bian-yi-dong-tai-ku/"},{"title":"iOS--引用子类对象作为属性","text":"某位同事编码。一个类引用一个子类对象作为属性。 123456#import &lt;Foundation/Foundation.h&gt;#import &quot;CycleFindTestClas.h&quot;@interface TestObjectClass : NSObject@property (nonatomic, strong) CycleFindTestClas *cycle;@end 123456789#import &quot;TestObjectClass.h&quot;// 此声明CycleFindTestClas类的代码会被编译器报错//（Cannot find interface declaration for 'TestObjectClass', superclass of 'CycleFindTestClas'）@interface CycleFindTestClas : TestObjectClass@end 以下为本人猜测，如果纰漏请多多指教。 究其原因，其实很简单。编译器查找某个类无非是两种。 通过文件查找 #import “ClassName.h” 通过前置声明 @class name; 上述代码没有前置声明，那么查找TestObjectClass类必然要通过文件，于是开始了下面的流程 编译器查到了TestObjectClass.h文件 然后开始从上到下遍历TestObjectClass.h代码 发现Foundation.h内没有，于是查找下一行CycleFindTestClas.h 发现CycleFindTestClas.h有TestObjectClass，但是这个TestObjectClass是个父类，那么继续开始查找TestObjectClass的声明 编译器查到了TestObjectClass.h文件 然后开始从上到下遍历TestObjectClass.h代码 ······························ 是不是循环了 所以根本就查找不到 TestObjectClass的声明@interface TestObjectClass : NSObject。所以我们在日常编码中 .h 内尽量不再引用其他自定义类的 .h 文件，尽量使用前置声明某个类. 12345@class CycleFindTestClas;#import &lt;Foundation/Foundation.h&gt;@interface TestObjectClass : NSObject@property (nonatomic, strong) CycleFindTestClas *cycle;@end","link":"/2021/04/22/ios-yin-yong-zi-lei-dui-xiang-zuo-wei-shu-xing/"},{"title":"Xcode下载地址大全","text":"Xcode下载——绝对的官方地址下载方式简单粗暴：第一种、点击Xcode版本名称稍等几秒即可开始下载另一种、右键复制链接地址，打开下载软件，新建任务把复制的链接粘贴在地址输入框即可开始下载本文中涉及到的下载地址均为苹果官方下载地址 Xcode 2Xcode_2.3.dmg 915.0MBXcode_2.4.dmg 938.2MBXcode_2.4.1.dmg 923.2MB Xcode 3Xcode_3.0.dmg 1.1GBXcode_3.2.dmg 748.7MBXcode_3.2.3_and_ios_sdk_4.0.1.dmg 2.2GBXcode_3.2.3_and_ios_sdk_4.0.2.dmg 2.4GBXcode_3.2.4_and_ios_sdk_4.1.dmg 2.9GBXcode_3.2.5_and_ios_sdk_4.2.dmg 3.5GBXcode_3.2.6_and_ios_sdk_4.3.dmg 4.1GB Xcode 4Xcode_4_and_ios_sdk_4.3.dmg 4.2GBXcode_4.0.1_and_ios_sdk_4.3.dmg 4.2GBXcode_4.0.2_and_ios_sdk_4.3.dmg 4.2GBXcode_4.1_for_snow_leopard.dmg 4.3GBXcode_4.1_for_lion.dmg 2.9GBXcode_4.2_for_snow_leopard.dmg 1.6GBXcode_4.2_for_lion.dmg 1.6GBXcode_4.2.1_for_lion.dmg 1.6GBXcode_4.3_for_lion.dmg 1.4GBXcode_4.3.1_for_lion.dmg 1.4GBXcode_4.3.2_for_lion.dmg 1.8GBXcode_4.3.3_for_lion.dmg 1.8GBXcode_4.4.dmg 1.8GBXcode_4.4.1.dmg 1.8GBXcode_4.5.dmg 1.5GBXcode_4.5.1.dmg 1.5GBXcode_4.5.2.dmg 1.5GBXcode_4.6.dmg 1.6GBXcode_4.6.1.dmg 1.6GBXcode_4.6.2.dmg 1.6GBXcode_4.6.3.dmg 1.6GB Xcode 5Xcode_5.dmg 1.9GBXcode_5.0.1.dmg 2.0GBXcode_5.0.2.dmg 2.0GBXcode_5.1.dmg 2.1GBXcode_5.1.1.dmg 2.1GB Xcode 6Xcode_6.0.1.dmg 2.1GBXcode_6.1.dmg 2.5GBXcode_6.1.1.dmg 2.5GBXcode_6.2.dmg 2.5GBXcode_6.3.dmg 2.5GBXcode_6.3.1.dmg 2.5GBXcode_6.3.2.dmg 2.5GBXcode_6.4.dmg 2.6GB Xcode 7Xcode_7.dmg 3.5GBXcode_7.0.1.dmg 3.5GBXcode_7.1.dmg 4.2GBXcode_7.1.1.dmg 4.2GBXcode_7.2.dmg 4.4GBXcode_7.2.1.dmg 4.4GBXcode_7.3.dmg 4.8GBXcode_7.3.1.dmg 4.8GB Xcode 8Xcode_8.xip 4.1GBXcode_8.1.xip 4.1GBXcode_8.2.xip 4.2GBXcode_8.2.1.xip 4.2GBXcode_8.3.xip 4.1GBXcode_8.3.1.xip 4.1GBXcode_8.3.2.xip4.1GB","link":"/2017/07/14/macos-xcode-xia-zai-di-zhi/"},{"title":"iOS--浅谈消息转发机制","text":"iOS–浅谈消息转发机制相信大家对这句话unrecognized selector sent to instance 0x*********一点都不陌生吧。 下面就来简单说一下 拯救即将崩溃代码–iOS的消息转发 动态绑定引发因为OC是一个动态运行时语言，其中之一的特性就是动态绑定。 关于动态绑定，苹果官网的给的解释为：（determining the method to invoke at runtime）。 简单点来说就是：程序直到执行时才能确定实际要调用的方法。 这样就会造成一个问题，我可以向一个实例发送一个消息，让它执行一个不属于自己的方法。这个时候就会出现unrecognized selector sent to instance。 如果发生这种情况，那么我们就可以应用消息转发来解决这个问题。把这个不属于自己的方法变成属于自己的方法，或者找一个有这个方法的实例来执行这个方法。在程序抛出这个错误之前我们有三次可以修正这个错误的机会。 拯救即将崩溃代码第一步 方法解析处理阶段 | 动态方法决议 该方法内可为当前类动态添加方法。 将sel的方法实现指向一个已存在的方法 123456789101112131415161718192021/** 方法解析处理阶段 | 动态方法决议 该方法内可为当前类动态添加方法。 将sel的方法实现指向一个已存在的方法 */+ (BOOL)resolveInstanceMethod:(SEL)sel{ NSString *selectorString = NSStringFromSelector(sel); printf(&quot;%s %s\\n&quot;, __func__, selectorString.UTF8String); // 根据 sel 得到 class 的实例方法 Method method = class_getInstanceMethod([self class], @selector(dynamic_method)); // 根据 sel 得到 class 的函数指针 IMP method_imp = class_getMethodImplementation([self class], @selector(dynamic_method)); // 给找不到实现的sel添加实现 BOOL ret = class_addMethod([self class], sel, method_imp, method_getTypeEncoding(method)); printf(&quot;%s\\n&quot;, ret?&quot;交换添加成功&quot;:&quot;交换添加失败&quot;); // 返回结果不影响流程 return YES;} 为什么说上面resolveInstanceMethod的返回结果不影响实际流程呢，看下面runtime的源码。我们可以看到 123456789101112131415161718192021222324252627282930313233343536373839404142/************************************************************************ resolveInstanceMethod* Call +resolveInstanceMethod, looking for a method to be added to class cls.* cls may be a metaclass or a non-meta class.* Does not check if the method already exists.**********************************************************************/static void resolveInstanceMethod(id inst, SEL sel, Class cls){ runtimeLock.assertUnlocked(); ASSERT(cls-&gt;isRealized()); SEL resolve_sel = @selector(resolveInstanceMethod:); if (!lookUpImpOrNilTryCache(cls, resolve_sel, cls-&gt;ISA(/*authenticated*/true))) { // Resolver not implemented. return; } BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend; // 执行了resolveInstanceMethod方法，得到了一个结果resolved bool resolved = msg(cls, resolve_sel, sel); // Cache the result (good or bad) so the resolver doesn't fire next time. // +resolveInstanceMethod adds to self a.k.a. cls IMP imp = lookUpImpOrNilTryCache(inst, sel, cls); // resolved只影响了信息的输出 if (resolved &amp;&amp; PrintResolving) { if (imp) { _objc_inform(&quot;RESOLVE: method %c[%s %s] &quot; &quot;dynamically resolved to %p&quot;, cls-&gt;isMetaClass() ? '+' : '-', cls-&gt;nameForLogging(), sel_getName(sel), imp); } else { // Method resolver didn't add anything? _objc_inform(&quot;RESOLVE: +[%s resolveInstanceMethod:%s] returned YES&quot; &quot;, but no new implementation of %c[%s %s] was found&quot;, cls-&gt;nameForLogging(), sel_getName(sel), cls-&gt;isMetaClass() ? '+' : '-', cls-&gt;nameForLogging(), sel_getName(sel)); } }} 第二步 快速转发阶段 | 快速查找 上一步未解决问题时触发。 返回一个能响应aSelector的实例，即将aSelector转发给另外的类。 12345678910111213141516171819/** 快速转发阶段 | 快速查找 上一步未解决问题时触发。 返回一个能响应aSelector的实例，即将aSelector转发给另外的类。 */- (id)forwardingTargetForSelector:(SEL)aSelector{ NSString *selectorString = NSStringFromSelector(aSelector); printf(&quot;%s %s\\n&quot;, __func__, selectorString.UTF8String); if ([selectorString isEqualToString:@&quot;no_imp_method&quot;]) { // 返回一个实现了aSelector函数的实例 // 如果该实例没有实现aSelector，则进入下一步methodSignatureForSelector printf(&quot;%s 转发消息至BackUpClass\\n&quot;,__func__); return [[BackUpClass alloc] init]; } // 返回self或者nil,则说明没有可以响应的目标,则进入下一步methodSignatureForSelector。 return nil;} 第三步 常规转发阶段 | 慢速查找 获得一个方法签名。签名由一个能响应aSelector的实例生成。 有签名则进入消息转发的最后一步forwardInvocation。 123456789101112131415/** 常规转发阶段 | 慢速查找 返回一个方法签名。签名由一个能响应aSelector的实例生成。 */- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector{ NSString *selectorString = NSStringFromSelector(aSelector); printf(&quot;%s %s\\n&quot;, __func__, selectorString.UTF8String); BackUpClass * backUp = [BackUpClass new]; NSMethodSignature * sign = [backUp methodSignatureForSelector:aSelector]; //有签名则进入消息转发的最后一步forwardInvocation return sign;} 也可以什么都不处理，至此本次消息转发结束，程序也不会crash。 12345678910111213/** 将sel转发给一个真正实现了sel的对象 也可以什么都不处理，至此本次消息转发结束，也不会crash。 */- (void)forwardInvocation:(NSInvocation *)anInvocation{ printf(&quot;%s %s\\n&quot;,__func__ , anInvocation.description.UTF8String); // 创建备用消息接收对象 BackUpClass * backUp = [[BackUpClass alloc] init]; printf(&quot;%s 转发消息至BackUpClass\\n&quot;,__func__); [anInvocation invokeWithTarget:backUp];} 写在后面浅谈。可以交流。","link":"/2021/10/18/ios-qian-tan-xiao-xi-zhuan-fa-ji-zhi/"},{"title":"iOS--日志本地化&#x2F;日志重定向","text":"写在前面本文主要是给读者分享技术的，如何保存能控制台输出的log，以便于查找程序本身出现的问题。##我们该如何做 首先我们要判断，是不是模拟器 1234567#if !(TARGET_IPHONE_SIMULATOR)//真机 //连接xcode时可以从监视器中看日志 没连接时Log日志会输出到文件中， [self redirectNSLogToDocumentFolder]; NSLog(@&quot;真机&quot;);#else//模拟器 NSLog(@&quot;模拟器&quot;);#endif 其次我们还要接着判断是不是真机连接了Xcode，然后才开始进行日志本地化文件的生成 12345678910111213141516171819202122232425262728293031323334- (void)redirectNSLogToDocumentFolder{ //如果已经连接Xcode调试则不输出到文件 if(isatty(STDOUT_FILENO)) { return; } UIDevice *device = [UIDevice currentDevice]; if([[device model] hasSuffix:@&quot;Simulator&quot;]){ //在模拟器不保存到文件中 return; } //将NSlog打印信息保存到Document目录下的Log文件夹下 NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *logDirectory = [[paths objectAtIndex:0] stringByAppendingPathComponent:@&quot;Log&quot;]; NSFileManager *fileManager = [NSFileManager defaultManager]; BOOL fileExists = [fileManager fileExistsAtPath:logDirectory]; if (!fileExists) { [fileManager createDirectoryAtPath:logDirectory withIntermediateDirectories:YES attributes:nil error:nil]; } NSDateFormatter *formatter = [[NSDateFormatter alloc] init]; [formatter setLocale:[[NSLocale alloc] initWithLocaleIdentifier:@&quot;zh_CN&quot;]]; [formatter setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;]; //每次启动后都保存一个新的日志文件中 NSString *dateStr = [formatter stringFromDate:[NSDate date]]; self.filepath = [logDirectory stringByAppendingFormat:@&quot;/%@.log&quot;,dateStr]; // 将log输入到文件 freopen([self.filepath cStringUsingEncoding:NSASCIIStringEncoding], &quot;a+&quot;, stdout); freopen([self.filepath cStringUsingEncoding:NSASCIIStringEncoding], &quot;a+&quot;, stderr); //未捕获的Objective-C异常日志 NSSetUncaughtExceptionHandler (&amp;UncaughtExceptionHandler);} 最后这是一个报错的异常信息，也就是我们所说的崩溃信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344void UncaughtExceptionHandler(NSException* exception){ NSString* name = [ exception name ]; NSString* reason = [ exception reason ]; NSArray* symbols = [ exception callStackSymbols ]; // 异常发生时的调用栈 NSMutableString* strSymbols = [ [ NSMutableString alloc ] init ]; //将调用栈拼成输出日志的字符串 for ( NSString* item in symbols ) { [ strSymbols appendString: item ]; [ strSymbols appendString: @&quot;\\r\\n&quot; ]; } //将crash日志保存到Document目录下的Log文件夹下 NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *logDirectory = [[paths objectAtIndex:0] stringByAppendingPathComponent:@&quot;Log&quot;]; NSFileManager *fileManager = [NSFileManager defaultManager]; if (![fileManager fileExistsAtPath:logDirectory]) { [fileManager createDirectoryAtPath:logDirectory withIntermediateDirectories:YES attributes:nil error:nil]; } //NSString *logFilePath = [logDirectory stringByAppendingPathComponent:@&quot;UncaughtException.log&quot;]; NSDateFormatter *formatter = [[NSDateFormatter alloc] init]; [formatter setLocale:[[NSLocale alloc] initWithLocaleIdentifier:@&quot;zh_CN&quot;]]; [formatter setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;]; AppDelegate *app = [UIApplication sharedApplication].delegate; NSString *dateStr = [formatter stringFromDate:app.date]; NSString *crashString = [NSString stringWithFormat:@&quot;&lt;- %@ -&gt;[ Uncaught Exception ]\\r\\nName: %@, Reason: %@\\r\\n[ Fe Symbols Start ]\\r\\n%@[ Fe Symbols End ]\\r\\n\\r\\n&quot;, dateStr, name, reason, strSymbols]; //把错误日志写到文件中 if (![fileManager fileExistsAtPath:app.filepath]) { [crashString writeToFile:app.filepath atomically:YES encoding:NSUTF8StringEncoding error:nil]; }else{ NSFileHandle *outFile = [NSFileHandle fileHandleForWritingAtPath:app.filepath]; [outFile seekToEndOfFile]; [outFile writeData:[crashString dataUsingEncoding:NSUTF8StringEncoding]]; [outFile closeFile]; } //把错误日志发送到邮箱 NSString *urlStr = [NSString stringWithFormat:@&quot;mailto://邮箱账号?subject=bug报告&amp;body=感谢您的配合!错误详情:%@&quot;,crashString ]; NSURL *url = [NSURL URLWithString:[urlStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]]; [[UIApplication sharedApplication] openURL:url];} 使用在AppDelegate的这个方法中编写如下代码 12345678910- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {#if !(TARGET_IPHONE_SIMULATOR)//真机 //连接xcode时可以从监视器中看日志 没连接时Log日志会输出到文件中， [self redirectNSLogToDocumentFolder]; NSLog(@&quot;真机&quot;);#else//模拟器 NSLog(@&quot;模拟器&quot;);#endifreturn YES;}","link":"/2017/08/18/ios-ri-zhi-ben-di-hua-ri-zhi-chong-ding-xiang/"},{"title":"macOS--编译FFMpeg For iOS","text":"FFmpeg iOS build script测试环境: FFmpeg 4.4.1 Xcode 13.1 (13A1030d) MacOS 11.6.1 (20G221) 注意事项 4.4目前无法编译Audiotoolbox，代码中也有写。建议编译4.3.2即可 编译依赖 https://github.com/libav/gas-preprocessor yasm 1.2.0 使用方法设定FFMpeg架构 123456789# i386 抛弃吧# armv7 也抛弃吧# x86_64 Intel专用 M1模拟器也是ARM64的# arm64# 选择编译架构ARCHS=&quot;x86_64 arm64&quot;# 最低支持版本 2021年了建议iOS11起DEPLOYMENT_TARGET=&quot;8.0&quot; 设定编译FFMpeg版本 12# 编译FFmpeg版本FFMPEG_VERSION=&quot;4.4.1&quot; 进入到当前目录直接执行脚本即可，如遇无法执行，可能是文件权限问题 123cd ios-ffmpeg-build-script-ilongge./build-ffmpeg.sh 使用依赖 VideotoolBox Audiotoolbox libz.dylib libbz2.dylib libiconv.dylib Thanks本脚本是摘抄自 FFmpeg-iOS-build-script 学习后加以改造 感谢原作者！！！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298#!/bin/shcurrent_path=$( cd &quot;$(dirname &quot;$0&quot;)&quot; pwd)echo $current_pathcd $current_path# i386 抛弃吧# armv7 也抛弃吧# x86_64 Intel专用 M1模拟器也是ARM64的# arm64# 选择编译架构ARCHS=&quot;x86_64 arm64&quot;# 最低支持版本 2021年了建议iOS11起DEPLOYMENT_TARGET=&quot;8.0&quot;# 都是已经编译过的插件的相对路径 没事别瞎改哦# X264=$(pwd)/extend/x264-ios# X265=$(pwd)/extend/x265-ios# FDK_AAC=$(pwd)/extend/fdk-aac-ios# OpenSSL=$(pwd)/extend/openssl-ios# LAME=$(pwd)/extend/lame-ios# 编译FFmpeg版本FFMPEG_VERSION=&quot;4.4.1&quot;if [[ $FFMPEG_VERSION != &quot;&quot; ]]; then FFMPEG_VERSION=$FFMPEG_VERSIONfiSOURCE=&quot;FFmpeg-$FFMPEG_VERSION&quot;FAT=$(pwd)&quot;/FFmpeg/FFmpeg-$FFMPEG_VERSION-iOS&quot;SCRATCH=$(pwd)&quot;/FFmpeg/scratch-$FFMPEG_VERSION&quot;THIN=$(pwd)&quot;/FFmpeg/thin-$FFMPEG_VERSION&quot;echo &quot;Current_Path = $(pwd)&quot;echo &quot;Build_FFmpeg_Version = $FFMPEG_VERSION&quot;echo &quot;Build_FFmpeg_ARCHS = $ARCHS&quot;CONFIGURE_FLAGS=&quot;--enable-cross-compile --disable-debug --disable-programs --disable-doc --enable-pic&quot;if [ $X264 -o $X265 ]; then CONFIGURE_FLAGS=&quot;$CONFIGURE_FLAGS --enable-gpl&quot; if [ &quot;$X264&quot; ]; then CONFIGURE_FLAGS=&quot;$CONFIGURE_FLAGS --enable-libx264 --enable-encoder=libx264&quot; fi if [ &quot;$X265&quot; ]; then CONFIGURE_FLAGS=&quot;$CONFIGURE_FLAGS --enable-libx265 --enable-encoder=libx265&quot; fifiif [ $FDK_AAC -o $OpenSSL ]; then CONFIGURE_FLAGS=&quot;$CONFIGURE_FLAGS --enable-nonfree&quot; if [ &quot;$FDK_AAC&quot; ]; then CONFIGURE_FLAGS=&quot;$CONFIGURE_FLAGS --enable-libfdk_aac --enable-encoder=libfdk_aac&quot; fi if [ &quot;$OpenSSL&quot; ]; then CONFIGURE_FLAGS=&quot;$CONFIGURE_FLAGS --enable-openssl --enable-protocol=http --enable-protocol=https --enable-protocol=hls&quot; fifiif [ &quot;$LAME&quot; ]; then CONFIGURE_FLAGS=&quot;$CONFIGURE_FLAGS --enable-libmp3lame --enable-encoder=libmp3lame&quot;fi# # avresample# #CONFIGURE_FLAGS=&quot;$CONFIGURE_FLAGS --enable-avresample&quot;COMPILE=&quot;y&quot;LIPO=&quot;y&quot;if [ &quot;$*&quot; ]; then if [ &quot;$*&quot; = &quot;lipo&quot; ]; then # skip compile COMPILE= else ARCHS=&quot;$*&quot; if [ $# -eq 1 ]; then # skip lipo LIPO= fi fifiif [ &quot;$COMPILE&quot; ]; then if [ ! $(which yasm) ]; then echo 'Yasm not found' if [ ! $(which brew) ]; then echo 'Homebrew not found. Trying to install...' ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; || exit 1 fi echo 'Trying to install Yasm...' brew install yasm || exit 1 fi if [ ! $(which gas-preprocessor.pl) ]; then echo 'gas-preprocessor.pl not found. Trying to install...' (curl -L https://github.com/libav/gas-preprocessor/raw/master/gas-preprocessor.pl \\ -o /usr/local/bin/gas-preprocessor.pl &amp;&amp; chmod +x /usr/local/bin/gas-preprocessor.pl) || exit 1 fi if [ ! -r FFmpeg/FFmpeg-$FFMPEG_VERSION ]; then SOURCE_URL=http://www.ffmpeg.org/releases/ffmpeg-$FFMPEG_VERSION.tar.bz2 echo 'FFmpeg source not found.' echo 'Trying to download from '$SOURCE_URL curl $SOURCE_URL | tar xj || exit 1 echo mv ffmpeg-$FFMPEG_VERSION FFmpeg/FFmpeg-$FFMPEG_VERSION mv ffmpeg-$FFMPEG_VERSION FFmpeg/FFmpeg-$FFMPEG_VERSION fi CWD=$(pwd) for ARCH in $ARCHS; do echo &quot;building $ARCH...&quot; mkdir -p &quot;$SCRATCH/$ARCH&quot; cd &quot;$SCRATCH/$ARCH&quot; CFLAGS=&quot;-arch $ARCH&quot; if [ &quot;$ARCH&quot; = &quot;i386&quot; -o &quot;$ARCH&quot; = &quot;x86_64&quot; ]; then PLATFORM=&quot;iPhoneSimulator&quot; CFLAGS=&quot;$CFLAGS -mios-simulator-version-min=$DEPLOYMENT_TARGET&quot; else PLATFORM=&quot;iPhoneOS&quot; CFLAGS=&quot;$CFLAGS -mios-version-min=$DEPLOYMENT_TARGET -fembed-bitcode&quot; if [ &quot;$ARCH&quot; = &quot;arm64&quot; ]; then EXPORT=&quot;GASPP_FIX_XCODE5=1&quot; fi fi XCRUN_SDK=$(echo $PLATFORM | tr '[:upper:]' '[:lower:]') CC=&quot;xcrun -sdk $XCRUN_SDK clang&quot; # force &quot;configure&quot; to use &quot;gas-preprocessor.pl&quot; (FFmpeg 3.3) if [ &quot;$ARCH&quot; = &quot;arm64&quot; ]; then AS=&quot;gas-preprocessor.pl -arch aarch64 -- $CC&quot; else AS=&quot;gas-preprocessor.pl -- $CC&quot; fi CXXFLAGS=&quot;$CFLAGS&quot; LDFLAGS=&quot;$CFLAGS&quot; if [ &quot;$X264&quot; ]; then CFLAGS=&quot;$CFLAGS -I$X264/include&quot; LDFLAGS=&quot;$LDFLAGS -L$X264/lib&quot; fi if [ &quot;$X265&quot; ]; then CFLAGS=&quot;$CFLAGS -I$X265/include&quot; LDFLAGS=&quot;$LDFLAGS -L$X265/lib&quot; fi if [ &quot;$FDK_AAC&quot; ]; then CFLAGS=&quot;$CFLAGS -I$FDK_AAC/include&quot; LDFLAGS=&quot;$LDFLAGS -L$FDK_AAC/lib&quot; fi if [ &quot;$OpenSSL&quot; ]; then CFLAGS=&quot;$CFLAGS -I$OpenSSL/include&quot; LDFLAGS=&quot;$LDFLAGS -L$OpenSSL/lib -lcrypto -lssl&quot; fi if [ &quot;$LAME&quot; ]; then CFLAGS=&quot;$CFLAGS -I$LAME/include&quot; LDFLAGS=&quot;$LDFLAGS -L$LAME/lib&quot; fi # 4.4起编译带有audiotoolbox的会报错 故按照issue关闭audiotoolbox y_or_n=$(echo $FFMPEG_VERSION &quot;4.3&quot; | awk '{if($1 &gt; $2) print 1; else print 0;}') if [ $y_or_n -eq 1 ]; then CONFIGURE_FLAGS=&quot;$CONFIGURE_FLAGS --disable-audiotoolbox&quot; fi TMPDIR=${TMPDIR/%\\//} $CWD/FFmpeg/$SOURCE/configure \\ --target-os=darwin \\ --arch=$ARCH \\ --cc=&quot;$CC&quot; \\ --as=&quot;$AS&quot; \\ $CONFIGURE_FLAGS \\ --extra-cflags=&quot;$CFLAGS&quot; \\ --extra-ldflags=&quot;$LDFLAGS&quot; \\ --prefix=&quot;$THIN/$ARCH&quot; || exit 1 #输出详细编译信息 echo ./configure / echo &quot;\\t&quot;--target-os=darwin echo &quot;\\t&quot;--arch=$ARCH echo &quot;\\t&quot;--cc=&quot;$CC&quot; echo &quot;\\t&quot;--as=&quot;$AS&quot; for FLAG in $CONFIGURE_FLAGS; do echo &quot;\\t&quot;$FLAG done echo &quot;\\n&quot; echo --extra-cflags / for FLAG in $CFLAGS; do echo &quot;\\t&quot;$FLAG done echo &quot;\\n&quot; echo --extra-ldflags / for FLAG in $LDFLAGS; do echo &quot;\\t&quot;$FLAG done echo &quot;\\n&quot; echo --prefix=&quot;$THIN/$ARCH&quot; #获取机器CPU核心数 就可能加快编译 THREAD_COUNT=$(sysctl -n machdep.cpu.thread_count) echo &quot;make -j $THREAD_COUNT install $EXPORT || exit 1&quot; make -j$THREAD_COUNT install $EXPORT || exit 1 cd $CWD donefiif [ &quot;$LIPO&quot; ]; then echo &quot;building fat binaries...&quot; mkdir -p $FAT/lib set - $ARCHS CWD=$(pwd) cd $THIN/$1/lib for LIB in *.a; do cd $CWD echo lipo -create $(find $THIN -name $LIB) -output $FAT/lib/$LIB 1&gt;&amp;2 lipo -create $(find $THIN -name $LIB) -output $FAT/lib/$LIB || exit 1 done if [ &quot;$X264&quot; ]; then Create_Lipo=&quot;lipo -create&quot; for ARCH in $ARCHS; do Create_Lipo=&quot;$Create_Lipo $X264/lib/libx264-$ARCH.a&quot; done Create_Lipo=&quot;$Create_Lipo -output $FAT/lib/libx264.a&quot; echo $Create_Lipo $($Create_Lipo) fi if [ &quot;$X265&quot; ]; then Create_Lipo=&quot;lipo -create&quot; for ARCH in $ARCHS; do Create_Lipo=&quot;$Create_Lipo $X265/lib/libx265-$ARCH.a&quot; done Create_Lipo=&quot;$Create_Lipo -output $FAT/lib/libx265.a&quot; echo $Create_Lipo $($Create_Lipo) fi if [ &quot;$FDK_AAC&quot; ]; then Create_Lipo=&quot;lipo -create&quot; for ARCH in $ARCHS; do Create_Lipo=&quot;$Create_Lipo $FDK_AAC/lib/libfdk-aac-$ARCH.a&quot; done Create_Lipo=&quot;$Create_Lipo -output $FAT/lib/libfdk-aac.a&quot; echo $Create_Lipo $($Create_Lipo) fi if [ &quot;$OpenSSL&quot; ]; then Create_Lipo=&quot;lipo -create&quot; for ARCH in $ARCHS; do Create_Lipo=&quot;$Create_Lipo $OpenSSL/lib/libcrypto-$ARCH.a&quot; done Create_Lipo=&quot;$Create_Lipo -output $FAT/lib/libcrypto.a&quot; echo $Create_Lipo $($Create_Lipo) Create_Lipo=&quot;lipo -create&quot; for ARCH in $ARCHS; do Create_Lipo=&quot;$Create_Lipo $OpenSSL/lib/libssl-$ARCH.a&quot; done Create_Lipo=&quot;$Create_Lipo -output $FAT/lib/libssl.a&quot; echo $Create_Lipo $($Create_Lipo) fi if [ &quot;$LAME&quot; ]; then Create_Lipo=&quot;lipo -create&quot; for ARCH in $ARCHS; do Create_Lipo=&quot;$Create_Lipo $LAME/lib/libmp3lame-$ARCH.a&quot; done Create_Lipo=&quot;$Create_Lipo -output $FAT/lib/libmp3lame.a&quot; echo $Create_Lipo $($Create_Lipo) fi cd $CWD cp -rf $THIN/$1/include $FATfiecho &quot;+++++++++++++++++++++++++++++++++++++++++++++++++++++&quot;echo &quot;+ Congratulations ! ! ! +&quot;echo &quot;+ Build FFMpeg-iOS Success ! ! ! +&quot;echo &quot;+++++++++++++++++++++++++++++++++++++++++++++++++++++&quot;","link":"/2021/12/11/macos-bian-yi-ffmpeg-for-ios/"},{"title":"macOS--编译FFMpeg For Android","text":"FFmpeg Android build script测试环境: FFmpeg 4.3.3 NDK-R21C MacOS 11.6.1 (20G221) 使用方法配置脚本 1234567891011# 编译平台# &quot;aarch64 arm&quot;ARCH=&quot;&quot;# 目标Android版本API=&quot;24&quot;# 支持的CPU架构CPU=&quot;armv8-a&quot;# so库输出目录OUTPUT=&quot;../FFMpeg-$CPU-Android&quot;# NDK的路径NDK=&quot;&quot; 进入到当前目录直接执行脚本即可，如遇无法执行，可能是文件权限问题 12345678# 进入目录cd android-ffmpeg-build-script-ilonggecd ffmpeg-4.3.3# 赋予脚本可执行权限chmod +x buidl-ffmpeg-android.sh# 执行脚本./buidl-ffmpeg-android.sh Thanks本脚本是摘抄自 Mac环境下编译ffmpeg生成so库文件-CSDN 学习后加以改造 感谢原作者！！！ Gitee仓库Github仓库 脚本内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#!/bin/bash# FFmpeg版本FFMPEG_VERSION=&quot;4.3.3&quot;if [ ! -n &quot;$FFMPEG_VERSION&quot; ]; then $FFMPEG_VERSION=&quot;4.3.3&quot;fi# 编译平台# &quot;aarch64 arm&quot;ARCH=&quot;&quot;# 目标Android版本API=&quot;24&quot;# 支持的CPU架构CPU=&quot;armv8-a&quot;# so库输出目录OUTPUT=&quot;FFMpeg-$CPU-Android&quot;# NDK的路径NDK=&quot;/Users/ilongge/MineCode/android-ndk-r22b&quot;if [ ! -n &quot;$NDK&quot; ]; then echo &quot;请配置NDK路径！！！&quot; exit 1fi# 编译工具链路径TOOLCHAIN=&quot;$NDK/toolchains/llvm/prebuilt/darwin-x86_64&quot;# 编译环境SYSROOT=&quot;$TOOLCHAIN/sysroot&quot;# 编译参数CONFIGURE_FLAGS=&quot;&quot;CONFIGURE_FLAGS=&quot;$CONFIGURE_FLAGS --enable-cross-compile&quot;CONFIGURE_FLAGS=&quot;$CONFIGURE_FLAGS --disable-debug&quot;CONFIGURE_FLAGS=&quot;$CONFIGURE_FLAGS --disable-programs&quot;CONFIGURE_FLAGS=&quot;$CONFIGURE_FLAGS --disable-doc&quot;CONFIGURE_FLAGS=&quot;$CONFIGURE_FLAGS --disable-ffplay&quot;CONFIGURE_FLAGS=&quot;$CONFIGURE_FLAGS --disable-ffprobe&quot;CONFIGURE_FLAGS=&quot;$CONFIGURE_FLAGS --disable-symver&quot;CONFIGURE_FLAGS=&quot;$CONFIGURE_FLAGS --disable-ffmpeg&quot;CONFIGURE_FLAGS=&quot;$CONFIGURE_FLAGS --disable-avdevice&quot;# 动态库CONFIGURE_FLAGS=&quot;$CONFIGURE_FLAGS --enable-shared&quot;# 静态库CONFIGURE_FLAGS=&quot;$CONFIGURE_FLAGS --disable-static&quot;CONFIGURE_FLAGS=&quot;$CONFIGURE_FLAGS --enable-pic&quot;CONFIGURE_FLAGS=&quot;$CONFIGURE_FLAGS --enable-neon&quot;CROSS_PREFIX_CLANG=&quot;$TOOLCHAIN/bin&quot;EXTRA_CFFLAGS=&quot;-fPIC&quot;CROSS_PREFIX=&quot;&quot;if [ $CPU = &quot;armv8-a&quot; ]; then ARCH=&quot;aarch64&quot; CONFIGURE_FLAGS=&quot;$CONFIGURE_FLAGS --enable-x86asm&quot; CROSS_PREFIX=&quot;$CROSS_PREFIX_CLANG/$ARCH-linux-android-&quot; CROSS_PREFIX_CLANG=&quot;$CROSS_PREFIX_CLANG/$ARCH-linux-android$API-&quot;elif [ $CPU = &quot;armv7-a&quot; ]; then ARCH=&quot;arm&quot; CROSS_PREFIX=&quot;$CROSS_PREFIX_CLANG/arm-linux-androideabi-&quot; CROSS_PREFIX_CLANG=&quot;$CROSS_PREFIX_CLANG/armv7a-linux-androideabi$API-&quot; CONFIGURE_FLAGS=&quot;$CONFIGURE_FLAGS --enable-asm&quot;fiecho &quot;./configure&quot;echo &quot; --prefix=$OUTPUT&quot;echo &quot; --target-os=android&quot;echo &quot; --arch=$ARCH&quot;echo &quot; --cpu=$CPU&quot;for FLAG in $CONFIGURE_FLAGS; do echo &quot; &quot;$FLAGdoneecho &quot; --sysroot=$SYSROOT&quot;echo &quot; --cross-prefix=$CROSS_PREFIX&quot;&quot;clang&quot;echo &quot; --cross-prefix-clang=$CROSS_PREFIX_CLANG&quot;&quot;clang&quot;echo &quot; --extra-cflags=$EXTRA_CFFLAGS&quot;./configure \\ --prefix=$OUTPUT \\ --target-os=android \\ --arch=$ARCH \\ --cpu=$CPU \\ $CONFIGURE_FLAGS \\ --sysroot=$SYSROOT \\ --cross-prefix=$CROSS_PREFIX \\ --cross-prefix-clang=$CROSS_PREFIX_CLANG \\ --extra-cflags=$EXTRA_CFFLAGS || exit 1#获取机器CPU核心数 尽可能加快编译THREAD_COUNT=$(sysctl -n machdep.cpu.thread_count)echo &quot;make -j $THREAD_COUNT install&quot;make -j$THREAD_COUNT install || exit 1echo &quot;+++++++++++++++++++++++++++++++++++++++++++++++++++++&quot;echo &quot;+ Congratulations ! ! ! +&quot;echo &quot;+ Build FFMpeg-Android Success ! ! ! +&quot;echo &quot;+++++++++++++++++++++++++++++++++++++++++++++++++++++&quot;echo &quot;make clean&quot;make clean","link":"/2021/12/11/macos-bian-yi-ffmpeg-for-android/"},{"title":"MGTV提取Ticket-保姆级教程","text":"以雷电模拟器为例 1、安装 芒果TV 5.1.3版本，我不知道其他的版本行不行，反正这个是可以的。 2、登录会员账号。 3、打开文件管理器 4、左上角菜单 点击选择根目录。然后依次进入下图所示的文件夹。 /data/data/com.hunantv.imgo.activity/shared_prefs 5、打开MGTVCommon.xml 查找ticket 大概在第44行 &lt;string name=&quot;ticket&quot;&gt;4A5D7EDF112A3D908B2C4C54********&lt;/string&gt; 4A5D7EDF112A3D908B2C4C54********即是ticket","link":"/2022/02/25/mgtv-ti-qu-ticket-bao-mu-ji-jiao-cheng/"},{"title":"iOS-如何创建pod库","text":"废话没有，直接开干，因Github国内连接性不好，所以以下内容全部基于Gitee。 第一步 创建一个Git库这个库的功能和cocoapods的Specs库功能一样，单纯的存放私有化pod库的podSpec文件，也就是我们代码库的索引文件。 库的名字随意但是最好带个Specs的后缀，能一眼看出来是干啥的。 例如我新建一个ilonggePublicSpec 创建成功之后 此时这个Specs库是空的。 这个时候最好点击【初始化readme文件】，省的后面蜜汁问题。 第二步 添加Specs库到本地pod打开终端 输入 1pod repo add ilonggePublicSpecs https://gitee.com/ilongge/ilongge-public-specs.git 解释一下这个命令 12345pod repo add 是添加一个podspec库ilonggePublicSpecs 给将要添加的库名一个本地的名字 https://gitee.com/ilongge/ilongge-public-specs.git 库的url 第三步 在本地创建自己的pod库打开终端 进入到自己想保存项目的目录下 假如我要新建一个TestManager库 1pod lib create TestManager 输入之后 下面会输出以下信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364Cloning `https://github.com/CocoaPods/pod-template.git` into `TestManager`.Configuring TestManager template.security: SecKeychainSearchCopyNext: The specified item could not be found in the keychain.------------------------------To get you started we need to ask a few questions, this should only take a minute.If this is your first time we recommend running through with the guide: - https://guides.cocoapods.org/making/using-pod-lib-create.html ( hold cmd and double click links to open in a browser. )What platform do you want to use?? [ iOS / macOS ] &gt; ios ### 这个库的平台是啥What language do you want to use?? [ Swift / ObjC ] &gt; Objc ### 啥语言Would you like to include a demo application with your library? [ Yes / No ] &gt; yes ### 包含一个demo程序 当然得要Which testing frameworks will you use? [ Specta / Kiwi / None ] &gt; None ### 测试框架 无所谓Would you like to do view based testing? [ Yes / No ] &gt; yes ### 测试的 没管过What is your class prefix? &gt; XL ### 前缀是啥 security: SecKeychainSearchCopyNext: The specified item could not be found in the keychain.security: SecKeychainSearchCopyNext: The specified item could not be found in the keychain.security: SecKeychainSearchCopyNext: The specified item could not be found in the keychain.security: SecKeychainSearchCopyNext: The specified item could not be found in the keychain.security: SecKeychainSearchCopyNext: The specified item could not be found in the keychain.security: SecKeychainSearchCopyNext: The specified item could not be found in the keychain.hint: Using 'master' as the name for the initial branch. This default branch namehint: is subject to change. To configure the initial branch name to use in allhint: of your new repositories, which will suppress this warning, call:hint: hint: git config --global init.defaultBranch &lt;name&gt;hint: hint: Names commonly chosen instead of 'master' are 'main', 'trunk' andhint: 'development'. The just-created branch can be renamed via this command:hint: hint: git branch -m &lt;name&gt;Running pod install on your new library.Analyzing dependenciesDownloading dependenciesInstalling FBSnapshotTestCase (2.1.4)Installing TestManager (0.1.0)Generating Pods projectIntegrating client project[!] Please close any current Xcode sessions and use `TestManager.xcworkspace` for this project from now on.Pod installation complete! There are 2 dependencies from the Podfile and 2 total pods installed.[!] Your project does not explicitly specify the CocoaPods master specs repo. Since CDN is now used as the default, you may safely remove it from your repos directory via `pod repo remove master`. To suppress this warning please add `warn_for_unused_master_specs_repo =&gt; false` to your Podfile. Ace! you're ready to go! We will start you off by opening your project in Xcode open 'TestManager/Example/TestManager.xcworkspace'To learn more about the template see `https://github.com/CocoaPods/pod-template.git`.To learn more about creating a new pod, see `https://guides.cocoapods.org/making/making-a-cocoapod`. 此时 Xcode会被自动打开，打开的是 TestManager/Example/TestManager.xcworkspace ，这时候我们先不要去动Xcode了。 第四步 创建远程git仓库我们再次 进入Gitee站点，新建一个空仓库：TestManager，一定要是空的，不要初始化，直接点创建即可，这个库是用来存放我们的pod库项目，后面我们会直接提交代码进来。 第五步 配置podSpec文件根据上一步的结果，我们得到一个git网址：https://gitee.com/ilongge/test-manager.git 打开Xcode的TestManager下的Podspec Metadata目录，我们可以看到TestManager.podspec文件 我们需要修改一下里面的地址配置： 123456s.homepage = 'https://github.com/ilongge/TestManager'# s.screenshots = 'www.example.com/screenshots_1', 'www.example.com/screenshots_2's.license = { :type =&gt; 'MIT', :file =&gt; 'LICENSE' }s.author = { 'ilongge' =&gt; '1015820857@qq.com' }s.source = { :git =&gt; 'https://github.com/ilongge/TestManager.git', :tag =&gt; s.version.to_s }# s.social_media_url = 'https://twitter.com/&lt;TWITTER_USERNAME&gt;' 修改成 12345678# 项目主页s.homepage = 'https://gitee.com/ilongge/test-manager' # s.screenshots = 'www.example.com/screenshots_1', 'www.example.com/screenshots_2's.license = { :type =&gt; 'MIT', :file =&gt; 'LICENSE' }s.author = { 'ilongge' =&gt; '1015820857@qq.com' }# 项目的代码地址，实际项目中引用的源码地址s.source = { :git =&gt; 'https://gitee.com/ilongge/test-manager.git', :tag =&gt; s.version.to_s } # s.social_media_url = 'https://twitter.com/&lt;TWITTER_USERNAME&gt;' 另外新增，移除M1 CPU的模拟器arm64架构，因为真机也是Arm64，所以打包的时候会因为有两个而报错。 1234567s.pod_target_xcconfig = { 'EXCLUDED_ARCHS[sdk=iphonesimulator*]' =&gt; 'arm64',}s.user_target_xcconfig = { 'EXCLUDED_ARCHS[sdk=iphonesimulator*]' =&gt; 'arm64',} 剩下的配置需要依据各个项目的实际情况，具体可以去详细了解podspec文件的详细说明。 初步配置完成之后，进入Example文件夹下 执行 pod install，任何对于podspec文件的改动和资源的增删改，都需要执行。 第六步 添加项目实际代码","link":"/2022/06/18/ios-si-you-hua-pod-ku/"}],"tags":[{"name":"转载","slug":"转载","link":"/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"原创","slug":"原创","link":"/tags/%E5%8E%9F%E5%88%9B/"}],"categories":[{"name":"iOS","slug":"iOS","link":"/categories/iOS/"},{"name":"Windows","slug":"Windows","link":"/categories/Windows/"},{"name":"macOS","slug":"macOS","link":"/categories/macOS/"}]}