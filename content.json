{"pages":[{"title":"404","text":"","link":"/404/index.html"},{"title":"about","text":"","link":"/about/index.html"},{"title":"friends","text":"","link":"/friends/index.html"},{"title":"contact","text":"","link":"/contact/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"CentOS7.2配置LNMP环境记录","text":"CentOS7.2配置LNMP环境记录1php 7.0+ nginx 1.10+ mysql 5.5+ LNMP是Linux、Nginx、MySQL(MariaDB)和PHP的缩写，这个组合是最常见的WEB服务器的运行环境之一。本文将带领大家在CentOS 7操作系统上搭建一套LNMP环境。 本教程适用于CentOS 7.x版本。 准备工作更新 yum 源,自带的源没有 PHP7:1rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm 1rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm 安装 epel:1yum install epel-release 升级系统1yum update 准备工作完成,开始安装! 安装NginxCentOS系统模板中配置了内网源，下载速度较快，推荐使用yum安装Nginx： 1sudo yum install nginx 按照提示，输入yes后开始安装。安装完毕后，Nginx的配置文件在/etc/nginx目录下。使用以下命令启动Nginx： 1sudo systemctl start nginx 检查系统中firewalld防火墙服务是否开启，如果已开启，我们需要修改防火墙配置，开启Nginx外网端口访问。 1sudo systemctl status firewalld 如果显示**active (running)**，则需要调整防火墙规则的配置。 修改/etc/firewalld/zones/public.xml文件，在zone一节中增加： 1234&lt;zone&gt; ... &lt;service name=&quot;nginx&quot;/&gt;&lt;zone&gt; 保存后重新加载firewalld服务： 1sudo systemctl restart firewalld 您可以通过浏览器访问 http://外网IP地址 来确定Nginx是否已经启动。 【注意：很重要！！！】部分童鞋发现按照教程操作最后无法访问，这是云服务器默认关闭了80端口。这个请移步云服务里控制台打开80端口的外网访问，如需步骤，请自行百度！ 最后将Nginx设置为开机启动： 1sudo systemctl enable nginx.service 这么Nginx就安装成功了！ 安装MySQL(MariaDB)MariaDB是MySQL的一个分支，主要由开源社区进行维护和升级，而MySQL被Oracle收购以后，发展较慢。在CentOS 7的软件仓库中，将MySQL更替为了MariaDB。 我们可以使用yum直接安装MariaDB： 1sudo yum install mariadb-server 安装完成之后，执行以下命令重启MariaDB服务： 1sudo systemctl restart mariadb MariaDB默认root密码为空，我们需要设置一下，执行脚本： 1sudo /usr/bin/mysql_secure_installation 这个脚本会经过一些列的交互问答来进行MariaDB的安全设置。 首先提示输入当前的root密码： Enter current password for root (enter for none): 初始root密码为空，我们直接敲回车进行下一步。* Set root password? [Y/n] 设置root密码，默认选项为Yes，我们直接回车，提示输入密码，在这里设置您的MariaDB的root账户密码。* Remove anonymous users? [Y/n] 是否移除匿名用户，默认选项为Yes，建议按默认设置，回车继续。 Disallow root login remotely? [Y/n] 是否禁止root用户远程登录？如果您只在本机内访问MariaDB，建议按默认设置，回车继续。 如果您还有其他云主机需要使用root账号访问该数据库，则需要选择n。* Remove test database and access to it? [Y/n] 是否删除测试用的数据库和权限？建议按照默认设置，回车继续。 Reload privilege tables now? [Y/n] 是否重新加载权限表？因为我们上面更新了root的密码，这里需要重新加载，回车。* 完成后你会看到Success!的提示，MariaDB的安全设置已经完成。我们可以使用以下命令登录MariaDB： 1mysql -uroot -p 按提示输入root密码，就会进入MariaDB的交互界面，说明已经安装成功。 最后我们将MariaDB设置为开机启动。 1sudo systemctl enable mariadb php70w 安装PHP我们可以直接使用yum安装PHP： 123sudo yum install php70w-fpm php70w-mysql php70w-mysqli php70w php70w-opcache php70w-gd php70w-intl php70w-mbstring php70w-exif php70w-mcrypt php70w-openssl//把该安装的一次性装到位 安装完成后我们将php-fpm启动： 1sudo systemctl start php-fpm 将php-fpm设置为开机启动： 1sudo systemctl enable php-fpm 接下来需要注意了！配置Nginx–多个站点我给大家提供一个范本作为参考： 12nginx.conf//里面我会详细的给予中文注释 12vi /etc/nginx/nginx.conf//编辑nginx.conf的命令 以下为conf文件内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104# For more information on configuration, see:# * Official English Documentation: http://nginx.org/en/docs/# * Official Russian Documentation: http://nginx.org/ru/docs/user nginx;worker_processes auto;error_log /var/log/nginx/error.log; #错误日志记录的位置pid /run/nginx.pid; #nginx.pid为记录nginx主进程pid文件；切勿修改、移动# Load dynamic modules. See /usr/share/nginx/README.dynamic.include /usr/share/nginx/modules/*.conf;#引入/usr/share/nginx/modules/ 目录下的所有以.conf结尾的文件events { worker_connections 1024;}http { log_format main '$remote_addr - $remote_user [$time_local] &quot;$request&quot; ' '$status $body_bytes_sent &quot;$http_referer&quot; ' '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;'; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; # Load modular configuration files from the /etc/nginx/conf.d directory. # See http://nginx.org/en/docs/ngx_core_module.html#include # for more information. include /etc/nginx/conf.d/*.conf; #这句很重要，引入所有etc/nginx/conf.d/目录下的.conf文件 #***etc/nginx/conf.d/目录存放的就是分站点的文件（下面会给出实例代码）*** server { #由于我们的nginx需要配置多站点，所以在此就需要注释一些东西 listen 80 default_server; listen [::]:80 default_server; #保留监听的端口 # server_name _; # root /usr/share/nginx/php; # Load configuration files for the default server block. # include /etc/nginx/default.d/*.conf; # location / { # } # error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } # location ~ \\.php$ { # root /usr/share/php; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; # include fastcgi_params; # } }# Settings for a TLS enabled server.## server {# listen 443 ssl http2 default_server;# listen [::]:443 ssl http2 default_server;# server_name _;# root /usr/share/nginx/html;## ssl_certificate &quot;/etc/pki/nginx/server.crt&quot;;# ssl_certificate_key &quot;/etc/pki/nginx/private/server.key&quot;;# ssl_session_cache shared:SSL:1m;# ssl_session_timeout 10m;# ssl_ciphers HIGH:!aNULL:!MD5;# ssl_prefer_server_ciphers on;## # Load configuration files for the default server block.# include /etc/nginx/default.d/*.conf;## location / {# }## error_page 404 /404.html;# location = /40x.html {# }## error_page 500 502 503 504 /50x.html;# location = /50x.html {# }# }}#注意：此份nginx.conf可以直接复制了去使用！~好用了就给博主打个赏钱！谢谢！ 配置完nginx之后我们该干啥、？当然是重启nginx呗 1sudo systemctl restart nginx #重启nginx 重启完毕，继续打开 http://外网IP地址 来确定Nginx是否已经启动。 此时，服务器启动的是nginx和apache。 而且php-fpm默认发送到apache。 所以咱们还得继续修改一下php-fpm。 配置 php-fpm123vi /etc/php-fpm.d/www.conf #编辑php-fpm配置文件 修改user和group （源代码为：user = apache group = apache） 12user = nginx group = nginx 修改完了之后，还是老样子，重启php-fpm服务 12systemctl restart php-fpm #重启php-fpm 最后，咱们需要为nginx添加站点了添加站点这我先给大家一个截图，以帮助大家迅速的了解是怎么回事 大家应该看的很清楚了，猜都可以猜到，博主这一共配置了三个站点，这三个站点是怎么被nginx引入的呢？ 1我给大家贴出nginx的配置文件的里面应该有这么一句(注意图中的红框，上面的是地址) 123include /etc/nginx/conf.d/*.conf;#这句很重要，引入所有etc/nginx/conf.d/目录下的.conf文件#***etc/nginx/conf.d/目录存放的就是分站点的文件（下面会给出实例代码）*** 好的，大家应该能准确理解了，如果还是理解不了的话只能缺你回去喝点三鹿了！ 下面我给大家贴出nginx站点配置文件的代码，修改修改就可以用看代码的时候请注意看里面的路径，当然我也还是会给一定的中文注释 123456789101112131415161718#这个文件是上面的qopmall.com.confserver { server_name qopmall.com www.qopmall.com;#这里就是你要绑定的域名了，空格分开 location / { root /usr/share/php/weixin; #这里是你站点存放的文件夹名称（也就是说，你当前这个站点的文件全部都丢在这个路径的weixin文件夹里面） index index.php index.html index.htm; #这里照抄即可 } # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # location ~ \\.php$ { root /usr/share/php/weixin; #这里的配置等同于上面的那个root配置 fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /usr/share/php/weixin/$fastcgi_script_name; #这里的配置也是和上面的root配置一样 include fastcgi_params; }} 代码非常简单，我没注释到的不用修改就行。 上面的路径，比如/usr/share/php/weixin 这就是你站点的根目录，我给大家截图参考： 各位童鞋，创建好站点了，先写个简单的php程序测试一下是否正常，比如info。 完","link":"/2017/12/31/centos7-pei-zhi-lnmp-huan-jing-ji-lu/"},{"title":"Centos7配置yum源","text":"Centos7配置yum源我们安装完成CentOS系统，默认都是系统自带的yum源，因为你懂得原因会导致国内用户用yum安装软件的时候比较慢，为了提高效率，一般我们会配置国内的yum源。 目前国内比较好的yum源有网易yum源、搜狐yum源等，现在介绍下怎么配置网易163yum源： 1、首先备份/etc/yum.repos.d/CentOS-Base.repo(不一定是这个名称 你可以看一下 具体叫啥) 1mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 2、根据CentOS不同版本选择下载对应的repo文件，放到/etc/yum.repos.d/ 目录首先进入yum.repos.d目录12cd /etc/yum.repos.d/ CentOS 5.x12wget http://mirrors.163.com/.help/CentOS5-Base-163.repo CentOS 6.x12wget http://mirrors.163.com/.help/CentOS6-Base-163.repo CentOS 7.x12wget http://mirrors.163.com/.help/CentOS7-Base-163.repo 3、最后，执行yum makecache生成缓存清除缓存1yum clean all 生成新缓存1yum makecache OK, 简单3步操作即可配置完成。","link":"/2018/01/12/centos7-pei-zhi-yum-yuan/"},{"title":"台式组装机简单故障的排查与清除","text":"台式组装机简单故障的排查与清除本文主要讲述台式机部分简单故障的排查与清除。 故障一：不能正常开机此故障在电脑使用中最为常见，原因也是五花八门，下面我给大家梳理一些常见的故障以及清除方法： 电脑开机，反复重启这种问题十有八九就是**内存**的问题，下图就是内存：目前主流内存有DDR3和DDR4 如果有空闲的内存插槽，请尝试调整内存安装位置；如不能解决下一条。 如果无法调整位置，请尝试使用橡皮擦蘸酒精擦拭内存金手指位置；如不能解决下一条。 如果无法调整位置，请尝试交换内存安装位置；如不能解决下一条。 如果无法调整位置，请尝试选择拆卸内存，然后每装一根开机一次看看问题是否得到解决，如果确定问题内存建议联系卖家；如不能解决下一条。 实在无法解决请更换内存； 此问题目前我多见于威刚内存 电脑开机主机启动正常，但显示器无反应 这种问题可能是内存的问题，也可能是**显卡问题，下图就是显卡：目前主流显卡很多，AMD的 RX 400、RX 500系列，Nvidia**的 GTX 9 、GTX 10系列； 如果是NVIDIA的10系显卡，请不要使用不带芯片的VGA转接头，尽量使用HDMI线连接显示器； 按照上个故障来排查；如不能解决下一条。 使用核显，将独立显卡从主板中拆除，将原先插在独立显卡上的视频线接到主板上，如果无相应插头建议自行寻找转换接口，如能正常开机则问题出在显卡上，建议联系卖家； 电脑开机自动进入**BIOS**这种问题基本就是电脑的启动项设置不对造成的。 进入电脑主板BIOS，进入启动设置：（没错的话叫 BOOT），选择自己系统所在的硬盘作为首选启动项，保存并退出。如不能解决下一条。 如出系统盘外还有其他硬盘请拆除后开机，看看是否正常。 电脑开机显示下面几张图：CPU Fan Error请尝试检查CPU散热风扇的接线柱，是否正确安装到了CPU_FAN位置，CPU_OPT安装的应该是副风扇（一体水冷的时候基本是水泵） Please enter Setup to recover BIOS setting这个问题基本出现在上了年纪的电脑上，也就是是两年以上的电脑，原因就是主板电池没电了，造成了主板的设置不能正常保存，去附近的电脑店里面一个就OK了，5块钱吧。 故障二：无法上网网络标志显示红叉或者根本没有网络标志这种问题基本就是**网卡**没有启动导致的可能的原因就是驱动没装好 去下载主板网卡在当前系统版本下的驱动，系统版本有32位（X86）和64位（X64）之分，请看清楚 能用部分聊天软件，就是不能打开网页基本**DNS的问题没的跑了,需要修改IP地址** 修改本机当前ip配置。如何修改这个就要看系统版本了，不一样的版本入口不一样 对于win7可以点击小电脑图标-&gt;打开网络与共享设置-&gt;然后左侧边栏更改适配器设置-&gt;找到目前在用的链接(本地连接或者是无线网络)-&gt;右键属性-&gt;选择ipV4-&gt;属性-&gt;勾选手动设置 其他的例如win8 win8.1，win10 基本都一样，如果找不到那么就去搜索控制面板，然后进入网络与Internet 进入网络与共享中心 进入网络适配器页面 进入连接属性 进入ipv4协议属性 手动填写IP地址 这里面的东西如何填写需要根据你的路由器来决定的，基本上家里的设置都是192.168.1.* (* 号填写100-254) 子网掩码 基本都是255.255.255.0 网关也是根据路由器来 192.168.1.1 DNS 第一行也可以根据路由器来：192.168.1.1 或者 指定固定的DNS，比如114.114.114.114 第二行随意 保存 如果上述方法不能解决建议重置网络服务 重置网络服务* 进入命令行工具（管理员模式）* 输入 netsh winsock reset 然后回车* 完成之后重启","link":"/2018/01/10/computer-normal-problem-check-and-fix/"},{"title":"Computer--U盘引导盘制作工具集合","text":"写作目的为了向电脑小白科普目前，使用人数较多的PE引导盘的制作工具软件，这玩意的用处真的是很大很大了。 千万不要说PE只能重装系统。 新硬盘无操作系统无分区，需要PE。 系统忘记登录密码不想重装，需要PE。 系统崩溃还有资料在桌面或者C盘，需要PE。 全盘数据恢复，需要PE。 重建主引导记录（MBR），重建分区表（修复分区表）、修复Windows系统引导，需要PE。 这么有用的东西到底有多少呢，我也不是很清楚，看看下面就知道了。（排名不分先后，想到哪个写哪个） 电脑店这个是我第一次用的制作工具，不知道怎么就给找到了。使用电脑店制作U盘PE系统比较的简单，基本上一键即可轻松制作，支持多种启动模式选择，支持个性化设置，别小看这个个性化设置，里边还隐藏着一些奥妙，为了测试的需要，我们采用默认设置进行PE系统的制作。 电脑店U盘启动盘制作工具，也是常称为的U盘启动制作工具的功能升格版，能更方便电脑技术人员装机、维护电脑使用的超强工具。此作品制作简单，支持所有U盘一键制作成启动盘；兼容多种机型；支持GHO、ISO系统文件，更支持原版系统安装，集成更全面工具，完全可以应对电脑技术人员常见的电脑故障维护工作。 主页：电脑店 - - &gt; http://u.diannaodian.com/ U深度这个是我比较喜欢里面的傲梅分区助手 主页：U深度 - - &gt; http://www.ushendu.info/ 大白菜基本和电脑店差不多，大白菜制作U盘PE系统同样简单，还是一键即可搞定，也支持多种启动模式选择，支持个性化设置，个性化设置里同样隐藏着一些东西，可以自己去研究。 老牌经典PE之一，同时集成服务器版的server 2003和win8PE，支持BIOS/UEFI双启，对古董机器兼容非常好。内置工具比微PE多。集成一键装机，硬盘数据恢复，密码破解，等等实用的程序。 但是个人觉得部分工具重复，工具版本偏老旧、且略为臃肿。另！大白菜PE制作时要事先取消360赞助，否则安装系统后将装上360，不介意用户请忽略。 我觉得大白菜亮点是支持读写苹果分区格式（注意是读写，不是读取！），非常适合黑苹果用户。我也是个黑苹果用户。 主页：大白菜 - - &gt; http://www.dabaicaipe.cn/dbcpe/ 老毛桃基本和电脑店差不多 主页：老毛桃 - - &gt; http://www.laomaotao.org/","link":"/2018/04/05/computer-pe-boot-usb-disk-tools-set/"},{"title":"多站点配置SSH-Key","text":"多站点配置SSH-Key相信很多用mac在开发的同学都会遇见一个问题：会根据业务不同往不同的git服务器上提交代码。这些库有私有的有公有的，这时候就需要配置SSH_Key了。 生成SSH-Key打开终端 （terminal） gitee(码云) · 秘钥对使用以下命令生成gitee的秘钥对【注意】emailaddress 填写自己的邮件地址 1ssh-keygen -t rsa -C &quot;emailaddress&quot; -f ~/.ssh/gitee_id_rsa github · 秘钥对使用以下命令生成github的秘钥对【注意】emailaddress 填写自己的邮件地址 1ssh-keygen -t rsa -C &quot;emailaddress&quot; -f ~/.ssh/github_id_rsa 添加私钥这个步骤是把私钥添加到当前设备，本地的不需要网络 添加 gitee 私钥 1ssh-add ~/.ssh/gitee_id_rsa 添加 github 私钥 1ssh-add ~/.ssh/github_id_rsa 添加公钥 和私钥不一样的是公钥是添加到git服务器的，所以这操作主要是在网页上进行的 添加 gitee 公钥显示出gitee的公钥 1cat ~/.ssh/gitee_id_rsa.pub 将展示出的以ssh-rsa开头，然后以刚才你输入的emailaddress结尾的内容全部复制 添加至gitee的SSHKey公钥 添加 github 公钥显示出github的公钥 1cat ~/.ssh/github_id_rsa.pub 将展示出的以ssh-rsa开头，然后以刚才你输入的emailaddress结尾的内容全部复制 添加至github的SSHKey公钥 创建Config在 ~/.ssh/目录下创建一个配置文件，来为秘钥使用做配置 1cd ~/.ssh/ 使用vim命令进行config文件的创建和编辑 1vim config 然后文件写入以下内容 添加以下内容1234567891011# giteeHost gitee.com HostName gitee.com PreferredAuthentications publickey IdentityFile ~/.ssh/gitee_id_rsa# githubHost github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/github_id_rsa 然后配对秘钥主要测试当前秘钥是否可用 配对gitee秘钥1ssh -T git@gitee.com gitee的测试会让输入 yes 连接gitee成功之后会显示以下信息 Welcome to Gitee.com, yourName! 配对github秘钥1ssh -T git@github.com 连接github成功之后会显示以下信息 Hi yourName! You’ve successfully authenticated, but GitHub does not provide shell access.","link":"/2018/03/14/multwwwconfigssh-key/"},{"title":"解除百度网盘下载限速","text":"众所周知的百度网盘为了迫使用户花钱，对用户的下载速度做出了限制。今天我就来分享一个破解限制的好办法，这个也是网上扒来的。 准备工作1、下载相关资料，也就是两个文件：http://pan.baidu.com/s/1nuPgpNN 2、安装chrome浏览器 3、安装下载的Aria2GUI 1.3.7.dmg 4、安装chrome插件BaiduExporter.zip 解压这个zip文件，然后打开chrome， 使用1、打开刚刚安装的Aria2GUI客户端 2、在chrome里面打开百度云网页,插件安装成功网页上就会多出一个“导出下载”的按钮 3、找到你要下载的文件，并且勾选文件（这里最好先把文件存入自己的网盘目录）,然后点击ARIA2 RPC下载任务就会被客户端执行 4、看一下速度 ATTENSION！！！本项目是MAC OS专用的，windows的目前不清楚安装chrome插件之后,插件原文件就不能移动位置,更不能删除,否则插件就会失效.","link":"/2017/08/09/release-baidunetdisk-downloading-speed-limit/"},{"title":"Windows--如何下载系统","text":"本文主要讲述如何下载原版系统，所谓的原版系统就是微软服务器上的系统镜像，而不是国内各大论坛的GHOST版本，个人并不推荐GHOST以及其他任何第三方封装过的系统。以下载win10 1511中文简体64位为例子 第1步 进入MSDN 网址为http://msdn.itellyou.cn/ 第2步 选择操作系统 第3步 选择你需要的系统版本 windows 10，Version 1511 中文-简体 64位 （X64） 第4步 复制ed2k链接 第5步 打开下载工具，新建一个下载任务，链接就是用刚才复制的链接 下载中最好不要暂停 下载完了之后记得验证SHA1值","link":"/2018/04/01/windows-download-windows-image/"},{"title":"Windows--如何修改IP地址","text":"Windows–如何修改IP地址本文主要讲述windows 7如何修改电脑的**IP地址**。其他的例如win8 win8.1，win10 基本都一样，如果找不到那么就去搜索控制面板，然后进入网络与Internet 进入网络与共享中心 进入网络适配器页面 进入连接属性 进入ipv4协议属性 手动填写IP地址 这里面的东西如何填写需要根据你的路由器来决定的，基本上家里的设置都是192.168.1.* (* 号填写100-254) 子网掩码 基本都是255.255.255.0 网关也是根据路由器来 192.168.1.1 DNS 第一行也可以根据路由器来：192.168.1.1 或者 指定固定的DNS，比如114.114.114.114 第二行随意 保存","link":"/2018/01/11/windows-how-to-change-ip-address/"},{"title":"Windows--验证SHA1 MD5值","text":"日常使用电脑过程中，难免会下载很多文件，比如游戏，软件等等，很多人在下载一个耗时长而又速度不稳定的文件之后，都可能遇见打开文件的时候显示文件被损坏的情况，这时候我们就需要在下载完成之后对文件就行数据完整性校验了。 举个例子，以验证系统的记事本程序的Hash值为例，程序文件的路径为C:\\Windows\\notepad.exe。如果我们想要校验它的MD5值，Win7 可运行： MD5 1certutil -hashfile C:\\Windows\\notepad.exe MD5 SHA1 1certutil -hashfile C:\\Windows\\notepad.exe SHA1 SHA256 1certutil -hashfile C:\\Windows\\notepad.exe SHA256 上面MD5 SHA1 SHA256请不要小写，除了文件路径，其他的要和上面一模一样 Win10 可运行如下命令： Get-FileHash C:\\Windows\\notepad.exe -Algorithm MD5| Format-List 如果想要校验它的SHA1值，则运行如下命令： Get-FileHash C:\\Windows\\notepad.exe -Algorithm SHA1| Format-List 如果想要校验SHA256值，则不需要带-Algorithm参数即可，命令如下： Get-FileHash C:\\Windows\\notepad.exe | Format-List 上面这个文件的路径是可以直接由鼠标拖进去的","link":"/2018/04/01/windows-how-to-verify-the-sha1-md5-value/"},{"title":"Windows--电脑U盘启动盘制作","text":"写在前面本文是博主鉴于当前任然后很大一部分电脑玩家经常为不会给爱机装系统而创作，本博主是一个精通电脑硬件性能以及软件使用的IT人士。 Windows的启动盘分为两类:(随便选择一种方法制作就OK了) 普通BIOS启动的PE类 UEFI启动的EFI类 无论是哪一类大家都不用担心，都有相对应的傻瓜式软件来帮我们完成，我们需要做的就是一下： 找一个U盘，最好是空的（因为无论是哪一种制作方式都可能会格式化这个U盘） U盘的大小最好是8GB左右的（第一种的方式大小无所谓，主要是第二种的方式会占用大量空间） 一台能联网的电脑（这个么有难度吧） 普通BIOS启动的PE类以下将简单介绍如何给Windows电脑制作一个普通BIOS启动的PE类U盘启动盘 准备工作下载U盘启动盘制作工具可以选的种类有很多个：老毛桃，U深度，大白菜，电脑店。。。。下面介绍的是电脑店。 下载地址：http://u.diannaodian.com/down 进入如图页面： 点击下载： 推荐点击本地下载： 然后就是等待下载完毕。。。。。。 在这个时候我们就可以开始对U盘做一些操作了(如果你的U盘不是空的话，如果里面没有东西，这一步可以跳过)，把U盘里面的所有东西都挪到电脑上（除了C盘的任何位置，只要你找的到就行）。 OK下载完了，开始安装：这个软件的安装很简单，就是单纯的吧这个下载的ZIP文件解压而已：我解压到了我的软件盘，盘符为D，如下图： 然后就是插上U盘，这时软件上面的U盘选择项就会出现你的U盘名称： 然后选择启动模式：（个人建议不要动保持USB-HDD模式） 然后选择U盘格式：（个人建议NTFS，因为Fat32有着文件大小的限制，单个文件的大小不得超过4GB） 都选择完了之后，那就点一下鼠标，点击全新制作：接下来就是等了。。。等。。。应该会很快完成之后：点击模拟启动，选择BIOS 至此，U盘启动盘已经制作完成。 UEFI启动的EFI类准备工作下载软碟通 百度就有： 安装： 接受协议，下一步。。。 注意改一下安装路径：（建议不要装在C盘，我的是在D盘） 一直下一步，知道结束 启动 选择继续试用： 选择上方工具栏的文件–打开：（选择你的系统镜像） 然后如图： 选择工具–写入磁盘镜像，插入U盘 点击写入：（没有合适的U盘 所以我这里是不能点的） 注意本类U盘启动盘只能以UEFI模式启动 请设置自己电脑的相关BIOS设置","link":"/2017/08/19/windows-make-pe-boot-usb-disk/"},{"title":"Windows--如何将硬盘分区表转换为GUID(GPT)分区表","text":"如何将硬盘分区表转换为GUID(GPT)分区表如果不知道自己的硬盘分区表类型可以参看 Windows–如何查看硬盘分区表类型 1、使用PE 制作U盘PE启动盘 进入PE 在PE里打开磁盘精灵 （DG） 右键磁盘 菜单中有转换为GUID分区表 2、在安装Win的时候 制作UEFI启动盘 进入UEFI安装的界面 shift + F10 （打开终端） 输入diskpart 回车 （进入diskpart） list disk (显示磁盘列表，注意这里你只能用大小来区分你的硬盘了) sel disk 0 (这个编号你自己看着你的来) clean （清除数据）（可选） convert gpt (转换为GPT分区表，好像是会清除磁盘上数据的) 同理，GPT转换至MBR上述方法同样适用","link":"/2018/02/26/windows-the-hard-disk-partition-table-type-changge-to-guid-gpt/"},{"title":"Windows--UEFI引导安装Win10","text":"Windows–UEFI引导安装Win10本文主要讲述如何使用普通U盘UEFI引导启动盘安装Windows系统 注意此方法只能安装于**GPT(GUID)**分区表的硬盘 准备工作 找一个8GB或更大的U盘 USB3.0更好 这样更快 下载官方ISO系统文件镜像（随便找一个不是C盘的目录放着就行，建议直接扔在D盘根目录） 然后新建一个文件夹叫 WindowsImage 解压这个ISO文件到 WindowsImage文件夹 首先制作UEFI启动盘 U盘格式化为Fat32文件系统（有些主板也支持NTFS，比如我的华硕Z170AR） 将解压好的 WindowsImage文件夹下面的所有文件放入U盘跟目录 注意现在的U盘打开之后应该有好几个文件夹，如下图 选择U盘启动 U盘插在需要装系统的电脑上，然后开机 笔记本：自己去百度你的这个型号如何从U盘启动 台式机：去百度你这个电脑主板的U盘启动方法 看图了正式安装系统下一步 现在安装 随便选一个版本 接受 （不然你还想怎样） 自定义 ： 分区自己看着选这一步建议大家把电脑上除了需要装系统的硬盘 其他的都拆下来 没区分的自己分区 没有引导分区会额外自动创建 点击确定 选择系统安装的盘符 基本就是第一个主分区 下一步 等 还是等 重启的时候就可以把U盘拔下来了，因为U盘的作用已经完了 重启 系统设置中国 随便选 我选拼音 随便 我选跳过 等 针对个人使用 下一步 如果不使用微软账号 就找到左下角 脱机账户 否 名字自己起 密码 填不填都可以 我不喜欢 我选否 我就这样配置 等咯 接着等 这不就OK了 完","link":"/2018/02/03/windows-uefi-boot-installation-win10/"},{"title":"Windows--如何使用PE安装官方ISO镜像","text":"Windows–如何使用PE安装官方ISO镜像本文主要讲述如何使用普通U盘启动盘安装Windows重装系统,注意此方法只能安装于MBR分区表的硬盘 准备工作 制作U盘启动盘–普通PE类 下载官方ISO系统文件镜像（随便找一个不是C盘的目录放着就行，建议直接扔在D盘根目录） 然后新建一个文件夹叫 WindowsImage 解压这个ISO文件到 WindowsImage文件夹 首先 将制作好的U盘插入电脑的usb接口，然后开机 选择U盘启动 笔记本：自己去百度你的这个型号如何从U盘启动 台式机：去百度你这个电脑主板的U盘启动方法 进入PE 出现如下图所示的界面 选择带有运行******x86 或者 *******x64 或者 windwos2003等字样的任何一个启动 进入PE 开始启动了 PE启动完成，现在可以操作了 安装windows系统 打开桌面上的windows安装器 点击install.wim文件的位置一项的选择 找到刚才解压的那个文件夹WindowsImage下的sources文件夹里面的install.wim文件（按大小排序按后最大的那个） 引导磁盘的位置—-选择C（最好自己去看看自己电脑现在在PE下的盘符，看一下你那个系统盘分区的盘符叫什么这里就选什么） 安装磁盘的位置—-选择C（最好自己去看看自己电脑现在在PE下的盘符，看一下你那个系统盘分区的盘符叫什么这里就选什么） 然后点击开始安装 如有对话框，则选择自动重新启动（对win10版本好像没用，需要手动重启）。不选保留原来的windows版本 确定 等待进度条完成 简书：http://www.jianshu.com/p/163b64432e97CSDN：http://blog.csdn.net/ZuoWeiXiaoDuZuoZuo/article/details/78958115 完","link":"/2018/01/03/windows-use-pe-installation-windwos-iso-image/"},{"title":"Windows--如何查看硬盘分区表类型","text":"如何查看硬盘分区表类型1、什么是硬盘分区表人们在使用电脑时，有时由于异常操作，有时由于病毒侵袭，会导致某个分区消失或硬盘无法启动。究其原因，就是硬盘分区表受损。硬盘分区表可以说是支持硬盘正常工作的骨架。操作系统正是通过它把硬盘划分为若干个分区，然后再在每个分区里面创建文件系统，写入数据文件。本文主要讲述的是分区表的位置，结构以及各个分区表是如何链接起来的。当掌握了这些知识后，即使分区表受到破坏，一样也可以根据残存的数据手工修复分区表，从而修复分区。 2、都有什么类型目前在用的 分区表类型主要有了两个： GUID （也叫 GPT）一种由基于 Itanium 计算机中的可扩展固件接口 (EFI) 使用的磁盘分区架构。与主启动记录(MBR) 分区方法相比，GPT 具有更多的优点，因为它允许每个磁盘有多达 128 个分区，支持高达 18 千兆兆字节的卷大小，允许将主磁盘分区表和备份磁盘分区表用于冗余，还支持唯一的磁盘和分区 ID (GUID）。与支持最大卷为 2 TB (terabytes) 并且每个磁盘最多有 4 个主分区（或 3 个主分区，1 个扩展分区和无限制的逻辑驱动器）的主启动记录(MBR)磁盘分区的样式相比，GUID分区表 (GPT) 磁盘分区样式支持最大卷为 18 EB (exabytes) 并且每磁盘最多有 128 个分区。与MBR分区的磁盘不同，至关重要的平台操作数据位于分区，而不是位于非分区或隐藏扇区。另外，GPT 分区磁盘有多余的主要及备份分区表来提高分区数据结构的完整性。 MBR传统的分区方案（称为MBR分区方案）是将分区信息保存到磁盘的第一个扇区（MBR扇区）中的64个字节中，每个分区项占用16个字节，这16个字节中存有活动状态标志、文件系统标识、起止柱面号、磁头号、扇区号、隐含扇区数目（4个字节）、分区总扇区数目（4个字节）等内容。由于MBR扇区只有64个字节用于分区表，所以只能记录4个分区的信息。这就是硬盘主分区数目不能超过4个的原因。后来为了支持更多的分区，引入了扩展分区及逻辑分区的概念。但每个分区项仍用16个字节存储。MBR分区方案不是用得好好的吗？为什么要提出新的方案呢？那就让我们看看MBR分区方案有什么问题。前面已经提到了主分区数目不能超过4个的限制，这是其一，很多时候，4个主分区并不能满足需要。另外最关键的是MBR分区方案无法支持超过2TB容量的磁盘。因为这一方案用4个字节存储分区的总扇区数，最大能表示2的32次方的扇区个数，按每扇区512字节计算，每个分区最大不能超过2TB。磁盘容量超过2TB以后，分区的起始位置也就无法表示了。在硬盘容量突飞猛进的今天，2TB的限制将很快被突破。由此可见，MBR分区方案已经无法满足需要了。 3、怎么查看自己的硬盘分区表桌面–&gt;计算机图标–&gt;右键–&gt;管理–&gt;磁盘管理–&gt;选择一个磁盘（注意是磁盘不是分区）–&gt;右键–&gt;属性–&gt;鼠标左键点击“卷”–&gt;查看“磁盘分区形式”","link":"/2018/02/24/windows-view-the-hard-disk-partition-table-type/"},{"title":"iOS--简单封装AFNetworking","text":"由于本人在工作中经常会进行网络请求，实在是不想一直写那段请求代码，就自己封装了一个LiynNet类。其中使用代理完成方法回调。 这里面涉及到了GET/POST方法。废话不多说直接上代码 下面是.h文件的内容:代理回调协议方法 1234@protocol LiynNetDelegate &lt;NSObject&gt;- (void)netFinsh:(id)object;- (void)netError:(id)errorMsg;@end 这里只有一个属性delegate，用于建立代理关系；这里向外暴露了五个方法，其中第一个类方法用来初始化一个网络请求类的实例化对象，这个对象是一个单例对象，因为网络请求对象，不存储数据，只作为一个单纯的工具类，所以这个对象只需要存在一个就可以。 12345678910@interface LiynNet : NSObject@property (nonatomic, weak) id&lt;LiynNetDelegate&gt; delegate;#pragma mark: method+ (LiynNet *)defaultNet;- (void)uploadPOST:(NSString *)URLString Parameters:(id)parameters UploadDictionary:(NSDictionary*)uploadInfo;- (void)POST:(NSString *)URLString Parameters:(id)parameters;- (void)GET:(NSString *)URLString Parameters:(id)parameters;- (void)GETPic:(NSString *)URLString Parameters:(id)parameters Path:(NSString *)path;@end 下面是.m文件的内容创建单例对象 123456789+(LiynNet *)defaultNet{ static LiynNet *net = nil; if (net == nil) { net = [[LiynNet alloc] init]; net.manager = [AFHTTPSessionManager manager]; net.manager.responseSerializer = [AFHTTPResponseSerializer serializer]; } return net;} 以下是网络请求在这里我就想了定制，因为有时候需要判断返回数据的类型，例如：当一个页面进行多种数据请求时，代理方法只有一个，那么我们就需要一个标记变量来区别这次返回的数据类型是什么。所以这里的parameters字典里需要一个字段msgType来区别。 一般POST下载请求1234567891011- (void)POST:(NSString *)URLString Parameters:(id)parameters{ NSString *msgType = parameters[@&quot;msgType&quot;]; NSLog(@&quot;{\\nmethod:POST \\nURL:%@ \\nParameters:%@&quot;,URLString,parameters); [self.manager POST:URLString parameters:parameters[@&quot;msg&quot;] progress:^(NSProgress * _Nonnull uploadProgress) { } success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { [self success:@{@&quot;msgType&quot;:msgType,@&quot;msg&quot;:responseObject}]; } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) { [self failure:@{@&quot;msgType&quot;:msgType,@&quot;error&quot;:error}]; }];} 一般的GET下载请求1234567891011- (void)GET:(NSString *)URLString Parameters:(id)parameters{ NSString *msgType = parameters[@&quot;msgType&quot;]; NSLog(@&quot;method:GET URL:%@ Parameters:%@&quot;,URLString,parameters); [self.manager GET:URLString parameters:parameters progress:^(NSProgress * _Nonnull downloadProgress) { } success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { [self success:responseObject]; } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) { [self failure:@{@&quot;msgType&quot;:msgType,@&quot;error&quot;:error}]; }];} 一般的POST上传请求注意上传的字段是服务器给定的，传入的字典uploadInfo内@”uploadParameter”对应的值。 123456789101112131415161718192021222324- (void)uploadPOST:(NSString *)URLString Parameters:(id)parameters UploadDictionary:(NSDictionary*)uploadInfo{ NSString *msgType = parameters[@&quot;msgType&quot;]; NSLog(@&quot;{\\nmethod:POST \\nURL:%@ \\nParametersCid:%@&quot;,URLString,parameters[@&quot;msg&quot;]); NSDictionary *dict = parameters[@&quot;msg&quot;]; [self.manager POST: URLString parameters:dict constructingBodyWithBlock:^(id _Nonnull formData) { NSData *rightData = UIImageJPEGRepresentation(uploadInfo[@&quot;image&quot;], 0.7); [formData appendPartWithFileData:rightData name: uploadInfo[@&quot;uploadParameter&quot;] fileName:@&quot;IDRight.png&quot; mimeType:@&quot;image/jpeg&quot;]; } progress:^(NSProgress * _Nonnull uploadProgress) { NSLog(@&quot;%f&quot;,1.0 * uploadProgress.completedUnitCount/uploadProgress.totalUnitCount); } success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { NSDictionary *dict = [NSJSONSerialization JSONObjectWithData:responseObject options:NSJSONReadingMutableContainers error:nil]; [self success:@{@&quot;msgType&quot;:msgType,@&quot;msg&quot;:dict}]; } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) { [self failure:@{@&quot;msgType&quot;:msgType,@&quot;error&quot;:error}]; }];} 两个私有方法请求数据成功12345- (void)success:(id)responseObject{ if (_delegate &amp;&amp; [_delegate respondsToSelector:@selector(netFinsh:)]) { [_delegate netFinsh:responseObject]; }} 请求数据失败12345- (void)failure:(id)error{ if (_delegate &amp;&amp; [_delegate respondsToSelector:@selector(netError:)]) { [_delegate netError:error]; }} 这个类是基于AFNetworking的，所以在使用的时候必须要先倒入AFNetworking的第三方库，建议使用CocoaPods来导入，如果有人不会使用的可以自行百度。 1pod 'AFNetworking', '~&gt; 3.1.0' 首先在使用的类里遵循协议 1&lt;LiynNetDelegate&gt; 声明一个全局的LiynNet类的对象（这个全局只是建议 不全局也可以） 123{ LiynNet *_net;} 或者定义一个属性 1@property (nonatomic, strong) LiynNet *net; 实例化这个LiynNet对象并建立代理关系 12345678#pragma mark - 懒加载-(LiynNet *)net{ if (_net == nil) { _net = [LiynNet defaultNet]; _net.delegate = self; } return _net;} 实现协议的方法在这里你就可以操作返回的数据了 123- (void)netFinsh:(id)object{ NSLog(@&quot;msgType %@\\n msg %@&quot;,object[@&quot;msgType&quot;],object[@&quot;msg&quot;]);} 这里你就需要慢慢查找原因了 1234- (void)netError:(id)errorMsg{ NSLog(@&quot;msgType %@\\n msg %@&quot;, errorMsg[@&quot;msgType&quot;], errorMsg[@&quot;msg&quot;]);}","link":"/2017/07/14/ios-custom-afnetworking/"},{"title":"iOS--自定义多选相册","text":"自定义多选相册一个项目需要类似于安卓的多选相册，而iOS自带的Piker只能单选，所以就想到了自定义，自定义的过程是辛苦的，结果出来之后是高兴的。 写在前面本代码只展示了iOS默认的相册内容，如果读者有其他想法的欢迎再本代码基础上修改。 获取系统默认的相册1234567-(PHFetchResult *)smartAlbums{ if (_smartAlbums == nil) { _smartAlbums = [PHAssetCollection fetchAssetCollectionsWithType:PHAssetCollectionTypeSmartAlbum subtype:PHAssetCollectionSubtypeSmartAlbumUserLibrary options:nil]; } return _smartAlbums;} 获取系统相册中的相片默认的照片排序是时间先后顺序，这里我也规定了按照文件创建的先后顺序来排序呢，为了避免同时引用过多的image导致内存暴增，这里使用的都是缩略图，而且只允许引用前20项。 1234567891011121314151617181920212223242526272829303132333435- (void)initPhotoData{ [self.photoArray removeAllObjects]; __weak typeof(self) weakSelf = self; for (PHCollection * obj in self.smartAlbums) { if ([obj isKindOfClass:[PHAssetCollection class]]) { PHAssetCollection *collection = (PHAssetCollection *)obj; PHFetchOptions *options = [[PHFetchOptions alloc] init]; options.sortDescriptors = @[[NSSortDescriptor sortDescriptorWithKey:@&quot;creationDate&quot; ascending:NO]]; PHFetchResult *fetchReuslt = [PHAsset fetchAssetsInAssetCollection:collection options:options]; NSLog(@&quot;count - %ld&quot;,(unsigned long)fetchReuslt.count); if (fetchReuslt.count == 0) { continue; } NSInteger count = 20&lt;fetchReuslt.count?20:fetchReuslt.count; __block NSInteger _index = 0; for (NSInteger i = 0 ;i&lt;count;i++) { PHAsset *asset = fetchReuslt[i]; //使用PHImageManager从PHAsset中请求图片 NSInteger index = _index; MyImageManager *imageManager = [MyImageManager defaultManager]; [imageManager requestImageForAsset:asset targetSize:CGSizeMake(ItemWidth()*2-2, ItemHieght()*2-2) contentMode:PHImageContentModeAspectFill options:self.requestOption Index:index resultHandler:^(UIImage *result, NSDictionary *info, NSInteger index) { NSInteger IDKey = [info[@&quot;PHImageResultRequestIDKey&quot;] integerValue]; NSLog(@&quot;%@,%ld,%ld,%ld&quot;,result,(long)IDKey,index,IDKey-index); [weakSelf.photoArray addObject:result]; }]; _index++; } }else{ NSLog(@&quot;NO&quot;); NSAssert1(NO, @&quot;Fetch Collect Not PHCollection:%@&quot;, obj); } } NSLog(@&quot;initPhotoDataDone&quot;);} 将获取到的缩略图展示到CollectionView上 这个项目在码云的git库上有，地址为https://git.oschina.net/LiynXu/PhotoDemo.git。 如果有任何意见或者建议，或者发现bug(应该是有的),请移步值git库下给予指导，3Q。","link":"/2017/08/18/ios-custom-ablum/"},{"title":"iOS--实例化对象转换为JSON数据","text":"如何将自定义类的实例化对象转换为JSON数据 我所用的方法是通过Runtime的相关方法，先后两步来实现的。具体往下看： 新建一个类命名为《UserClass》 展示.h文件UserClass.h 1234567891011121314// UserClass.h// MyPickerView// Created by LiynXu on 16/3/7.// Copyright © 2016年 LiynXu. All rights reserved.#import &lt;Foundation/Foundation.h&gt;@interface UserClass : NSObject@property (nonatomic,strong) NSString *name;@property (nonatomic,strong) NSString *password;@property (nonatomic,assign) NSInteger age;@property (nonatomic,strong) NSString *sex;- (instancetype)initWithName:(NSString *)name Password:(NSString *)password;- (NSDictionary *)convertToDictWithObject:(NSObject *)object;//主要使用这个方法得到一个字典@end 由上面的头文件可以看出我所建立的类有4个属性：name，password，age，sex。并且包含一个初始化方法，和对象转字典的方法(了解过Runtime，所以知道了Runtime可以在运行时某个对象的所有属性，以及属性的相关值) 具体实现方法 第一步将自定义类的实例化对象转为字典，这一步需要结合Runtime进行，所以我们需要做一个操作就是导入一个头文件 #import &lt;objc/runtime.h&gt;//当前需要使用使用运行时库 第二步使用第一部得到的字典转为JSON数据 1234567891011121314151617// UserClass.m// MyPickerView// Created by LiynXu on 16/3/7.// Copyright © 2016年 LiynXu. All rights reserved.#import &quot;UserClass.h&quot;#import &lt;objc/runtime.h&gt;//当前需要使用使用运行时库@implementation UserClass-(instancetype)initWithName:(NSString *)name Password:(NSString *)password{ self= [super init]; if (self) { _name = name; _password = password; } return self;} 上面的主要是一个初始化方法，重要的是下面，下面，下面！ 123456789101112131415161718- (NSDictionary *)convertToDictWithObject:(NSObject *)object{//获取当前对象的所有属性以及属性的值 NSMutableDictionary *Dict = [NSMutableDictionary dictionary]; unsigned int outCount, i; objc_property_t *properties = class_copyPropertyList([object class], &amp;outCount); //获取所有属性以及属性的值,并且转换为一个字典 for (i = 0; i&lt;outCount; i++){ objc_property_t property = properties[i]; const char* char_f =property_getName(property); NSString *propertyName = [NSString stringWithUTF8String:char_f]; id propertyValue = [self valueForKey:(NSString *)propertyName]; if (propertyValue) [Dict setObject:propertyValue forKey:propertyName]; } free(properties); return Dict;}@end 程序入口main.m 包含具体示例代码 123456789101112131415161718192021222324252627282930313233//// main.m// JsonCode//// Created by LiynXu on 16/3/7.// Copyright © 2016年 LiynXu. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;#import &quot;UserClass.h&quot;int main(int argc, const char * argv[]) { @autoreleasepool { UserClass *user = [[UserClass alloc] initWithName:@&quot;name&quot; Password:@&quot;password&quot;]; NSDictionary *codeDict = [user convertToDictWithObject:user];//对象转字典， NSLog(@&quot;%@&quot;,codeDict); NSData *jsonData = [NSJSONSerialization dataWithJSONObject:codeDict options:NSJSONWritingPrettyPrinted error:nil];//字典转json code NSLog(@&quot;%@&quot;,jsonData); NSFileManager *fileManager = [NSFileManager defaultManager]; NSString *path = [NSString stringWithFormat:@&quot;%@/Document/jsonData.json&quot;,NSHomeDirectory()]; BOOL res=[fileManager createFileAtPath:path contents:nil attributes:nil]; if (res) { NSLog(@&quot;文件创建成功: %@&quot; ,path); }else NSLog(@&quot;文件创建失败: %@&quot; ,path); NSString *jsonStrong = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding]; //json转字符串 NSLog(@&quot;%@&quot;,jsonStrong); NSDictionary *decodeDict = [NSJSONSerialization JSONObjectWithData:jsonData options:NSJSONReadingMutableContainers error:nil]; //json Decode NSLog(@&quot;%@&quot;,decodeDict); } return 0;}","link":"/2017/08/18/ios-custom-object-to-json-runtime/"},{"title":"获取iOS设备型号，目前所有iOS设备","text":"简介获取iOS设备型号，目前所有iOS设备皆可识别 下面是.h文件 声明这个返回值为NSString的类方法 1234567891011121314151617// GetDeviceModel.h// Created by LiynXu on 15/11/10.// Copyright © 2015年 LiynXu. All rights reserved.// xxl652170427@163.com#import &lt;Foundation/Foundation.h&gt;@interface GetDeviceModel : NSObject/* 获取设备描述 */+ (NSString *)getCurrentDeviceModelDescription;/* 由获取到的设备描述，来匹配设备型号 */+ (NSString *)getCurrentDeviceModel;@end 返回值为NSString的类方法 获取设备描述 12345678910111213141516+ (NSString *)getCurrentDeviceModelDescription{ int mib[2]; size_t len; char *machine; mib[0] = CTL_HW; mib[1] = HW_MACHINE; sysctl(mib, 2, NULL, &amp;len, NULL, 0); machine = malloc(len); sysctl(mib, 2, machine, &amp;len, NULL, 0); NSString *platform = [NSString stringWithCString:machine encoding:NSASCIIStringEncoding]; free(machine); return platform;} 由获取到的设备描述，来匹配设备型号 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485+ (NSString *)getCurrentDeviceModel{ NSString *platform = [GetDeviceModel getCurrentDeviceModelDescription]; if ([platform isEqualToString:@&quot;iPhone1,1&quot;]) return @&quot;iPhone 2G&quot;; if ([platform isEqualToString:@&quot;iPhone1,2&quot;]) return @&quot;iPhone 3G&quot;; if ([platform isEqualToString:@&quot;iPhone2,1&quot;]) return @&quot;iPhone 3GS&quot;; if ([platform isEqualToString:@&quot;iPhone3,1&quot;]) return @&quot;iPhone 4&quot;; if ([platform isEqualToString:@&quot;iPhone3,2&quot;]) return @&quot;iPhone 4&quot;; if ([platform isEqualToString:@&quot;iPhone3,3&quot;]) return @&quot;iPhone 4&quot;; if ([platform isEqualToString:@&quot;iPhone4,1&quot;]) return @&quot;iPhone 4S&quot;; if ([platform isEqualToString:@&quot;iPhone5,1&quot;]) return @&quot;iPhone 5&quot;; if ([platform isEqualToString:@&quot;iPhone5,2&quot;]) return @&quot;iPhone 5&quot;; if ([platform isEqualToString:@&quot;iPhone5,3&quot;]) return @&quot;iPhone 5c&quot;; if ([platform isEqualToString:@&quot;iPhone5,4&quot;]) return @&quot;iPhone 5c&quot;; if ([platform isEqualToString:@&quot;iPhone6,1&quot;]) return @&quot;iPhone 5s&quot;; if ([platform isEqualToString:@&quot;iPhone6,2&quot;]) return @&quot;iPhone 5s&quot;; if ([platform isEqualToString:@&quot;iPhone7,1&quot;]) return @&quot;iPhone 6 Plus&quot;; if ([platform isEqualToString:@&quot;iPhone7,2&quot;]) return @&quot;iPhone 6&quot;; if ([platform isEqualToString:@&quot;iPhone8,1&quot;]) return @&quot;iPhone 6S&quot;; if ([platform isEqualToString:@&quot;iPhone8,2&quot;]) return @&quot;iPhone 6S Plus&quot;; if ([platform isEqualToString:@&quot;iPhone9,1&quot;]) return @&quot;iPhone 7 A1660&quot;; if ([platform isEqualToString:@&quot;iPhone9,2&quot;]) return @&quot;iPhone 7 Plus A1661&quot;; if ([platform isEqualToString:@&quot;iPhone9,3&quot;]) return @&quot;iPhone 7 A1778&quot;; if ([platform isEqualToString:@&quot;iPhone9,4&quot;]) return @&quot;iPhone 7 Plus A1784&quot;; if ([platform isEqualToString:@&quot;iPod1,1&quot;]) return @&quot;iPod Touch 1G&quot;; if ([platform isEqualToString:@&quot;iPod2,1&quot;]) return @&quot;iPod Touch 2G&quot;; if ([platform isEqualToString:@&quot;iPod3,1&quot;]) return @&quot;iPod Touch 3G&quot;; if ([platform isEqualToString:@&quot;iPod4,1&quot;]) return @&quot;iPod Touch 4G&quot;; if ([platform isEqualToString:@&quot;iPod5,1&quot;]) return @&quot;iPod Touch 5G&quot;; if ([platform isEqualToString:@&quot;iPad1,1&quot;]) return @&quot;iPad 1G&quot;; if ([platform isEqualToString:@&quot;iPad2,1&quot;]) return @&quot;iPad 2&quot;; if ([platform isEqualToString:@&quot;iPad2,2&quot;]) return @&quot;iPad 2&quot;; if ([platform isEqualToString:@&quot;iPad2,3&quot;]) return @&quot;iPad 2&quot;; if ([platform isEqualToString:@&quot;iPad2,4&quot;]) return @&quot;iPad 2&quot;; if ([platform isEqualToString:@&quot;iPad2,5&quot;]) return @&quot;iPad Mini 1G&quot;; if ([platform isEqualToString:@&quot;iPad2,6&quot;]) return @&quot;iPad Mini 1G&quot;; if ([platform isEqualToString:@&quot;iPad2,7&quot;]) return @&quot;iPad Mini 1G&quot;; if ([platform isEqualToString:@&quot;iPad3,1&quot;]) return @&quot;iPad 3&quot;; if ([platform isEqualToString:@&quot;iPad3,2&quot;]) return @&quot;iPad 3&quot;; if ([platform isEqualToString:@&quot;iPad3,3&quot;]) return @&quot;iPad 3&quot;; if ([platform isEqualToString:@&quot;iPad3,4&quot;]) return @&quot;iPad 4&quot;; if ([platform isEqualToString:@&quot;iPad3,5&quot;]) return @&quot;iPad 4&quot;; if ([platform isEqualToString:@&quot;iPad3,6&quot;]) return @&quot;iPad 4&quot;; if ([platform isEqualToString:@&quot;iPad4,1&quot;]) return @&quot;iPad Air&quot;; if ([platform isEqualToString:@&quot;iPad4,2&quot;]) return @&quot;iPad Air&quot;; if ([platform isEqualToString:@&quot;iPad4,3&quot;]) return @&quot;iPad Air&quot;; if ([platform isEqualToString:@&quot;iPad4,4&quot;]) return @&quot;iPad Mini 2G &quot;; if ([platform isEqualToString:@&quot;iPad4,5&quot;]) return @&quot;iPad Mini 2G &quot;; if ([platform isEqualToString:@&quot;iPad4,6&quot;]) return @&quot;iPad Mini 2G &quot;; if ([platform isEqualToString:@&quot;iPad4,7&quot;]) return @&quot;iPad Mini 3 &quot;; if ([platform isEqualToString:@&quot;iPad4,8&quot;]) return @&quot;iPad Mini 3 &quot;; if ([platform isEqualToString:@&quot;iPad4,9&quot;]) return @&quot;iPad Mini 3 &quot;; if ([platform isEqualToString:@&quot;iPad5,1&quot;]) return @&quot;iPad Mini 4 WiFi &quot;; if ([platform isEqualToString:@&quot;iPad5,2&quot;]) return @&quot;iPad Mini 4 WiFi+Cellular &quot;; if ([platform isEqualToString:@&quot;iPad5,3&quot;]) return @&quot;iPad Air2 &quot;; if ([platform isEqualToString:@&quot;iPad5,4&quot;]) return @&quot;iPad Air2 &quot;; if ([platform isEqualToString:@&quot;iPad6,7&quot;]) return @&quot;iPad Pro WiFi 12.7-inch&quot;; if ([platform isEqualToString:@&quot;iPad6,8&quot;]) return @&quot;iPad Pro WiFi+Cellular 12.7-inch&quot;; if ([platform isEqualToString:@&quot;iPad6,3&quot;]) return @&quot;iPad Pro WiFi 9.7-inch&quot;; if ([platform isEqualToString:@&quot;iPad6,4&quot;]) return @&quot;iPad Pro WiFi+Cellular 9.7-inch&quot;; if ([platform isEqualToString:@&quot;i386&quot;]) return @&quot;iPhone Simulator&quot;; if ([platform isEqualToString:@&quot;x86_64&quot;]) return @&quot;iPhone Simulator&quot;; return platform;} 如何使用首先在.m文件中导入以下两个头文件 12#import &quot;GetDeviceModel.h&quot;#import &lt;sys/sysctl.h&gt; 然后在需要获取设备型号地方这样写,用一个NSString类型的对象接收 12NSString *string = [GetDeviceModel getCurrentDeviceModel];NSLog(@&quot;设备型号:%@&quot;,string); 也可以给当前app的AppDelegate添加一个DeviceModel属性,一下是AppDelegate的.h文件内容 1234567#import &lt;UIKit/UIKit.h&gt;@interface AppDelegate : UIResponder &lt;UIApplicationDelegate&gt;@property (strong, nonatomic) UIWindow *window;@property (nonatomic,copy) NSString *DeviceModel;@end 然后直接想下面这样用就行了 1self.DeviceModel = [GetDeviceModel getCurrentDeviceModel]; 完整代码演示：https://git.oschina.net/LiynXu/GetDeviceModel.git 欢迎访问！效果展示：","link":"/2017/08/18/ios-get-ios-device-model/"},{"title":"iOS HealthKit简单介绍","text":"HealthKit简单介绍目前很多App都会有访问健康数据的需求，那么我们就不得不使用HealthKit。HealthKit框架提供了一个结构，应用可以使用它来分享健康和健身数据。HealthKit管理从不同来源获得的数据，并根据用户的偏好设置，自动将不同来源的所有数据合并起来。应用还可以获取每个来源的原始数据，然后执行自己的数据合并。 如何在项目中集成HealthKit这一个部分我们将一步一步的在项目中集成HealthKit。 第一步添加HealthKit1、进入项目设置–&gt;Capabilities–&gt;HealthKit，然后如下图打开就可以了，如果下面几个选项前都打上了勾的话，那么就代表OK了，一般也不会出现X。 2、如果上面的步骤完成了的话那么在工程目录下会多一个文件，这个文件以工程名命名，后缀名为entitlements，如下图： 3、并且在Frameworks目录下会多一个HealthKit.framework文件： 项目中的使用首先要在需要访问健康数据的地方，使用import导入HealthKit头文件： 1#import &lt;HealthKit/HealthKit.h&gt; 然后写一个属性： 1@property (nonatomic, strong) HKHealthStore *healthStore; 1、这一步为你的应用实例化一个 HKHealthStore 对象。每个应用只需要一个HealthKit存储实例。这个存储实例就是你和HealthKit数据库交互的主要接口。 1self.healthStore = [[HKHealthStore alloc] init]; 2、 调用 isHealthDataAvailable 方法来查看HealthKit在该设备上是否可用。HealthKit在iPad上不可用。 123if ([HKHealthStore isHealthDataAvailable]) { NSLog(@&quot;HealthDataAvailable&quot;); } 3、在项目中具体代码： 123456789101112131415161718192021222324//创建想要获取的数据类型 HKObjectType *stepCpunt = [HKObjectType quantityTypeForIdentifier:HKQuantityTypeIdentifierStepCount];//步数 HKObjectType *Height = [HKObjectType quantityTypeForIdentifier:HKQuantityTypeIdentifierHeight];//身高 HKObjectType *BodyMass = [HKObjectType quantityTypeForIdentifier:HKQuantityTypeIdentifierBodyMass];//体重 HKObjectType *DistanceWalkingRunning = [HKObjectType quantityTypeForIdentifier:HKQuantityTypeIdentifierDistanceWalkingRunning];//步行+跑步距离 HKObjectType *DistanceCycling = [HKObjectType quantityTypeForIdentifier:HKQuantityTypeIdentifierDistanceCycling];//骑行距离 //一个集合，数据类型 NSSet *healthSet = [NSSet setWithObjects:stepCpunt,Height,BodyMass,DistanceWalkingRunning,DistanceCycling,nil]; //[self.healthStore requestAuthorizationToShareTypes:nil readTypes:healthSet completion:nil]; //向系统的健康APP请求数据，并回调结果 [self.healthStore requestAuthorizationToShareTypes:nil readTypes:healthSet completion:^(BOOL success, NSError * _Nullable error) { if (success) { NSLog(@&quot;requestAuthorization success&quot;); [self readHealthData:HKQuantityTypeIdentifierStepCount]; [self readHealthData:HKQuantityTypeIdentifierDistanceWalkingRunning]; [self readHealthData:HKQuantityTypeIdentifierDistanceCycling]; [self readHealthData:HKQuantityTypeIdentifierHeight]; [self readHealthData:HKQuantityTypeIdentifierBodyMass]; }else{ NSLog(@&quot;requestAuthorization error&quot;); } }]; 具体的数据获的操作 123456789101112131415161718192021222324252627282930313233//查询数据- (void)readHealthData:(NSString* )HKQuantityTypeIdentifierType{ //查询采样信息 HKSampleType *sampleType = [HKQuantityType quantityTypeForIdentifier:HKQuantityTypeIdentifierType]; //NSSortDescriptors用来告诉healthStore怎么样将结果排序。 NSSortDescriptor *start = [NSSortDescriptor sortDescriptorWithKey:HKSampleSortIdentifierStartDate ascending:NO]; NSSortDescriptor *end = [NSSortDescriptor sortDescriptorWithKey:HKSampleSortIdentifierEndDate ascending:NO]; /* 查询的基类是HKQuery，这是一个抽象类，能够实现每一种查询目标，这里我们需要查询的步数是一个 HKSample类所以对应的查询类就是HKSampleQuery。 下面的limit参数传1表示查询最近一条数据,查询多条数据只要设置limit的参数值就可以了 在这里我们需要定义block里面执行哪些语句 */ HKSampleQuery *sampleQuery = [[HKSampleQuery alloc] initWithSampleType:sampleType predicate:nil limit:2 sortDescriptors:@[start,end] resultsHandler:^(HKSampleQuery * _Nonnull query, NSArray&lt;__kindof HKSample *&gt; * _Nullable results, NSError * _Nullable error) { //打印查询结果 NSLog(@&quot;resultCount = %ld result = %@&quot;,results.count,results); //把结果装换成字符串类型 if (results.count!=0) { HKQuantitySample *result = results[0]; HKQuantity *quantity = result.quantity; NSString *stepStr = (NSString *)quantity; [[NSOperationQueue mainQueue] addOperationWithBlock:^{ //查询是在多线程中进行的，如果要对UI进行刷新，要回到主线程中 NSLog(@&quot;最新数据：%@&quot;,stepStr); }]; }else{ NSLog(@&quot;没有健康数据&quot;); } }]; //执行查询 [self.healthStore executeQuery:sampleQuery];} 运行结果在这里","link":"/2017/08/18/ios-healthkit/"},{"title":"通过assetURL获取到视频","text":"首先导入头文件 1#import &lt;Photos/Photos.h&gt; iOS中assetURL样式： 1assets-library://asset/asset.mov?id=F2E6E143-4343-4B57-87F9-346936E0EDB3&amp;ext=mov 使用当前的URL过滤到我们想要的数据 1234567891011121314151617181920212223242526272829303132PHFetchResult *result = [PHAsset fetchAssetsWithALAssetURLs:@[assetUrl] options:nil]; PHAsset * PHAsset = result.firstObject; /// 包含该视频的基础信息 PHAssetResource * resource = [[PHAssetResource assetResourcesForAsset: PHAsset] firstObject]; NSLog(@&quot;%@&quot;,resource); /* type: originalFilename: */ PHImageRequestOptions * options = [[PHImageRequestOptions alloc] init]; options.version = PHImageRequestOptionsVersionCurrent; options.deliveryMode = PHImageRequestOptionsDeliveryModeHighQualityFormat; options.synchronous = YES; __block NSData *videoData = nil; [[PHImageManager defaultManager] requestImageDataForAsset: PHAsset options: options resultHandler: ^(NSData * imageData, NSString * dataUTI, UIImageOrientation orientation, NSDictionary * info) { NSLog(@&quot;%@&quot;,imageData); //这里的imageData就是视频数据; }];","link":"/2017/12/14/ios-use-asseturl-get-vedio/"},{"title":"水波纹-OC-iOS","text":"简介使用iOS原生CoreGraphic框架完成，主要内容就是在给定的路径上绘制出图形，水波纹的实现是按照三角函数的sin函数来实现的，利用sin函数计算出大量的点，然后做颜色填充。 实现方法首先一个波纹需要一个layer来进行渲染，越底层的波纹要越早绘制，本Demo只实现了双波纹交错。水波纹基本属性： 不需要对外暴露的属性 12345678@interface WaterRippleView(){ float _currentLinePointY;}@property (nonatomic, strong)CADisplayLink *rippleDisplayLink;//苹果的垂直同步@property (nonatomic, strong)CAShapeLayer *mainRippleLayer;//主波图层@property (nonatomic, strong)CAShapeLayer *minorRippleLayer;//次波图层@property (nonatomic, assign)CGFloat rippleWidth;//波浪宽度@end 可以对外暴露的属性 1234567@property (nonatomic, strong)UIColor *mainRippleColor;//主波填充颜色@property (nonatomic, strong)UIColor *minorRippleColor;//次波填充颜色@property (nonatomic, assign)CGFloat mainRippleoffsetX;//主波偏移量@property (nonatomic, assign)CGFloat minorRippleoffsetX;//次波偏移量@property (nonatomic, assign)CGFloat rippleSpeed;//波浪速度@property (nonatomic, assign)CGFloat ripplePosition;//波浪Y轴位置@property (nonatomic, assign)float rippleAmplitude;//波浪振幅 各属性的默认值设置 12345678self.mainRippleColor = [UIColor colorWithRed:255/255.0f green:127/255.0f blue:80/255.0f alpha:1];self.minorRippleColor = [UIColor whiteColor];self.mainRippleoffsetX = 1;self.minorRippleoffsetX = 2;self.rippleSpeed = .5f;self.rippleWidth = frame.size.width;self.ripplePosition = frame.size.height-10.0f;self.rippleAmplitude = 5; 对外暴露的方法 1234//设置frame 主波填充颜色 次波填充颜色- (instancetype)initWithFrame:(CGRect)frame mainRippleColor:(UIColor *)mainRippleColor minorRippleColor:(UIColor *)minorRippleColor;//设置frame 主波填充颜色 次波填充颜色 主波偏移量 次波偏移量 波浪速度 波浪Y轴位置 波浪振幅- (instancetype)initWithFrame:(CGRect)frame mainRippleColor:(UIColor *)mainRippleColor minorRippleColor:(UIColor *)minorRippleColor mainRippleoffsetX:(float)mainRippleoffsetX minorRippleoffsetX:(float)minorRippleoffsetX rippleSpeed:(float)rippleSpeed ripplePosition:(float)ripplePosition rippleAmplitude:(float)rippleAmplitude; 在view中需要绘制图形时，要在自带的dramRect：方法中编写相关代码 123456789101112131415- (void)drawRect:(CGRect)rect { /* *创建两个layer */ self.mainRippleLayer = [CAShapeLayer layer]; self.mainRippleLayer.fillColor = self.mainRippleColor.CGColor; [self.layer addSublayer:self.mainRippleLayer]; self.minorRippleLayer = [CAShapeLayer layer]; self.minorRippleLayer.fillColor = self.minorRippleColor.CGColor; [self.layer addSublayer:self.minorRippleLayer]; self.rippleDisplayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(getCurrentRipple)]; [self.rippleDisplayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];} 下面是绘制代码：主波 123456789101112131415- (void)drawMainRipple{ self.mainRippleoffsetX += self.rippleSpeed; CGMutablePathRef path = CGPathCreateMutable(); CGPathMoveToPoint(path, nil, 0, self.ripplePosition); CGFloat y = 0.f; for (float x = 0.f; x &lt;= self.rippleWidth ; x++) { y = self.rippleAmplitude * sin(1.2 * M_PI/ self.rippleWidth * x - self.mainRippleoffsetX *M_PI/180) + self.ripplePosition; CGPathAddLineToPoint(path, nil, x, y); } CGPathAddLineToPoint(path, nil, self.rippleWidth, self.frame.size.height); CGPathAddLineToPoint(path, nil, 0, self.frame.size.height); CGPathCloseSubpath(path); self.mainRippleLayer.path = path; CGPathRelease(path);} 次波 12345678910111213141516- (void)drawMinorRipple{ self.minorRippleoffsetX += self.rippleSpeed+0.1f; CGMutablePathRef minorRipple = CGPathCreateMutable(); CGPathMoveToPoint(minorRipple, nil, 0, self.ripplePosition); CGFloat y = 0.f; for (float x = 0.f; x &lt;= self.rippleWidth ; x++) { y = self.rippleAmplitude * sin(1.2 * M_PI/ self.rippleWidth * x - self.minorRippleoffsetX*M_PI/360 ) + self.ripplePosition; CGPathAddLineToPoint(minorRipple, nil, x, y); } CGPathAddLineToPoint(minorRipple, nil, self.rippleWidth, self.frame.size.height); CGPathAddLineToPoint(minorRipple, nil, 0, self.frame.size.height); CGPathCloseSubpath(minorRipple); self.minorRippleLayer.path = minorRipple; CGPathRelease(minorRipple);} 实现效果 最后本Demo的git库地址：https://git.oschina.net/LiynXu/waterripple.git欢迎访问","link":"/2017/07/14/ios-water-ripple-oc/"},{"title":"斐讯K2刷华硕固件","text":"写在前面斐讯K2是一款处于1200Mbps(300+867Mbps)无线速率段的双频802.11ac路由器，2.4G+5G双频并发，PA+LNA强强组合，智能管理轻松控制，斐讯K2完美诠释了“家再大，隔墙再多，WiFi信号不受阻隔”的上网体验。斐讯K2路由器可以在京东免费撸，很多朋友撸回家发现固件太垃圾，各种不好用，因此想把斐讯K2刷成华硕固件。 中关村斐讯K2 重要说明 据说，这种方法支持斐讯K2的固件版本为： 22.3.15.128 22.3.15.232 22.3.17.148 22.4.2.8 22.4.2.9 如果目前你的斐讯K2路由器的固件版本高于或者低于这几个版本，可以进行升级或者降级操作，然后按照。下面我会提供相关文件的下载地址，方便大家下载后进行升级和降级操作。点击 百度网盘或者复制链接: https://pan.baidu.com/s/1gfssXUz 密码: qdke 第一步：——自带固件降级—–降级分为两个版本，一个是老版本22.5.9，另外一个是22.5.11，因为在.11版本降级会出现提示，非法固件而不允许刷机，那么我们就是用另外一种方法来进行刷机 首先22.5.9版本降级第1步a、进入系统设置，找到手动升级，选择k2_163_v11_breed.bin ，然后升级 第2步a、升级完成后，断开路由器电源。 b、按住复位键，插上电源，等待7秒钟后松开复位键。 第3步 a、进入breed web设置页面 22.5.11版本降级第1步1、安装Firefox浏览器。 2、用网线连接电脑和路由器的Lan口（WAN口无所谓，联不联网无所谓），K1、K2默认登录密码修改为admin。 第2步、开启telnet工作1、打开Firefox浏览器登陆斐讯路由器，选择右上角的“定时重启路由器”，如图。 2、点击指定重启时间，将鼠标箭头放到05上，右键选择“查看元素”。注意一定要放在05上； 3、在查看器中将鼠标移到”05”上（找不到05的话刷新一下网页），点击鼠标右键，选择“编程HTML”。 4、将”05”改成”01:00 | telnetd -l /bin/login.sh”（复制粘贴即可），然后鼠标移动到黑框之外的空白处点击鼠标左键，就可以完成编辑了。 5、在定时重启路由器页面上选择05之后（注意现在回变成1：00…..），点击“保存”。 那么现在就完成了开启K2路由器telnet服务的工作。6、下载目录内breed Web助手（3.4版本）–&gt;关闭防火墙，退出杀毒软件–&gt;找到这个文件“路由器刷breed Web助手通用版v3.0”–&gt;右键以管理员身份运行 7、如图刷机方案选择：”通用方案[需要开启路由器telnet或ssh]”，然后点击开始刷机； 8、完成后这样就完成了斐讯路由器刷入不死Breed。 第二步： a、进入breed界面 b、在菜单固件更新中，选择文件哪一行，选择SW_K2_703004657_V22.4.2.8.bin 固件 c、等待上传完成 e、请等待升级完成，自动重启后。然后按住复位键7秒，等待重启后。 到此你的路由器固件成功降级到了22.4.2.8 f、注意右下角的固件版本号 ——刷入华硕固件—–第1步–刷入breed和ssh a、点击“高级设置”——&gt;“备份恢复”——&gt;“浏览”找到刚才下载的：tianbaoha_breed_ssh.dat文件——&gt;“恢复备份”。 b、路由器会自动重启，等待重启完成 c、验证 斐讯K2重启完成后，重新在浏览器中输入p.to或者192.168.2.1，打开登录界面，管理密码用：tianbaoha 。如果可以登录到设置界面，说明breed和ssh已经刷入成功。 第2步a、管理密码用：tianbaoha 登录到K2的设置界面后，点击“高级设置”——&gt;“系统设置”——&gt;“手动升级”——&gt;点击 下载备份EEPROM，如下图所示。 第3步–刷写华硕固件**登录地址：192.168.123.1 ****管理账号：admin/admin **默认wifi密码：1234567890 a、点击“高级设置”——&gt;“系统设置”——&gt;“手动升级”——&gt;点击“浏览”，找到刚才下载的华硕固件:RT-AC54U-GPIO-1-PSG1208-64M_3.4.3.9-099.trx b、点击“升级”。 第4步 a、等待路由器重启。 b、在浏览器中输入：192.168.123.1 打开登录界面——&gt;用户名和密码用：admin/admin，登录到界面了 结束","link":"/2017/08/18/fei-xun-k2-shua-hua-shuo-gu-jian/"},{"title":"iOS--富文本推送NotificationContentExtension","text":"NotificationContentExtension文件根据以下ContentExtension Info.plist文件中的配置决定category的设置，两者必须一致： NSExtensionPrincipalClass对应的值是你展示视图的controller（这里就是NotificationViewController） 宏定义采用下列代码： 12345678910111213141516//推送相关设置#define Action_Category_Identifier_Image @&quot;Image_Category&quot; //图片类别标识符#define Action_Category_Identifier_Audio @&quot;Audio_Category&quot; //音频类别标识符#define Action_Category_Identifier_Movie @&quot;Movie_Category&quot; //视频类别标识符#define Action_Identifier_Image_Confirm @&quot;imageConfirmAction&quot; //图片确认按钮#define Action_Identifier_Image_Concel @&quot;imageConcelAction&quot; //图片取消按钮#define Action_Identifier_Audio_Confirm @&quot;audioConfirmAction&quot; //音频确认按钮#define Action_Identifier_Audio_Concel @&quot;audioConcelAction&quot; //音频取消按钮#define Action_Identifier_Movie_Confirm @&quot;movieConfirmAction&quot; //视频确认按钮#define Action_Identifier_Movie_Concel @&quot;movieConcelAction&quot; //视频取消按钮#define Action_Title_Image_Confirm @&quot;查看&quot; //图片确认按钮标题#define Action_Title_Image_Concel @&quot;忽略&quot; //图片取消按钮标题#define Action_Title_Audio_Confirm @&quot;查看&quot; //音频确认按钮标题#define Action_Title_Audio_Concel @&quot;忽略&quot; //音频取消按钮标题#define Action_Title_Movie_Confirm @&quot;查看&quot; //视频确认按钮标题#define Action_Title_Movie_Concel @&quot;忽略&quot; //视频取消按钮标题 采用的是自定义布局，注意如果想使用这个布局的话，你必须提前在service里面设置好categoryIdentifier，它的值是你plist文件里面的任何一个 1234@interface NotificationViewController () &lt;UNNotificationContentExtension&gt;@property (nonatomic, strong)UIImageView *imageView;@property (nonatomic,strong)UILabel *label;@end LazyLoad 1234567-(UIImageView *)imageView{ if (_imageView == nil) { _imageView = [[UIImageView alloc] init]; _imageView.contentMode = UIViewContentModeScaleAspectFit; } return _imageView;} AddView 123456- (void)viewDidLoad { [super viewDidLoad]; [self.view addSubview:self.imageView]; // Do any required interface initialization here.} 取出多媒体资料并展示到视图上，下面为image 123456789101112131415161718- (void)didReceiveNotification:(UNNotification *)notification { NSLog(@&quot;notification.request.content.userInfo%@&quot;,notification.request.content.userInfo); UNNotificationContent * content = notification.request.content; CGFloat widthTime = 2; if ([UIScreen mainScreen].bounds.size.width&gt;375) { widthTime = 3.0; } UIImage *image = nil; if (content.attachments.count) { UNNotificationAttachment * attachment_img = content.attachments[0]; if (attachment_img.URL.startAccessingSecurityScopedResource) { image = [UIImage imageWithContentsOfFile:attachment_img.URL.path]; self.imageView.image = image; } } self.imageView.frame = self.view.frame; self.label.text = notification.request.content.body;} 响应相关Action 12345678910111213141516171819202122232425-(void)didReceiveNotificationResponse:(UNNotificationResponse *)response completionHandler:(void (^)(UNNotificationContentExtensionResponseOption))completion{ UNNotificationContent *content = [response.notification.request.content mutableCopy]; NSString *category = content.categoryIdentifier; NSString *actionIdentifier = [response.actionIdentifier copy]; if ([category isEqualToString:Action_Category_Identifier_Image]) { if ([actionIdentifier isEqualToString:Action_Identifier_Image_Confirm]) { completion(UNNotificationContentExtensionResponseOptionDismissAndForwardAction); }else{ completion(UNNotificationContentExtensionResponseOptionDismiss); } }else if ([category isEqualToString:Action_Category_Identifier_Audio]){ if ([actionIdentifier isEqualToString:Action_Identifier_Audio_Confirm]) { completion(UNNotificationContentExtensionResponseOptionDismissAndForwardAction); }else{ completion(UNNotificationContentExtensionResponseOptionDismiss); } }else{ if ([actionIdentifier isEqualToString:Action_Identifier_Movie_Confirm]) { completion(UNNotificationContentExtensionResponseOptionDismissAndForwardAction); }else{ completion(UNNotificationContentExtensionResponseOptionDismiss); } }}","link":"/2017/07/18/ios-notificationcontentextension/"},{"title":"iOS--富文本推送NotificationServiceExtension","text":"添加http协议支持，没错，这里是支持http协议的，不像其他文章说的不支持配置在另外基础篇文章里面有，info.plist文件里修改一下就行了 NotificationService文件额外添加了一个文件管理器的字段，用来存储数据 123456789101112@interface NotificationService ()@property (nonatomic, strong) void (^contentHandler)(UNNotificationContent *contentToDeliver);@property (nonatomic, strong) UNMutableNotificationContent *bestAttemptContent;@property (nonatomic, strong) NSFileManager *fileMgr;@property (nonatomic, strong) NSURLSessionDownloadTask *download;@property (nonatomic, strong) NSURLSession *session;@property (nonatomic, strong) NSDictionary *userInfo;@property (nonatomic, strong) NSURL *attchUrl;@property (nonatomic, strong) NSString *imageExtension;@end 1@implementation NotificationService LazyLoad 123-(NSFileManager *)fileMgr{ return [NSFileManager defaultManager];} 网络session 123456-(NSURLSession *)session{ if (_session == nil) { _session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]]; } return _session;} 下载任务 123456789101112131415161718192021222324-(NSURLSessionDownloadTask *)download{ if (!_download) { _download = [self.session downloadTaskWithURL:self.attchUrl completionHandler:^(NSURL * _Nullable tempLocation, NSURLResponse * _Nullable response, NSError * _Nullable error) { if (!error) { NSURL *localURL = [NSURL fileURLWithPath:[tempLocation.path stringByAppendingString:self.imageExtension]]; [self.fileMgr moveItemAtURL:tempLocation toURL:localURL error:&amp;error]; NSError *attachmentError = nil; UNNotificationAttachment * attachment = [UNNotificationAttachment attachmentWithIdentifier:@&quot;photo&quot; URL:localURL options:nil error:&amp;attachmentError]; if (attachmentError) { NSLog(@&quot;attachmentError %@&quot;,attachmentError); }else if (attachment){ self.bestAttemptContent.attachments = @[attachment]; }else{ } }else{ NSLog(@&quot;downloadTaskerror %@&quot;,error.localizedDescription); } self.bestAttemptContent.categoryIdentifier = self.userInfo[@&quot;aps&quot;][@&quot;category&quot;]; self.contentHandler(self.bestAttemptContent); }]; } return _download;} 收到远程通知之后，在当前方法内进行处理，并生成attchment，最终回调给系统 12345678910111213- (void)didReceiveNotificationRequest:(UNNotificationRequest *)request withContentHandler:(void (^)(UNNotificationContent * _Nonnull))contentHandler { self.contentHandler = contentHandler; self.bestAttemptContent = [request.content mutableCopy]; self.resumeTime = 0; self.userInfo = [request.content.userInfo copy]; NSString * attchUrl = self.userInfo[@&quot;image&quot;]; self.imageExtension = [NSString stringWithFormat:@&quot;.%@&quot;,[[attchUrl componentsSeparatedByString:@&quot;.&quot;] lastObject]]; if (attchUrl) { self.attchUrl = [NSURL URLWithString:attchUrl]; [self resumeSession]; }} 开始执行下载多媒体资源任务 1234- (void)resumeSession{ [self.download resume];} 超时，异常时调用 123456789- (void)serviceExtensionTimeWillExpire { // Called just before the extension will be terminated by the system. // Use this as an opportunity to deliver your &quot;best attempt&quot; at modified content, otherwise the original push payload will be used. self.contentHandler(self.bestAttemptContent);}@end","link":"/2017/07/18/ios-notificationserviceextension/"},{"title":"iOS--富文本推送UIMutableUserNotificationAction","text":"iOS10富文本推送–UIMutableUserNotificationAction AppDelagate文件添加action根据以下ContentExtension Info.plist文件中的配置决定category的设置，两者必须一致 宏定义采用下列代码： 12345678910111213141516//推送相关设置#define Action_Category_Identifier_Image @&quot;Image_Category&quot; //图片类别标识符#define Action_Category_Identifier_Audio @&quot;Audio_Category&quot; //音频类别标识符#define Action_Category_Identifier_Movie @&quot;Movie_Category&quot; //视频类别标识符#define Action_Identifier_Image_Confirm @&quot;imageConfirmAction&quot; //图片确认按钮#define Action_Identifier_Image_Concel @&quot;imageConcelAction&quot; //图片取消按钮#define Action_Identifier_Audio_Confirm @&quot;audioConfirmAction&quot; //音频确认按钮#define Action_Identifier_Audio_Concel @&quot;audioConcelAction&quot; //音频取消按钮#define Action_Identifier_Movie_Confirm @&quot;movieConfirmAction&quot; //视频确认按钮#define Action_Identifier_Movie_Concel @&quot;movieConcelAction&quot; //视频取消按钮#define Action_Title_Image_Confirm @&quot;查看&quot; //图片确认按钮标题#define Action_Title_Image_Concel @&quot;忽略&quot; //图片取消按钮标题#define Action_Title_Audio_Confirm @&quot;查看&quot; //音频确认按钮标题#define Action_Title_Audio_Concel @&quot;忽略&quot; //音频取消按钮标题#define Action_Title_Movie_Confirm @&quot;查看&quot; //视频确认按钮标题#define Action_Title_Movie_Concel @&quot;忽略&quot; //视频取消按钮标题 添加相应类别的aciton，一个类别必须对应一个category，在下面这个方法里面执行, 1- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//添加相应类别的aciton，一个类别必须对应一个category- (void)addNotificationAction{ //Image_Category UIMutableUserNotificationAction *imageConfirmAction = [self creatNotificationActionIdentifier:Action_Identifier_Image_Confirm title:Action_Title_Image_Confirm activationMode:UIUserNotificationActivationModeForeground]; imageConfirmAction.authenticationRequired = YES; imageConfirmAction.destructive = YES; UIMutableUserNotificationAction *imageConcelAction = [self creatNotificationActionIdentifier:Action_Identifier_Image_Concel title:Action_Title_Image_Concel activationMode:UIUserNotificationActivationModeBackground]; UIMutableUserNotificationCategory *ImageCategory = [self creatNotificationCategoryIdentifier:Action_Category_Identifier_Image setActions:@[imageConfirmAction,imageConcelAction] forContext:UIUserNotificationActionContextDefault]; //Audio_Category UIMutableUserNotificationAction *audioConfirmAction = [self creatNotificationActionIdentifier:Action_Identifier_Audio_Confirm title:Action_Title_Audio_Confirm activationMode:UIUserNotificationActivationModeForeground]; audioConfirmAction.authenticationRequired = YES; audioConfirmAction.destructive = YES; UIMutableUserNotificationAction *audioConcelAction = [self creatNotificationActionIdentifier:Action_Identifier_Audio_Concel title:Action_Title_Audio_Concel activationMode:UIUserNotificationActivationModeBackground]; UIMutableUserNotificationCategory *audioCategory = [self creatNotificationCategoryIdentifier:Action_Category_Identifier_Audio setActions:@[audioConfirmAction,audioConcelAction] forContext:UIUserNotificationActionContextDefault]; //Movie_Category UIMutableUserNotificationAction *movieConfirmAction = [self creatNotificationActionIdentifier:Action_Identifier_Movie_Confirm title:Action_Title_Movie_Confirm activationMode:UIUserNotificationActivationModeForeground]; movieConfirmAction.authenticationRequired = YES; movieConfirmAction.destructive = YES; UIMutableUserNotificationAction *movieConcelAction = [self creatNotificationActionIdentifier:Action_Identifier_Movie_Concel title:Action_Title_Movie_Concel activationMode:UIUserNotificationActivationModeBackground]; UIMutableUserNotificationCategory *movieCategory = [self creatNotificationCategoryIdentifier:Action_Category_Identifier_Movie setActions:@[movieConfirmAction,movieConcelAction] forContext:UIUserNotificationActionContextDefault]; NSSet *categories = [NSSet setWithObjects:ImageCategory,audioCategory,movieCategory,nil]; UIUserNotificationType types = (UIUserNotificationTypeAlert| UIUserNotificationTypeSound| UIUserNotificationTypeBadge); UIUserNotificationSettings *settings; settings = [UIUserNotificationSettings settingsForTypes:types categories:categories]; [[UIApplication sharedApplication] registerUserNotificationSettings:settings]; } 创建一个category 12345678910//创建一个category- (UIMutableUserNotificationCategory*)creatNotificationCategoryIdentifier:(NSString *)identifier setActions:(nullable NSArray&lt;UIUserNotificationAction *&gt; *)actions forContext:(UIUserNotificationActionContext)context{ UIMutableUserNotificationCategory *category = [[UIMutableUserNotificationCategory alloc] init]; category.identifier = identifier;//这组动作的唯一标示 [category setActions:actions forContext:context]; return category;} 创建一个action 123456789101112//创建一个action-(UIMutableUserNotificationAction *)creatNotificationActionIdentifier:(NSString *)identifier title:(NSString *)title activationMode:(UIUserNotificationActivationMode)activationMode{ UIMutableUserNotificationAction *action = [[UIMutableUserNotificationAction alloc] init]; //第二按钮 action.identifier = identifier; action.title = title; action.activationMode = activationMode; return action;}","link":"/2017/07/18/ios-uimutableusernotificationaction/"},{"title":"iOS 如何加载本地html文件","text":"iOS 如何加载本地html文件???? 其实很简单 如下图所示 1234-(void)loadLocalHtml{ NSURL *url = [[NSBundle mainBundle] URLForResource:@&quot;/sfa/html/index.html&quot; withExtension:nil]; [self.webView loadRequest:[NSURLRequest requestWithURL:url]];} 其中 1@&quot;/sfa/html/index.html&quot; 部分是你的html文件相对于整个工程的路径例如下面这个工程构成图： 相关文件最好以文件方式导入而不是group CSDN: iOS 如何加载本地html文件 简书: iOS 如何加载本地html文件","link":"/2017/12/18/ios-ru-he-jia-zai-ben-di-html-wen-jian/"},{"title":"iOS--如何计算出今天是周几","text":"iOS–如何计算出今天是周几？？ 很简单： 123456789NSCalendar *cal = [[NSCalendar alloc] initWithCalendarIdentifier:NSCalendarIdentifierRepublicOfChina];NSInteger comp = [cal component:NSCalendarUnitWeekday fromDate:[NSDate date]];NSLog(@&quot;%ld&quot;,comp);NSDateComponents *comps = [cal components:NSCalendarUnitWeekday fromDate:[NSDate date]];NSLog(@&quot;%@&quot;,comps);","link":"/2017/08/23/ios-ru-he-ji-suan-chu-jin-tian-shi-zhou-ji/"},{"title":"iOS日志本地化--日志重定向","text":"写在前面本文主要是给读者分享技术的，如何保存能控制台输出的log，以便于查找程序本身出现的问题。 我们该如何做 首先我们要判断，是不是模拟器 1234567#if !(TARGET_IPHONE_SIMULATOR)//真机 //连接xcode时可以从监视器中看日志 没连接时Log日志会输出到文件中， [self redirectNSLogToDocumentFolder]; NSLog(@&quot;真机&quot;);#else//模拟器 NSLog(@&quot;模拟器&quot;);#endif 其次我们还要接着判断是不是真机连接了Xcode，然后才开始进行日志本地化文件的生成 12345678910111213141516171819202122232425262728293031323334- (void)redirectNSLogToDocumentFolder{ //如果已经连接Xcode调试则不输出到文件 if(isatty(STDOUT_FILENO)) { return; } UIDevice *device = [UIDevice currentDevice]; if([[device model] hasSuffix:@&quot;Simulator&quot;]){ //在模拟器不保存到文件中 return; } //将NSlog打印信息保存到Document目录下的Log文件夹下 NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *logDirectory = [[paths objectAtIndex:0] stringByAppendingPathComponent:@&quot;Log&quot;]; NSFileManager *fileManager = [NSFileManager defaultManager]; BOOL fileExists = [fileManager fileExistsAtPath:logDirectory]; if (!fileExists) { [fileManager createDirectoryAtPath:logDirectory withIntermediateDirectories:YES attributes:nil error:nil]; } NSDateFormatter *formatter = [[NSDateFormatter alloc] init]; [formatter setLocale:[[NSLocale alloc] initWithLocaleIdentifier:@&quot;zh_CN&quot;]]; [formatter setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;]; //每次启动后都保存一个新的日志文件中 NSString *dateStr = [formatter stringFromDate:[NSDate date]]; self.filepath = [logDirectory stringByAppendingFormat:@&quot;/%@.log&quot;,dateStr]; // 将log输入到文件 freopen([self.filepath cStringUsingEncoding:NSASCIIStringEncoding], &quot;a+&quot;, stdout); freopen([self.filepath cStringUsingEncoding:NSASCIIStringEncoding], &quot;a+&quot;, stderr); //未捕获的Objective-C异常日志 NSSetUncaughtExceptionHandler (&amp;UncaughtExceptionHandler);} 最后这是一个报错的异常信息，也就是我们所说的崩溃信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344void UncaughtExceptionHandler(NSException* exception){ NSString* name = [ exception name ]; NSString* reason = [ exception reason ]; NSArray* symbols = [ exception callStackSymbols ]; // 异常发生时的调用栈 NSMutableString* strSymbols = [ [ NSMutableString alloc ] init ]; //将调用栈拼成输出日志的字符串 for ( NSString* item in symbols ) { [ strSymbols appendString: item ]; [ strSymbols appendString: @&quot;\\r\\n&quot; ]; } //将crash日志保存到Document目录下的Log文件夹下 NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *logDirectory = [[paths objectAtIndex:0] stringByAppendingPathComponent:@&quot;Log&quot;]; NSFileManager *fileManager = [NSFileManager defaultManager]; if (![fileManager fileExistsAtPath:logDirectory]) { [fileManager createDirectoryAtPath:logDirectory withIntermediateDirectories:YES attributes:nil error:nil]; } //NSString *logFilePath = [logDirectory stringByAppendingPathComponent:@&quot;UncaughtException.log&quot;]; NSDateFormatter *formatter = [[NSDateFormatter alloc] init]; [formatter setLocale:[[NSLocale alloc] initWithLocaleIdentifier:@&quot;zh_CN&quot;]]; [formatter setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;]; AppDelegate *app = [UIApplication sharedApplication].delegate; NSString *dateStr = [formatter stringFromDate:app.date]; NSString *crashString = [NSString stringWithFormat:@&quot;&lt;- %@ -&gt;[ Uncaught Exception ]\\r\\nName: %@, Reason: %@\\r\\n[ Fe Symbols Start ]\\r\\n%@[ Fe Symbols End ]\\r\\n\\r\\n&quot;, dateStr, name, reason, strSymbols]; //把错误日志写到文件中 if (![fileManager fileExistsAtPath:app.filepath]) { [crashString writeToFile:app.filepath atomically:YES encoding:NSUTF8StringEncoding error:nil]; }else{ NSFileHandle *outFile = [NSFileHandle fileHandleForWritingAtPath:app.filepath]; [outFile seekToEndOfFile]; [outFile writeData:[crashString dataUsingEncoding:NSUTF8StringEncoding]]; [outFile closeFile]; } //把错误日志发送到邮箱 NSString *urlStr = [NSString stringWithFormat:@&quot;mailto://邮箱账号?subject=bug报告&amp;body=感谢您的配合!错误详情:%@&quot;,crashString ]; NSURL *url = [NSURL URLWithString:[urlStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]]; [[UIApplication sharedApplication] openURL:url];} 使用在AppDelegate的这个方法中编写如下代码 12345678910- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {#if !(TARGET_IPHONE_SIMULATOR)//真机 //连接xcode时可以从监视器中看日志 没连接时Log日志会输出到文件中， [self redirectNSLogToDocumentFolder]; NSLog(@&quot;真机&quot;);#else//模拟器 NSLog(@&quot;模拟器&quot;);#endifreturn YES;}","link":"/2017/08/18/ios-ri-zhi-ben-di-hua-ri-zhi-chong-ding-xiang/"},{"title":"iOS时间工具类","text":"iOS时间工具类工作之余写的一个关于Unix时间的工具 1234567891011121314151617181920@interface UnixTime : NSObject@property (nonatomic,assign) double unixTimeInterval;//GMT时间戳 微秒级@property (nonatomic,strong) NSDate *unixDate;//GMT时间 2016-01-04 8:55:46 +0000@property (nonatomic,strong) NSString *LocalTimeZone;//本地时区 GMT-12 GMT+12@property (nonatomic,assign) NSInteger timeOffset;//时间偏移量 @property (nonatomic,assign) double unixTimestamp;//GMT+0 毫秒@property (nonatomic,assign) NSInteger unixZeroTimestamp;//当天零点 GMT+0 秒+ (UnixTime *)shareUnixTime;//单例 类方法- (void)getUnixTimestampAtNow;//Unix时间戳 若要获取某天的零时刻 必须先执行找个方法- (void)getSystemTimeZone;//本地时区- (NSString *)getTimeStringWithTime:(double)time;//字符串输出时间 设置日期格式带毫秒的 2016-01-04 16:55:46- (NSInteger)getUnixTimeWithDay:(NSInteger)day;// 某天的零时Unix时间戳- (NSInteger)getUnixTimeWithDay:(NSInteger)day AndClock:(NSInteger)clock; // 某天的特定时刻Unix时间戳- (NSInteger)gettimestampWithDateFormatString:(NSString *)dateFormatString;- (NSString *)formatTimeWithTime:(NSNumber *)time;//根据传入时间数值 返回hh:mm:ss格式的时间 这个是表示时间点的- (NSString *)formatHMWithTime:(NSNumber *)time;//根据传入时间数值 返回hh:mm格式的时间 这个时用来表示时间长短的- (NSString *)getTravelTimeWithStartTime:(NSNumber *)startTime andEndTime:(NSNumber *)endTime;//根据传入时间数值返回时间差值分钟 这个时用来表示时间长短的- (NSString *)getDayHourMinWithTimeStamp:(NSNumber *)time;@end UnixTime.m文件包含方法的具体实现，用法都在.h文件里写了 1234567891011121314#import &quot;UnixTime.h&quot;@implementation UnixTime+ (UnixTime *)shareUnixTime{ static UnixTime *unixTime = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ unixTime = [[UnixTime alloc]init]; }); return unixTime;} 123456789101112131415161718- (void)getUnixTimestampAtNow{ self.unixDate = [NSDate date]; NSLog(@&quot;GMT %@&quot;,self.unixDate); NSTimeInterval time=[self.unixDate timeIntervalSince1970]; self.unixTimeInterval =time; NSString *timeIntervalString = [NSString stringWithFormat:@&quot;%f&quot;,self.unixTimeInterval]; NSLog(@&quot;GMTTimeInterval %@&quot;,timeIntervalString); NSString *micSecondString = [timeIntervalString substringWithRange:NSMakeRange(timeIntervalString.length-6, 3)]; //NSLog(@&quot;micSec %@&quot;,micSecondString); NSInteger micSec = [micSecondString integerValue]; self.unixTimestamp = (NSInteger)time+micSec/1000.000; NSLog(@&quot;GMTTimestamp %ld&quot;,(long)self.unixTimestamp); [self getUnixZeroTimestamp]; [self getSystemTimeZone]; [self getTimeOffset];} 12345678910111213- (void)getSystemTimeZone{ NSTimeZone *timezone = [NSTimeZone systemTimeZone]; //NSLog(@&quot;timeZone%@&quot;,timezone); NSString *timeAbbreviation = timezone.abbreviation; self.LocalTimeZone = timeAbbreviation; if ([timeAbbreviation isEqualToString:@&quot;GMT&quot;]) { self.LocalTimeZone = @&quot;GMT+0&quot;; } // NSLog(@&quot;TimeZone.abb: %@&quot;,self.LocalTimeZone);} 12345678910111213- (void)getTimeOffset{ NSString *str1 = [self.LocalTimeZone substringWithRange:NSMakeRange(3, 1)]; NSString *str2 = [self.LocalTimeZone substringWithRange:NSMakeRange(4, self.LocalTimeZone.length-4)]; NSInteger timeZoneOffset = [str2 integerValue]; if ([str1 isEqualToString:@&quot;+&quot;]) { self.timeOffset = timeZoneOffset*3600; }else if ([str1 isEqualToString:@&quot;-&quot;]){ self.timeOffset = -timeZoneOffset*3600; } //NSLog(@&quot;timeOffSet %ld&quot;,(long)self.timeOffset);} 123456789- (void)getUnixZeroTimestamp{ self.unixZeroTimestamp = (NSInteger)(self.unixTimestamp/86400)*86400; NSInteger days = self.unixZeroTimestamp/86400 ; NSLog(@&quot;GMTZeroTimestamp %ld&quot;,self.unixZeroTimestamp); NSLog(@&quot;days %ld&quot;,days);} 123456789101112- (NSString *)getTimeStringWithTime:(double)time{ NSDate *date = [NSDate dateWithTimeIntervalSince1970:time]; NSDateFormatter *dateFormat = [[NSDateFormatter alloc] init]; [dateFormat setDateFormat:@&quot;YYYY-MM-dd HH:mm:ss&quot;]; // 设置日期格式带秒的 2016-01-04 16:55:46 //NSLog(@&quot;date %@&quot;,date); NSString *timeString = [dateFormat stringFromDate:date]; //NSLog(@&quot;time %@&quot;,timeString); return timeString;} 12345678910- (NSInteger)gettimestampWithDateFormatString:(NSString *)dateFormatString{ NSDateFormatter *dateFormat = [[NSDateFormatter alloc] init]; [dateFormat setDateFormat:@&quot;YYYY-MM-dd HH:mm:ss&quot;]; NSDate *date = [dateFormat dateFromString:dateFormatString]; NSInteger time= [date timeIntervalSince1970]; NSLog(@&quot;time %ld&quot;,time); return time;} 12345678- (NSInteger)getUnixTimeWithDay:(NSInteger)day{ NSInteger unixTime = self.unixZeroTimestamp-(day-1)*86400-self.timeOffset; NSLog(@&quot;unixTime %ld&quot;,unixTime); NSLog(@&quot;%@&quot;,[self getTimeStringWithTime:unixTime]); return unixTime;} 12345678910111213141516171819- (NSInteger)getUnixTimeWithDay:(NSInteger)day AndClock:(NSInteger)clock{//特定时刻的Unix时间戳 if (clock&lt;0||clock&gt;24) {//为了避免传入数据不正确 进行换算 增强可靠性 clock = clock%24; if (clock&lt;0) { clock=clock+24; }else{ clock=clock; } }else{ clock=clock; } NSInteger unixTime = self.unixZeroTimestamp-(day-1)*86400+3600*clock;//-self.timeOffset; //NSLog(@&quot;unixTime %ld&quot;,unixTime); return unixTime;} 123456789101112131415161718192021- (NSString *)formatTimeWithTime:(NSNumber *)time{ float _time_2 = [time floatValue]; NSInteger _time_1 = [time integerValue]; NSInteger sec = (NSInteger)((_time_2-_time_1)*60); NSInteger hour; NSInteger min; if (_time_1&gt;=1 &amp;&amp; _time_1&lt;60) { min = _time_1%60; return [NSString stringWithFormat:@&quot;%ld:%.2ld&quot;,min,sec]; } if (_time_1&gt;=60) { hour = _time_1/60; min = _time_1%60; return [NSString stringWithFormat:@&quot;%ld:%.2ld:%.2ld&quot;,hour,min,sec]; } return [NSString stringWithFormat:@&quot;0:%.2ld&quot;,sec];} 1234567891011121314- (NSString *)formatHMWithTime:(NSNumber *)time{ UnixTime *unixtime = [UnixTime shareUnixTime]; NSString *string = [unixtime getTimeStringWithTime:[time integerValue]]; NSArray *firArray = [string componentsSeparatedByString:@&quot; &quot;]; NSString *firstring = firArray[1]; NSMutableArray *secArray = [NSMutableArray arrayWithArray:[firstring componentsSeparatedByString:@&quot;:&quot;]]; [secArray removeLastObject]; return [secArray componentsJoinedByString:@&quot;:&quot;]; } 1234567891011- (NSString *)getTravelTimeWithStartTime:(NSNumber *)startTime andEndTime:(NSNumber *)endTime{ NSInteger _startTime = [startTime integerValue]; NSInteger _endTime = [endTime integerValue]; NSInteger travelTime = (_endTime - _startTime)/60+1; return [NSString stringWithFormat:@&quot;%ld&quot;,travelTime];} 12345678910111213141516- (NSString *)getDayHourMinWithTimeStamp:(NSNumber *)time{ NSInteger _time = [time integerValue]; NSDate *date = [NSDate dateWithTimeIntervalSince1970:_time]; NSDateFormatter *dateFormat = [[NSDateFormatter alloc] init]; [dateFormat setDateFormat:@&quot;YYYY-MM-dd HH:mm&quot;]; // 设置日期格式 2016-01-04 16:55:46 //NSLog(@&quot;date %@&quot;,date); NSString *timeString = [dateFormat stringFromDate:date]; //NSLog(@&quot;time %@&quot;,timeString); return timeString;}@end","link":"/2017/07/14/ios-shi-jian-gong-ju-lei/"},{"title":"iOS自定义相机的实现","text":"iOS自定义相机的实现本文主要介绍iOS系统上的自定义相机的实现，其实并不难主要包含了，拍摄设备，输入端，输出端，以及抓取图像，保存图像的操作。 ###简单介绍组要控件 上方功能区 取消按钮 闪光灯按钮 相机切换按钮 下方功能区 拍照按钮 重新拍照按钮 选择照片按钮 图像展示视图 主要代码展示头文件内容展示 定了一个block，用于传输照片信息 1234567#import &lt;UIKit/UIKit.h&gt;typedef void(^ImageBlock)(NSDictionary *imageDictionary);@interface CameraViewController : UIViewController@property (nonatomic, copy) ImageBlock imageblock;-(void)setImageblock:(void(^)(NSDictionary *imageDictionary))imageblock;@end 视图控件代码，逻辑代码展示 当前视图需要的主要空控件，为了方便操作全部定义为属性 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@interface CameraViewController ()&lt;AVCaptureMetadataOutputObjectsDelegate,UIAlertViewDelegate,CAAnimationDelegate&gt;//捕获设备，通常是前置摄像头，后置摄像头，麦克风（音频输入）@property(nonatomic)AVCaptureDevice *device;//AVCaptureDeviceInput 代表输入设备，他使用AVCaptureDevice 来初始化@property(nonatomic)AVCaptureDeviceInput *input;//当启动摄像头开始捕获输入@property(nonatomic)AVCaptureMetadataOutput *output;//输出@property (nonatomic)AVCaptureStillImageOutput *ImageOutPut;//session：由他把输入输出结合在一起，并开始启动捕获设备（摄像头）@property(nonatomic)AVCaptureSession *session;//图像预览层，实时显示捕获的图像@property(nonatomic)AVCaptureVideoPreviewLayer *previewLayer;//设备@property (nonatomic, strong)AVCaptureDevice *deveice;//拍照@property (nonatomic, strong) UIButton *PhotoButton;//闪光灯@property (nonatomic, strong) UIButton *flashButton;//取消@property (nonatomic, strong) UIButton *cancleButton;//切换摄像头@property (nonatomic, strong) UIButton *changeButton;//确定选择当前照片@property (nonatomic, strong) UIButton *selectButton;//重新拍照@property (nonatomic, strong) UIButton *reCamButton;//照片加载视图@property (nonatomic, strong) UIImageView *imageView;//对焦区域@property (nonatomic, strong) UIImageView *focusView;//上方功能区@property (nonatomic, strong) UIView *topView;//下方功能区@property (nonatomic, strong) UIView *bottomView;//闪光灯状态@property (nonatomic, assign) BOOL isflashOn;//拍到的照片@property (nonatomic, strong) UIImage *image;//照片的信息@property (nonatomic, strong) NSDictionary *imageDict;//是否可以拍照@property (nonatomic, assign) BOOL canCa;//闪光灯模式@property (nonatomic, assign) AVCaptureFlashMode flahMode;//前后摄像头@property (nonatomic, assign) AVCaptureDevicePosition cameraPosition;//模糊视图@property (nonatomic, strong) UIVisualEffectView *effectView;@end 使用懒加载，减少主要函数中的代码，看起来更为清爽。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164@implementation CameraViewController#pragma mark - 更改摄像头-(UIVisualEffectView *)effectView{ if (_effectView == nil) { UIBlurEffect *effect = [UIBlurEffect effectWithStyle:UIBlurEffectStyleLight]; _effectView = [[UIVisualEffectView alloc] initWithEffect:effect]; _effectView.frame = CGRectMake(0, 0, ScreenWidth(), ScreenHieght()); _effectView.alpha = 1; } return _effectView;} #pragma mark - 更改闪光灯状态-(void)setIsflashOn:(BOOL)isflashOn{ _isflashOn = isflashOn; [[NSUserDefaults standardUserDefaults] setObject:@(_isflashOn) forKey:@&quot;flashMode&quot;]; if (_isflashOn) { [self.flashButton setBackgroundImage:[UIImage imageNamed:@&quot;flash_on&quot;] forState:UIControlStateNormal]; }else{ [self.flashButton setBackgroundImage:[UIImage imageNamed:@&quot;flash_off&quot;] forState:UIControlStateNormal]; }}#pragma mark - 上方功能区-(UIView *)topView{ if (!_topView ) { _topView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, ScreenWidth(), 50)]; _topView.backgroundColor = [UIColor colorWithRed:1 green:1 blue:1 alpha:0.2]; [_topView addSubview:self.cancleButton]; [_topView addSubview:self.flashButton]; [_topView addSubview:self.changeButton]; } return _topView;}#pragma mark - 取消-(UIButton *)cancleButton{ if (_cancleButton == nil) { _cancleButton = [UIButton buttonWithType:UIButtonTypeCustom]; _cancleButton.frame = CGRectMake(20, 10, 60, 30); [_cancleButton setTitle:@&quot;取消&quot; forState:UIControlStateNormal]; [_cancleButton addTarget:self action:@selector(cancle) forControlEvents:UIControlEventTouchUpInside]; } return _cancleButton ;}#pragma mark - 闪光灯-(UIButton *)flashButton{ if (_flashButton == nil) { _flashButton = [UIButton buttonWithType:UIButtonTypeCustom]; _flashButton.frame = CGRectMake((ScreenWidth()-30)/2.0, 10, 30, 30); [_flashButton addTarget:self action:@selector(FlashOn) forControlEvents:UIControlEventTouchUpInside]; } return _flashButton;}#pragma mark - 切换摄像头-(UIButton *)changeButton{ if (_changeButton == nil) { _changeButton = [UIButton buttonWithType:UIButtonTypeCustom]; _changeButton.frame = CGRectMake(ScreenWidth()-40, 10, 30, 30); [_changeButton setBackgroundImage:[UIImage imageNamed:@&quot;cam&quot;] forState:UIControlStateNormal]; [_changeButton addTarget:self action:@selector(changeCamera) forControlEvents:UIControlEventTouchUpInside]; } return _changeButton;}#pragma mark - 下方功能区-(UIView *)bottomView{ if (!_bottomView) { _bottomView = [[UIView alloc] initWithFrame:CGRectMake(0, ScreenHieght()-80, ScreenWidth(), 80)]; _bottomView.backgroundColor = [UIColor colorWithRed:1 green:1 blue:1 alpha:0.4]; [_bottomView addSubview:self.reCamButton]; [_bottomView addSubview:self.PhotoButton]; [_bottomView addSubview:self.selectButton]; } return _bottomView;}-(UIButton *)reCamButton{ if (_reCamButton == nil) { _reCamButton = [UIButton buttonWithType:UIButtonTypeCustom]; _reCamButton.frame = CGRectMake(40, 25, 80, 30); [_reCamButton addTarget:self action:@selector(reCam) forControlEvents:UIControlEventTouchUpInside]; [_reCamButton setTitle:@&quot;重新拍照&quot; forState:UIControlStateNormal]; [_reCamButton setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal]; _reCamButton.alpha = 0; } return _reCamButton;}-(UIButton *)PhotoButton{ if (_PhotoButton == nil) { _PhotoButton = [UIButton buttonWithType:UIButtonTypeCustom]; _PhotoButton.frame = CGRectMake(ScreenWidth()/2.0-30, 10, 60, 60); [_PhotoButton setImage:[UIImage imageNamed:@&quot;photograph&quot;] forState: UIControlStateNormal]; [_PhotoButton setImage:[UIImage imageNamed:@&quot;photograph_Select&quot;] forState:UIControlStateNormal]; [_PhotoButton addTarget:self action:@selector(shutterCamera) forControlEvents:UIControlEventTouchUpInside]; } return _PhotoButton;}-(UIButton *)selectButton{ if (_selectButton == nil) { _selectButton = [UIButton buttonWithType:UIButtonTypeCustom]; _selectButton.frame = CGRectMake(ScreenWidth()-120, 25, 80, 30); [_selectButton addTarget:self action:@selector(selectImage) forControlEvents:UIControlEventTouchUpInside]; [_selectButton setTitle:@&quot;选择照片&quot; forState:UIControlStateNormal]; [_selectButton setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal]; _selectButton.alpha = 0; } return _selectButton;}#pragma mark - 加载照片的视图-(UIImageView *)imageView{ if (_imageView == nil) { _imageView = [[UIImageView alloc]initWithFrame:self.previewLayer.frame]; _imageView.layer.masksToBounds = YES; _imageView.image = _image; } return _imageView;}#pragma mark - 对焦区域-(UIImageView *)focusView{ if (_focusView == nil) { _focusView = [[UIImageView alloc]initWithFrame:CGRectMake(0, 0, 80, 80)]; _focusView.backgroundColor = [UIColor clearColor]; _focusView.image = [UIImage imageNamed:@&quot;foucs80pt&quot;]; } return _focusView;}#pragma mark - 使用self.session，初始化预览层，self.session负责驱动input进行信息的采集，layer负责把图像渲染显示-(AVCaptureVideoPreviewLayer *)previewLayer{ if (_previewLayer == nil) { _previewLayer = [[AVCaptureVideoPreviewLayer alloc]initWithSession:self.session]; _previewLayer.frame = CGRectMake(0, 0, ScreenWidth(), ScreenHieght()); _previewLayer.videoGravity = AVLayerVideoGravityResizeAspectFill; } return _previewLayer;}-(AVCaptureStillImageOutput *)ImageOutPut{ if (_ImageOutPut == nil) { _ImageOutPut = [[AVCaptureStillImageOutput alloc] init]; } return _ImageOutPut;}#pragma mark - 初始化输入-(AVCaptureDeviceInput *)input{ if (_input == nil) { _input = [[AVCaptureDeviceInput alloc]initWithDevice:self.device error:nil]; } return _input;}#pragma mark - 初始化输出-(AVCaptureMetadataOutput *)output{ if (_output == nil) { _output = [[AVCaptureMetadataOutput alloc]init]; } return _output;}#pragma mark - 使用AVMediaTypeVideo 指明self.device代表视频，默认使用后置摄像头进行初始化-(AVCaptureDevice *)device{ if (_device == nil) { _device = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo]; } return _device;} 主要逻辑代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#pragma mark - 当前视图控制器的初始化- (instancetype)init{ self = [super init]; if (self) { _canCa = [self canUserCamear]; } return self;}-(void)setImageblock:(void (^)(NSDictionary *))imageblock{ _imageblock = imageblock;}#pragma mark - 检查相机权限- (BOOL)canUserCamear{ AVAuthorizationStatus authStatus = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeVideo]; if (authStatus == AVAuthorizationStatusDenied) { UIAlertView *alertView = [[UIAlertView alloc]initWithTitle:@&quot;请打开相机权限&quot; message:@&quot;设置-隐私-相机&quot; delegate:self cancelButtonTitle:@&quot;确定&quot; otherButtonTitles:@&quot;取消&quot;, nil]; alertView.tag = 100; [alertView show]; return NO; } else{ return YES; } return YES;}#pragma mark - 视图加载- (void)viewDidLoad { [super viewDidLoad]; self.view.backgroundColor = [UIColor clearColor]; if (_canCa) { [self customCamera]; [self customUI]; [self FlashOn]; }else{ return; } // Do any additional setup after loading the view, typically from a nib.}#pragma mark - 自定义视图- (void)customUI{ [self.view addSubview:self.topView]; [self.view addSubview:self.bottomView]; [self.view addSubview:self.focusView]; UITapGestureRecognizer *tapGesture = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(focusGesture:)]; [self.view addGestureRecognizer:tapGesture]; }#pragma mark - 自定义相机- (void)customCamera{ //生成会话，用来结合输入输出 self.session = [[AVCaptureSession alloc]init]; if ([self.session canSetSessionPreset:AVCaptureSessionPresetPhoto]) { self.session.sessionPreset = AVCaptureSessionPresetPhoto; } if ([self.session canAddInput:self.input]) { [self.session addInput:self.input]; } if ([self.session canAddOutput:self.ImageOutPut]) { [self.session addOutput:self.ImageOutPut]; } [self.view.layer addSublayer:self.previewLayer]; //开始启动 [self.session startRunning]; if ([self.device lockForConfiguration:nil]) { if ([self.device isFlashModeSupported:AVCaptureFlashModeAuto]) { [self.device setFlashMode:AVCaptureFlashModeAuto]; } //自动白平衡 if ([self.device isWhiteBalanceModeSupported:AVCaptureWhiteBalanceModeAutoWhiteBalance]) { [self.device setWhiteBalanceMode:AVCaptureWhiteBalanceModeAutoWhiteBalance]; } [self.device unlockForConfiguration]; } [self focusAtPoint:self.view.center];} *闪光灯 1234567891011121314151617181920#pragma 闪光灯- (void)FlashOn{ if ([self.device lockForConfiguration:nil]) { if (self.isflashOn) { if ([self.device isFlashModeSupported:AVCaptureFlashModeOff]) { [self.device setFlashMode:AVCaptureFlashModeOff]; self.isflashOn = NO; //[self.flashButton setTitle:@&quot;关&quot; forState:UIControlStateNormal]; } }else{ if ([self.device isFlashModeSupported:AVCaptureFlashModeAuto]) { [self.device setFlashMode:AVCaptureFlashModeAuto]; self.isflashOn = YES; //[self.flashButton setTitle:@&quot;开&quot; forState:UIControlStateNormal]; } } [self.device unlockForConfiguration]; }} 双摄像头切换，切换时使用高斯模糊对试图进行处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#pragma mark - 相机切换- (void)changeCamera{ NSUInteger cameraCount = [[AVCaptureDevice devicesWithMediaType:AVMediaTypeVideo] count]; if (cameraCount &gt; 1) { self.changeButton.userInteractionEnabled = NO; [self cutoff]; NSError *error; CATransition *animation = [CATransition animation]; animation.duration = 1; animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]; animation.type = @&quot;oglFlip&quot;; animation.delegate = self; AVCaptureDevice *newCamera = nil; AVCaptureDeviceInput *newInput = nil; AVCaptureDevicePosition position = [[self.input device] position]; if (position == AVCaptureDevicePositionFront){ newCamera = [self cameraWithPosition:AVCaptureDevicePositionBack]; animation.subtype = kCATransitionFromLeft; self.cameraPosition = AVCaptureDevicePositionBack; }else { newCamera = [self cameraWithPosition:AVCaptureDevicePositionFront]; animation.subtype = kCATransitionFromRight; self.cameraPosition = AVCaptureDevicePositionFront; } newInput = [AVCaptureDeviceInput deviceInputWithDevice:newCamera error:nil]; [self.previewLayer addAnimation:animation forKey:nil]; /* 高斯模糊 */ [self.imageView addSubview:self.effectView]; [self.view insertSubview:self.imageView belowSubview:self.topView]; // if (newInput != nil) { [self.session beginConfiguration]; [self.session removeInput:self.input]; if ([self.session canAddInput:newInput]) { [self.session addInput:newInput]; self.input = newInput; } else { [self.session addInput:self.input]; } [self.session commitConfiguration]; } else if (error) { NSLog(@&quot;toggle carema failed, error = %@&quot;, error); } //[self.session startRunning]; }}- (AVCaptureDevice *)cameraWithPosition:(AVCaptureDevicePosition)position{ NSArray *devices = [AVCaptureDevice devicesWithMediaType:AVMediaTypeVideo]; for ( AVCaptureDevice *device in devices ) if ( device.position == position ) return device; return nil;}-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag{ self.changeButton.userInteractionEnabled = YES; [self.effectView removeFromSuperview]; [self.imageView removeFromSuperview]; if (self.cameraPosition == AVCaptureDevicePositionFront) { self.flashButton.alpha = 0; }else if (self.cameraPosition == AVCaptureDevicePositionBack){ self.flashButton.alpha = 1; } [self.session startRunning];} 摄像头对焦 1234567891011121314151617181920212223242526272829303132333435363738#pragma mark - 聚焦- (void)focusGesture:(UITapGestureRecognizer*)gesture{ CGPoint point = [gesture locationInView:gesture.view]; [self focusAtPoint:point];}- (void)focusAtPoint:(CGPoint)point{ CGSize size = self.view.bounds.size; CGPoint focusPoint = CGPointMake( point.y /size.height ,1-point.x/size.width ); NSError *error; if ([self.device lockForConfiguration:&amp;error]) { if ([self.device isFocusModeSupported:AVCaptureFocusModeAutoFocus]) { [self.device setFocusPointOfInterest:focusPoint]; [self.device setFocusMode:AVCaptureFocusModeAutoFocus]; } if ([self.device isExposureModeSupported:AVCaptureExposureModeAutoExpose ]) { [self.device setExposurePointOfInterest:focusPoint]; [self.device setExposureMode:AVCaptureExposureModeAutoExpose]; } [self.device unlockForConfiguration]; self.focusView.center = point; //[self startFocusAnimation]; self.focusView.alpha = 1; [UIView animateWithDuration:0.2 animations:^{ self.focusView.transform = CGAffineTransformMakeScale(1.25f, 1.25f); } completion:^(BOOL finished) { [UIView animateWithDuration:0.3 animations:^{ self.focusView.transform = CGAffineTransformMakeScale(1.0f, 1.0f); } completion:^(BOOL finished) { [self hiddenFocusAnimation]; }]; }]; } } 主要功能按钮 拍照按钮123456789101112131415161718192021222324252627#pragma mark - 拍照- (void)shutterCamera{ AVCaptureConnection * videoConnection = [self.ImageOutPut connectionWithMediaType:AVMediaTypeVideo]; if (!videoConnection) { NSLog(@&quot;take photo failed!&quot;); return; } [self.ImageOutPut captureStillImageAsynchronouslyFromConnection:videoConnection completionHandler:^(CMSampleBufferRef imageDataSampleBuffer, NSError *error) { if (imageDataSampleBuffer == NULL) { return; } NSData * imageData = [AVCaptureStillImageOutput jpegStillImageNSDataRepresentation:imageDataSampleBuffer]; self.image = [UIImage imageWithData:imageData]; self.imageDict = @{@&quot;image&quot;:self.image,@&quot;info&quot;:@{@&quot;PHImageFileUTIKey&quot;:@&quot;.jpeg&quot;}}; [self.session stopRunning]; //[self.view insertSubview:self.imageView belowSubview:self.PhotoButton]; [self.view insertSubview:self.imageView aboveSubview:self.topView]; NSLog(@&quot;image size = %@&quot;,NSStringFromCGSize(self.image.size)); self.topView.alpha = 0; self.PhotoButton.alpha = 0; self.reCamButton.alpha = 1; self.selectButton.alpha = 1; }];} 保存至相册 12345678910111213141516171819#pragma - 保存至相册- (void)saveImageToPhotoAlbum:(UIImage*)savedImage{ UIImageWriteToSavedPhotosAlbum(savedImage, self, @selector(image:didFinishSavingWithError:contextInfo:), NULL); }// 指定回调方法- (void)image: (UIImage *) image didFinishSavingWithError: (NSError *) error contextInfo: (void *) contextInfo{ if(error != NULL){ UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;保存图片结果提示&quot; message:@&quot;保存图片失败&quot; delegate:self cancelButtonTitle:@&quot;确定&quot; otherButtonTitles:nil]; [alert show]; }} 取消 返回上级 12345678910111213141516171819#pragma mark - 取消 返回上级-(void)cancle{ [self.imageView removeFromSuperview]; [self.session stopRunning]; [self.navigationController popViewControllerAnimated:YES];}- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex{ if (buttonIndex == 0 &amp;&amp; alertView.tag == 100) { NSURL * url = [NSURL URLWithString:UIApplicationOpenSettingsURLString]; if([[UIApplication sharedApplication] canOpenURL:url]) { [[UIApplication sharedApplication] openURL:url]; } }} 重新拍照 12345678910#pragma mark - 重新拍照- (void)reCam{ self.imageView.image = nil; [self.imageView removeFromSuperview]; [self.session startRunning]; self.topView.alpha = 1; self.PhotoButton.alpha = 1; self.reCamButton.alpha = 0; self.selectButton.alpha = 0;} 选择照片 返回上级 123456789101112131415#pragma mark - 选择照片 返回上级- (void)selectImage{ [self saveImageToPhotoAlbum:self.image]; self.imageblock(self.image); [self.navigationController popViewControllerAnimated:YES];}-(void)viewDidDisappear:(BOOL)animated{ }- (void)focusDidFinsh{ self.focusView.hidden = YES; self.focusView.transform = CGAffineTransformMakeScale(1.0f, 1.0f); //self.focusView.transform=CGAffineTransformMakeScale(0.7f, 0.7f);} 对焦框动画123456789101112131415161718192021222324252627- (void)startFocusAnimation{ self.focusView.hidden = NO; self.focusView.transform = CGAffineTransformMakeScale(1.25f, 1.25f);//将要显示的view按照正常比例显示出来 [UIView beginAnimations:nil context:UIGraphicsGetCurrentContext()]; //[UIView setAnimationCurve:UIViewAnimationCurveEaseInOut]; //InOut 表示进入和出去时都启动动画 //[UIView setAnimationWillStartSelector:@selector(hiddenFoucsView)]; [UIView setAnimationDidStopSelector:@selector(hiddenFocusAnimation)]; [UIView setAnimationDuration:0.5f];//动画时间 self.focusView.transform = CGAffineTransformIdentity;//先让要显示的view最小直至消失 [UIView commitAnimations]; //启动动画 //相反如果想要从小到大的显示效果，则将比例调换 }- (void)hiddenFocusAnimation{ [UIView beginAnimations:nil context:UIGraphicsGetCurrentContext()]; //NSDate *DATE = [NSDate date]; //[UIView setAnimationStartDate:[NSDate date]]; [UIView setAnimationDelay:3]; self.focusView.alpha = 0; [UIView setAnimationDuration:0.5f];//动画时间 [UIView commitAnimations]; }- (void)hiddenFoucsView{ self.focusView.alpha = !self.focusView.alpha;} 写在最后 第一次自定义一个相机，代码写的可能不太好理解。 这个项目在码云的git库上有，地址为https://git.oschina.net/LiynXu/PhotoDemo.git。 如果有任何意见或者建议，或者发现bug(应该是有的),请移步值git库下给予指导，3Q。","link":"/2017/08/18/ios-zi-ding-yi-xiang-ji-de-shi-xian/"},{"title":"iOS--富文本推送UNNotificationExtension基础篇","text":"本文主要讲述如何集成富文本推送的相关扩展，另外还会有文章来详细展开 简介本地推送和远程推送同时都可支持附带Media Attachments。不过远程通知需要实现通知服务扩展（UNNotificationServiceExtension），在service extension里面去下载attachment，但是需要注意，service extension会限制下载的时间（30s），并且下载的文件大小也会同样被限制。这里毕竟是一个推送，而不是把所有的内容都推送给用户。所以你应该去推送一些缩小比例之后的版本。比如图片，推送里面附带缩略图，当用户打开app之后，再去下载完整的高清图。视频就附带视频的关键帧或者开头的几秒，当用户打开app之后再去下载完整视频。attachment支持图片，音频，视频，附件支持的类型及大小 准备工作添加Notification Service Extension在当前工程项目中添加新的Target–&gt; Notification Service先在Xcode 打开你的工程，File–&gt;New–&gt;Target然后添加这个Notification Service Extension： 添加Notification Content Extension在当前工程项目中添加新的Target–&gt; Notification Content先在Xcode 打开你的工程，File–&gt;New–&gt;Target然后添加这个Notification Content Extension： 添加扩展完成这样你的项目中就会有两个Extension Target 设置ServiceExtension Info.plist 添加http协议支持，没错，这里是支持http协议的，不像其他文章说的不支持 ContentExtension Info.plist 设置可以改变 如果不想使用故事版把NSExtensionMainStoryboard替换为NSExtensionPrincipalClass（我这里已经） ServiceExtension基本设置 当前Target的BundleID根据项目主Target的BundleID自动生成 格式”项目主Target的BundleID.-当前Target名称” 例如当前项目BundleID为 com.apple.NotificationDemo，ServiceExtension的名字是NotificationService 那么ServiceExtension的BundleID就是com.apple.NotificationDemo.-NotificationService Automatically manages signing 官方建议勾选 Deployment Target 必须设置为10.0以上，不能设置为10.0以下 ContentExtension基本设置 当前Target的BundleID根据项目主Target的BundleID自动生成 格式”项目主Target的BundleID.-当前Target名称” 例如当前项目BundleID为 com.apple.NotificationDemo，ContentExtension的名字是NotificationContent 那么ServiceExtension的BundleID就是com.apple.NotificationDemo.-NotificationContent Automatically manages signing 官方建议勾选 Deployment Target 必须设置为10.0以上，不能设置为10.0以下 如何使用 首先当前应用需要支持APNS,不支持的自己集成去吧服务器向设备发送通知这个通知消息的格式是有要求的，有以下几点需要注意： aps字段必须要有，不然收不到通知 aps字段下alert字段必须要有，不然也收不到通知 alert字段的值是字符串的时候，不可为空，不然的话你虽然收的到通知，但是是手机除了震动或者声音，没有任何提示 alert字段的值是字典的时候，下面这三个字段必须要有一个，不然和上面一样。就是一句话alert的值必须是可以使用的 mutable-content字段值最好是1，目前没见过其他值 如果你想在iOS10上展示位富文本的推送格式，category字段必须带，值必须在info.plist文件中能找的到的 1234567891011121314 { &quot;aps&quot;:{ &quot;alert&quot; : { &quot;title&quot; : &quot;iOS远程消息主标题！-title&quot;, &quot;subtitle&quot; : &quot;iOS远程消息副标题！-Subtitle&quot;, &quot;body&quot; : &quot;longge -body&quot; }, &quot;sound&quot; : &quot;default&quot;, &quot;badge&quot; : &quot;1&quot;, &quot;mutable-content&quot; : &quot;1&quot;, &quot;category&quot; : &quot;Image_Category&quot;, }, &quot;image&quot; : &quot;http://ot260qjni.bkt.clouddn.com/testOne.jpeg&quot;} 上面的测试图片好像不能用了（具体能不能用你们最好测试一下，直接浏览器打开能看到就可以用），我也不知道为啥 你们可以自己去找找先关的图床。","link":"/2017/07/14/ios-unnotificationextension/"},{"title":"macOS--Cocoapods的安装","text":"重新配置gem源替换1gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/ 查看1gem sources -l 请确保只有一个gem源—“https://gems.ruby-china.org/” 123*** CURRENT SOURCES ***https://gems.ruby-china.org/","link":"/2017/07/14/macos-cocoapods-de-an-zhuang/"},{"title":"macOS--制作Mac引导盘","text":"如何制作Mac引导盘制作mac的引导盘方法不止这一种，请严格按照要求来操作，出毛病我是不负责的哦。 准备工作 8GB U盘一个（这个是容量下限，最低8GB，最好是USB3.0或者以上） 一个正常使用的macOS 下载原版系统 (已下载可以忽略) 打开AppStore 看AppStore窗口右侧 macOS ······ 点击 下载 等（这个看网速的） 制作引导盘【注意】每个输入都和之前的一句隔着一个 空格 打开终端（terminal） 输入 “sudo” 1sudo 打开Finder（新版系统叫访达） 进入应用程序 点击刚刚下载的系统 右键–显示包内容 找到路径**”Contents/Resources/createinstallmedia”**，直接拖至终端,然后代码应该是下面这种 123sudo /Applications/Install\\ macOS\\ High\\ Sierra.app/Contents/Resources/createinstallmedia 注意 sudo 后有 空格 接着输入以下代码 12--volume 语句现在是这样的 123sudo /Applications/Install\\ macOS\\ High\\ Sierra.app/Contents/Resources/createinstallmedia --volume 然后输入你的U盘盘符 123/Volumes/macOS 语句现在是这样的 123sudo /Applications/Install\\ macOS\\ High\\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/macOS 下一步 123--applicationpath 语句现在是这样的 123sudo /Applications/Install\\ macOS\\ High\\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/macOS --applicationpath 下一步 直接把应用程序内的“安装macOS High Sierra.app”拖进终端 语句现在是这样的 123sudo /Applications/Install\\ macOS\\ High\\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/macOS --applicationpath /Applications/Install\\ macOS\\ High\\ Sierra.app 下一步 123--nointeraction 语句现在是这样的 123sudo /Applications/Install\\ macOS\\ High\\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/macOS --applicationpath /Applications/Install\\ macOS\\ High\\ Sierra.app --nointeraction 回车 （提示输入密码） 123Password: 输入管理员密码 回车 正在格式化磁盘 123Erasing Disk: 0%... 10%... 20%... 30%...100%... 正在拷贝安装器文件 123Copying installer files to disk... 这个时候你就可以看到你的U盘名称变了，而且里面多了一个系统，不过这个时候并没有完成 大概需要等待5-10分钟，这个时间长短主要取决于你U盘的写入速率 当显示下面信息是就代表制作完成 1234567Copy complete.Making disk bootable...Copying boot files...Copy complete.Done.","link":"/2018/04/07/macos-make-boot-usb-disk-for-mac/"},{"title":"macOS--苹果笔记本安装Win","text":"Mac–苹果笔记本安装Win(价值200块)为什么说是价值200块呢？ 是因为你拿着你的mac去任何一个电脑店让老板给您装Windows系统，应该会找你要200。 另外本文主要讲述的Windows系统为最新版的Win10 1709版本。 1、因为他们都觉得买得起mac的不差这200块钱。 2、还有一个原因就是因为mac贵，所以我提供的服务也贵。 3、以上两条都是为了坑点钱，其实给mac装Win系统很简单。 比我给windows装mac简单多了。 首先下载一个Windows的ISO镜像文件如果不会参看如何下载Windows系统 使用bootcamp把系统写入到U盘 请注意，下载好的系统最好放在mac上 这里你需要一个最小8GB的U盘，里面要是空的，因为要格式化，有数据的注意备份。 然后插U盘到MAC上。 打开bootcamp(新版系统叫 启动转换助理 ) 继续 勾选三个钩（win7第一个可以不钩） 继续 选择你刚才下载好的ISO系统文件 继续 等 分区，大小可以用鼠标挪动 重启就开始安装了 安装Windows具体步骤参看【UEFI引导安装Win10】 注意 选择安装盘的这一步具体操作如下： 选择带有bootcamp的分区，应该是第三个 或者 第四个（选择完成之后下方会有警告提示：不能安装到当前分区。。。。。。） 然后点击下方格式化（请确认上一步硬盘是否选错） 格式化之后，第一步的警告提示就应该消失了 下一步 其他步骤基本无异 再次重启进入Windows之后，打开U盘中的bootcamp.exe安装上去。这个文件是苹果电脑的驱动支持软件，不装的话估计你连网都没有哦。 是不是很简单完！","link":"/2018/03/11/macos-ping-guo-bi-ji-ben-an-zhuang-win/"},{"title":"Windows--远程桌面账号密码输入正确却显示凭据失败","text":"Windows–远程桌面账号密码输入正确却显示凭据失败Windows A电脑 通过自带的远程桌面连接 Windows B电脑 A电脑：客户端 B电脑：服务器 一般来说客户端不需要什么操作 下面来说一下服务器端 第一步：Win+R 第二步：输入gpedit.msc 然后回车 进入计算机策略配置 依次点开“计算机配置”→“Window设置”→“安全设置”→“本地策略”→“安全选项” 找到“网络访问：本地账户的共享和安全模型” 按下图更改为“经典-对本地用户进行身份验证，不改变其本来身份”","link":"/2021/10/11/windows-remotedestopone/"},{"title":"iOS--AES加密","text":"密码学中的高级加密标准（Advanced Encryption Standard，AES），又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。加密代码都在这里 AES加密方法 1234567891011121314151617181920212223242526272829303132333435363738/** * AES加密 * aesKey 加密Key */+(NSData *)AESParmEncryptWithKey:(NSString *)AES_Key andEncryptData:(NSData *)encryptData //加密{ NSString * kInitVector = [AES_Key copy]; //16位偏移，CBC模式才有 NSData *initVector = [kInitVector dataUsingEncoding:NSUTF8StringEncoding]; //公钥 char keyPtr[kCCKeySizeAES128+1]; memset(keyPtr, 0, sizeof(keyPtr)); [AES_Key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding]; //数据长度 NSUInteger dataLength = encryptData.length; //加密输出缓冲区大小 size_t bufferSize = dataLength + kCCBlockSizeAES128; //加密输出缓冲区 void *buffer = malloc(bufferSize); //实际输出大小 size_t numBytesEncrypted = 0; CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt,//kCCEncrypt 代表加密 kCCDecrypt代表解密 kCCAlgorithmAES,//加密算法 kCCOptionPKCS7Padding,//CBC -&gt; PKCS7Padding，ECB -&gt; kCCOptionPKCS7Padding|kCCOptionECBMode keyPtr, kCCBlockSizeAES128,//密钥长度128 initVector.bytes,//偏移字符串, ECB模式传NULL encryptData.bytes,//编码内容 dataLength, buffer, bufferSize, &amp;numBytesEncrypted); if (cryptStatus == kCCSuccess) { return [NSData dataWithBytesNoCopy:buffer length:numBytesEncrypted]; } free(buffer); return nil;} 12345678910111213141516171819202122/** * AES加密 * aesKey 加密Key */+ (NSString *)AES_EncryptWithKey:(NSString *)AES_Key andEncryptText:(NSString *)encryptText{ AES_Key = [AESUtils checkAESKey:AES_Key]; const char *cstr = [encryptText cStringUsingEncoding:NSUTF8StringEncoding]; NSData *data = [NSData dataWithBytes:cstr length:encryptText.length]; //对数据进行加密 NSData *result = [AESUtils AESParmEncryptWithKey:AES_Key andEncryptData:data]; //转换为2进制字符串 if (result &amp;&amp; result.length &gt; 0) { Byte *datas = (Byte*)[result bytes]; NSMutableString *output = [NSMutableString stringWithCapacity:result.length * 2]; for(int i = 0; i &lt; result.length; i++){ [output appendFormat:@&quot;%02x&quot;, datas[i]]; } return output; } return nil;} AES解密方法 12345678910111213141516171819202122232425262728293031323334353637/** * AES解密 * aesKey 加密Key */+ (NSData *)AESParmDecryptWithKey:(NSString *)AES_Key andDecryptData:(NSData *)decryptData //解密{ NSString * kInitVector = [AES_Key copy]; //16位偏移，CBC模式才有 NSData *initVector = [kInitVector dataUsingEncoding:NSUTF8StringEncoding]; //公钥 char keyPtr[kCCKeySizeAES128+1]; memset(keyPtr, 0, sizeof(keyPtr)); [AES_Key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding]; //数据长度 NSUInteger dataLength = decryptData.length; //加密输出缓冲区大小 size_t bufferSize = dataLength + kCCBlockSizeAES128; //加密输出缓冲区 void *buffer = malloc(bufferSize); //实际输出大小 size_t numBytesDecrypted = 0; CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt,//kCCEncrypt 代表加密 kCCDecrypt代表解密 kCCAlgorithmAES,//加密算法 kCCOptionPKCS7Padding,//CBC -&gt; PKCS7Padding，ECB -&gt; kCCOptionPKCS7Padding|kCCOptionECBMode keyPtr, kCCBlockSizeAES128,//密钥长度128 initVector.bytes,//偏移字符串,, ECB模式传NULL decryptData.bytes,//编码内容 dataLength, buffer, bufferSize, &amp;numBytesDecrypted); if (cryptStatus == kCCSuccess) { return [NSData dataWithBytesNoCopy:buffer length:numBytesDecrypted]; } free(buffer); return nil;} 1234567891011121314151617181920212223242526/** * AES解密 * aesKey 加密Key */+ (NSString *)AES_DecryptWithKey:(NSString *)AES_Key andDecryptText:(NSString *)decryptText{ AES_Key = [AESUtils checkAESKey:AES_Key]; //转换为2进制Data NSMutableData *data = [NSMutableData dataWithCapacity:decryptText.length / 2]; unsigned char whole_byte; char byte_chars[3] = {'\\0','\\0','\\0'}; int i; for (i=0; i &lt; [decryptText length] / 2; i++) { byte_chars[0] = [decryptText characterAtIndex:i*2]; byte_chars[1] = [decryptText characterAtIndex:i*2+1]; whole_byte = strtol(byte_chars, NULL, 16); [data appendBytes:&amp;whole_byte length:1]; } //对数据进行解密 NSData* result = [AESUtils AESParmDecryptWithKey:AES_Key andDecryptData:data]; if (result &amp;&amp; result.length &gt; 0) { return [[NSString alloc] initWithData:result encoding:NSUTF8StringEncoding]; } return nil;} 123456789101112131415/** * 加密key检查 * aesKey 加密Key */+ (NSString *)checkAESKey:(NSString *)AES_Key{ if (AES_Key.length &lt; 16) { NSMutableArray *array = [NSMutableArray arrayWithArray:@[AES_Key]]; while (array.count &lt;= 16 - AES_Key.length) { [array insertObject:@&quot;0&quot; atIndex:0]; } AES_Key = [array componentsJoinedByString:@&quot;&quot;]; } return AES_Key;} Demo地址Demo如有错误请指出。","link":"/2021/07/29/ios-aes-encrypt/"},{"title":"iOS--浅谈生成一个单例","text":"浅谈生成一个单例单例作为非常常用的一个设计模式来说，是每个Coder必备的技能之一，但是还有很多人可能写了个假单例，就是我换种实例化方法可能就生成了一个新的对象。 1、为什么要生成一个单例对象 为了确保在整个应用期间只有一个实例，以达到用户的特定的使用目的。 对于频繁使用的对象，可以把多次创建对象所花费的时间节省下来，提高运行效率。 如果对象所占用的空间大，那么就可以节省大量不必要的空间，降了内存压力。 2、生成单例需要注意的问题 不同实例化方法可能返回不同的对象 3、如何生成一个单例首先在当前类文件中声明一个全局静态对象 123@implementation TestObjectClassstatic TestObjectClass *_testClass = nil; 写一个类方法，初始化全局静态对象 123456+ (instancetype)shareObject{ if (_testClass == nil) { _testClass = [[super alloc]init]; } return _testClass;} 重写allocWithZone方法，拦截alloc方法，防止生成新对象（使用synchronized，并优化同步锁） 12345678910+ (instancetype)allocWithZone:(struct _NSZone *)zone { if (_testClass == nil) { @synchronized (self) { if (_testClass == nil) { _testClass = [super allocWithZone:zone]; } } } return _testClass;} 重写allocWithZone方法，拦截alloc方法，防止生成新对象（使用dispatch_once） 12345678910+ (instancetype)allocWithZone:(struct _NSZone *)zone { static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ if (_testClass == nil) { _testClass = [super allocWithZone:zone]; } }); return _testClass;} 重写copyWithZone方法，拦截copy方法，防止生成新对象 123- (id)copyWithZone:(nullable NSZone *)zone { return _testClass;} 重写mutableCopyWithZone方法，拦截mutableCopy方法，防止生成新对象 123- (id)mutableCopyWithZone:(nullable NSZone *)zone { return _testClass;} 如有纰漏请多多指教。 简书：https://www.jianshu.com/p/03eb4f2203bdCSDN：https://blog.csdn.net/ZuoWeiXiaoDuZuoZuo/article/details/116001644","link":"/2021/04/22/ios-qian-tan-sheng-cheng-yi-ge-dan-li/"},{"title":"macOS--cocoapodsPackager编译动态库","text":"cocoapods-packager编译动态库失败的解决由于近期在研究私有库打包，发现此问题。 起因一开始运行此段代码pod package *******.podspec --force --no-mangle毫无问题。然后就开始尝试生成一个动态库，于是加上了--dynamic，此时出现了下面一大串代码。 12345678910111213 CocoaPods : 1.9.3 Ruby : ruby 2.6.3p62 (2019-04-16 revision 67580) [universal.x86_64-darwin19] RubyGems : 3.0.3 Host : Mac OS X 10.15 (19A582a) Xcode : 11.3.1 (11C504) Git : git version 2.21.1 (Apple Git-122.3)Ruby lib dir : /System/Library/Frameworks/Ruby.framework/Versions/2.6/usr/libRepositories : ARSpecRepo - git - git@gitlab.allride-ai.cn:infra/ios-common.git @ b1f3805d2a766c9509bde74f4574270917dce669 cocoa-local - file system master - git - https://github.com/CocoaPods/Specs.git @ 163b8a8c3e6980b42c623bc76f6b136f8c68d19c trunk - CDN - https://cdn.cocoapods.org/ 12345678cocoapods-art : 1.0.4cocoapods-deintegrate : 1.0.4cocoapods-packager : 1.5.0cocoapods-plugins : 1.0.0cocoapods-search : 1.0.0cocoapods-stats : 1.1.0cocoapods-trunk : 1.4.1cocoapods-try : 1.1.0 123456789101112131415ArgumentError - wrong number of arguments (given 3, expected 7..10)/usr/local/lib/ruby/gems/2.6.0/gems/cocoapods-1.9.3/lib/cocoapods/target/pod_target.rb:137:in `initialize'/usr/local/lib/ruby/gems/2.6.0/gems/cocoapods-packager-1.5.0/lib/cocoapods-packager/pod_utils.rb:161:in `new'/usr/local/lib/ruby/gems/2.6.0/gems/cocoapods-packager-1.5.0/lib/cocoapods-packager/pod_utils.rb:161:in `build_dynamic_target'/usr/local/lib/ruby/gems/2.6.0/gems/cocoapods-packager-1.5.0/lib/cocoapods-packager/pod_utils.rb:131:in `install_dynamic_pod'/usr/local/lib/ruby/gems/2.6.0/gems/cocoapods-packager-1.5.0/lib/pod/command/package.rb:83:in `build_in_sandbox'/usr/local/lib/ruby/gems/2.6.0/gems/cocoapods-packager-1.5.0/lib/pod/command/package.rb:100:in `block in build_package'/usr/local/lib/ruby/gems/2.6.0/gems/cocoapods-packager-1.5.0/lib/pod/command/package.rb:99:in `each'/usr/local/lib/ruby/gems/2.6.0/gems/cocoapods-packager-1.5.0/lib/pod/command/package.rb:99:in `build_package'/usr/local/lib/ruby/gems/2.6.0/gems/cocoapods-packager-1.5.0/lib/pod/command/package.rb:66:in `run'/usr/local/lib/ruby/gems/2.6.0/gems/claide-1.0.3/lib/claide/command.rb:334:in `run'/usr/local/lib/ruby/gems/2.6.0/gems/cocoapods-1.9.3/lib/cocoapods/command.rb:52:in `run'/usr/local/lib/ruby/gems/2.6.0/gems/cocoapods-1.9.3/bin/pod:55:in `&lt;top (required)&gt;'/usr/local/lib/ruby/gems/2.6.0/bin/pod:24:in `load'/usr/local/lib/ruby/gems/2.6.0/bin/pod:24:in `&lt;main&gt;' 然后同事的电脑可以正常打包，我查看了他的电脑环境，发现ruby是2.3.7，我以为是此处发生问题，于是开始了降级Ruby，然而。。。。。。事情并没有这么简单。 我以为降级就会成功因为我的系统已经更新到了10.15 Catalina，默认的Ruby版本就是2.6.3。 降级Ruby就得降级系统，但是降级系统到10.14总是不成功，总是提示 更新固件时发生错误。退出安装器以重新启动电脑，然后再次尝试。 然后我想起来这可能是联网验证的结果，于是我关闭wifi，调整时间到15年，然而。。。。。。。。。。还是会出现 更新固件时发生错误。退出安装器以重新启动电脑，然后再次尝试。 看来断了wifi还是没有用，最后发现安装过程中会重启几次，重启的时候wifi会自动开启然后连上我的路由器，于是我就把路由器的网线拔了，wifi让你连有网算我输！ 然后。。。。。。。。居然成功了。哎。我太难了。 进入系统后一顿初始化， * 下载Xcode * 安装cocoapods * 安装cocoapods-packager * 拉代码 等啊等，个把小时搞定这些事。 package *******.podspec --force --dynamic --no-mangle```打包ing123456789101112131415161718192021然后。。。。。。啊。。。。。。。还是报错啊！！！！！！！！！！！和之前除了工具版本不一致。其他基本一模一样。看来不是Ruby版本的问题。### 刚才方向不对，再来于是我就想是不是cocoapods-packager自己的锅。迅速去Github上的cocoapods-packager项目看issues。发现了一个问题： [**issues#257** Fail to build a pod into dynamic framework](https://github.com/CocoaPods/cocoapods-packager/issues/257)细心的我发现了一句话```Look at the master branch, the calling to Pod::PodTarget.new has changed.```我马不停蹄的查看了cocoapods-packager本机的代码，目录在这```cocoapods-packager/lib/cocoapods-packager/pod_utils.rb``` file_accessors = create_file_accessors(static_target, dynamic_sandbox) archs = [] dynamic_target = Pod::PodTarget.new(dynamic_sandbox, true, static_target.user_build_configurations, archs, platform, static_target.specs, static_target.target_definitions, file_accessors) dynamic_target end 123Githu上现存的master分支 dynamic_target = Pod::PodTarget.new(static_target.specs, static_target.target_definitions, dynamic_sandbox) dynamic_target.host_requires_frameworks = true dynamic_target.user_build_configurations = static_target.user_build_configurations dynamic_target end 对比发现这一段代码不一样，虽然我看不懂、、、、、、我是真的不会ruby。 问题到这里差不多就解决了一大半，因为我已经找到了原因。 ### 发现解决方法 这个时候我```sudo gem uninstall cocoapods-packager```，卸载掉cocoapods-packager。 开始源码安装cocoapods-packager。 首先拉取源代码 ```git clone https://github.com/CocoaPods/cocoapods-packager.git``` 完毕之后进入目录 ```cocoapods-packager``` * 查看bundler是否安装```gem list bundler ```(没有出现bundler的话就```gem install bundler```) * 安装依赖项```bundler install``` * 执行```sudo gem build cocoapods-packager.gemspec ```语句后会生成cocoapods-packager-1.5.0.gem文件 * 将生成的cocoapods-packager-1.5.0.gem 文件执行本地安装```sudo gem install cocoapods-packager-1.5.0.gem -l``` 为了更稳我重启了终端。 接着 ```pod package *******.podspec --force --dynamic --no-mangle```打包ing 出现了 ```Building dynamic framework **** (****) with configuration Release``` 成功了。。。。。。 太难了。 此时我的编译环境是 * macOS 10.14.6 * Xcode 11.3 下面就想，新系统上行不行的通，现在验证之前又不能升级。。。。 emmmm。。。。。 我还有个blackApple。 ### 最新编译环境验证 另外一个设备的编译环境是 * macOS 10.15.7 * Xcode 12.0.1 都是最新的。 卸载掉gem安装的cocoapods-packager。 源码安装cocoapods-packager。 接着 ```pod package *******.podspec --force --dynamic --no-mangle```打包ing 出现了 ```Building dynamic framework **** (****) with configuration Release``` 哎。又成功了。Happy。。。。 马上把我笔记本的东西都升级了。美滋滋。。。 特此记录。。。。。。。。。。。 ### 完","link":"/2020/09/28/macos-cocoapodspackager-bian-yi-dong-tai-ku/"},{"title":"iOS--引用子类对象作为属性","text":"某位同事编码。一个类引用一个子类对象作为属性。 123456#import &lt;Foundation/Foundation.h&gt;#import &quot;CycleFindTestClas.h&quot;@interface TestObjectClass : NSObject@property (nonatomic, strong) CycleFindTestClas *cycle;@end 123456789#import &quot;TestObjectClass.h&quot;// 此声明CycleFindTestClas类的代码会被编译器报错//（Cannot find interface declaration for 'TestObjectClass', superclass of 'CycleFindTestClas'）@interface CycleFindTestClas : TestObjectClass@end 以下为本人猜测，如果纰漏请多多指教。 究其原因，其实很简单。编译器查找某个类无非是两种。 通过文件查找 #import “ClassName.h” 通过前置声明 @class name; 上述代码没有前置声明，那么查找TestObjectClass类必然要通过文件，于是开始了下面的流程 编译器查到了TestObjectClass.h文件 然后开始从上到下遍历TestObjectClass.h代码 发现Foundation.h内没有，于是查找下一行CycleFindTestClas.h 发现CycleFindTestClas.h有TestObjectClass，但是这个TestObjectClass是个父类，那么继续开始查找TestObjectClass的声明 编译器查到了TestObjectClass.h文件 然后开始从上到下遍历TestObjectClass.h代码 ······························ 是不是循环了 所以根本就查找不到 TestObjectClass的声明@interface TestObjectClass : NSObject。所以我们在日常编码中 .h 内尽量不再引用其他自定义类的 .h 文件，尽量使用前置声明某个类. 12345@class CycleFindTestClas;#import &lt;Foundation/Foundation.h&gt;@interface TestObjectClass : NSObject@property (nonatomic, strong) CycleFindTestClas *cycle;@end","link":"/2021/04/22/ios-yin-yong-zi-lei-dui-xiang-zuo-wei-shu-xing/"},{"title":"Xcode下载地址大全","text":"Xcode下载——绝对的官方地址下载方式简单粗暴：第一种、点击Xcode版本名称稍等几秒即可开始下载另一种、右键复制链接地址，打开下载软件，新建任务把复制的链接粘贴在地址输入框即可开始下载本文中涉及到的下载地址均为苹果官方下载地址 Xcode 2Xcode_2.3.dmg 915.0MBXcode_2.4.dmg 938.2MBXcode_2.4.1.dmg 923.2MB Xcode 3Xcode_3.0.dmg 1.1GBXcode_3.2.dmg 748.7MBXcode_3.2.3_and_ios_sdk_4.0.1.dmg 2.2GBXcode_3.2.3_and_ios_sdk_4.0.2.dmg 2.4GBXcode_3.2.4_and_ios_sdk_4.1.dmg 2.9GBXcode_3.2.5_and_ios_sdk_4.2.dmg 3.5GBXcode_3.2.6_and_ios_sdk_4.3.dmg 4.1GB Xcode 4Xcode_4_and_ios_sdk_4.3.dmg 4.2GBXcode_4.0.1_and_ios_sdk_4.3.dmg 4.2GBXcode_4.0.2_and_ios_sdk_4.3.dmg 4.2GBXcode_4.1_for_snow_leopard.dmg 4.3GBXcode_4.1_for_lion.dmg 2.9GBXcode_4.2_for_snow_leopard.dmg 1.6GBXcode_4.2_for_lion.dmg 1.6GBXcode_4.2.1_for_lion.dmg 1.6GBXcode_4.3_for_lion.dmg 1.4GBXcode_4.3.1_for_lion.dmg 1.4GBXcode_4.3.2_for_lion.dmg 1.8GBXcode_4.3.3_for_lion.dmg 1.8GBXcode_4.4.dmg 1.8GBXcode_4.4.1.dmg 1.8GBXcode_4.5.dmg 1.5GBXcode_4.5.1.dmg 1.5GBXcode_4.5.2.dmg 1.5GBXcode_4.6.dmg 1.6GBXcode_4.6.1.dmg 1.6GBXcode_4.6.2.dmg 1.6GBXcode_4.6.3.dmg 1.6GB Xcode 5Xcode_5.dmg 1.9GBXcode_5.0.1.dmg 2.0GBXcode_5.0.2.dmg 2.0GBXcode_5.1.dmg 2.1GBXcode_5.1.1.dmg 2.1GB Xcode 6Xcode_6.0.1.dmg 2.1GBXcode_6.1.dmg 2.5GBXcode_6.1.1.dmg 2.5GBXcode_6.2.dmg 2.5GBXcode_6.3.dmg 2.5GBXcode_6.3.1.dmg 2.5GBXcode_6.3.2.dmg 2.5GBXcode_6.4.dmg 2.6GB Xcode 7Xcode_7.dmg 3.5GBXcode_7.0.1.dmg 3.5GBXcode_7.1.dmg 4.2GBXcode_7.1.1.dmg 4.2GBXcode_7.2.dmg 4.4GBXcode_7.2.1.dmg 4.4GBXcode_7.3.dmg 4.8GBXcode_7.3.1.dmg 4.8GB Xcode 8Xcode_8.xip 4.1GBXcode_8.1.xip 4.1GBXcode_8.2.xip 4.2GBXcode_8.2.1.xip 4.2GBXcode_8.3.xip 4.1GBXcode_8.3.1.xip 4.1GBXcode_8.3.2.xip4.1GB","link":"/2017/07/14/macos-xcode-xia-zai-di-zhi/"},{"title":"iOS--浅谈消息转发机制","text":"iOS–浅谈消息转发机制相信大家对这句话unrecognized selector sent to instance 0x*********一点都不陌生吧。 下面就来简单说一下 拯救即将崩溃代码–iOS的消息转发 动态绑定引发因为OC是一个动态运行时语言，其中之一的特性就是动态绑定。 关于动态绑定，苹果官网的给的解释为：（determining the method to invoke at runtime）。 简单点来说就是：程序直到执行时才能确定实际要调用的方法。 这样就会造成一个问题，我可以向一个实例发送一个消息，让它执行一个不属于自己的方法。这个时候就会出现unrecognized selector sent to instance。 如果发生这种情况，那么我们就可以应用消息转发来解决这个问题。把这个不属于自己的方法变成属于自己的方法，或者找一个有这个方法的实例来执行这个方法。在程序抛出这个错误之前我们有三次可以修正这个错误的机会。 拯救即将崩溃代码第一步 方法解析处理阶段 | 动态方法决议 该方法内可为当前类动态添加方法。 将sel的方法实现指向一个已存在的方法 123456789101112131415161718192021/** 方法解析处理阶段 | 动态方法决议 该方法内可为当前类动态添加方法。 将sel的方法实现指向一个已存在的方法 */+ (BOOL)resolveInstanceMethod:(SEL)sel{ NSString *selectorString = NSStringFromSelector(sel); printf(&quot;%s %s\\n&quot;, __func__, selectorString.UTF8String); // 根据 sel 得到 class 的实例方法 Method method = class_getInstanceMethod([self class], @selector(dynamic_method)); // 根据 sel 得到 class 的函数指针 IMP method_imp = class_getMethodImplementation([self class], @selector(dynamic_method)); // 给找不到实现的sel添加实现 BOOL ret = class_addMethod([self class], sel, method_imp, method_getTypeEncoding(method)); printf(&quot;%s\\n&quot;, ret?&quot;交换添加成功&quot;:&quot;交换添加失败&quot;); // 返回结果不影响流程 return YES;} 为什么说上面resolveInstanceMethod的返回结果不影响实际流程呢，看下面runtime的源码。我们可以看到 123456789101112131415161718192021222324252627282930313233343536373839404142/************************************************************************ resolveInstanceMethod* Call +resolveInstanceMethod, looking for a method to be added to class cls.* cls may be a metaclass or a non-meta class.* Does not check if the method already exists.**********************************************************************/static void resolveInstanceMethod(id inst, SEL sel, Class cls){ runtimeLock.assertUnlocked(); ASSERT(cls-&gt;isRealized()); SEL resolve_sel = @selector(resolveInstanceMethod:); if (!lookUpImpOrNilTryCache(cls, resolve_sel, cls-&gt;ISA(/*authenticated*/true))) { // Resolver not implemented. return; } BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend; // 执行了resolveInstanceMethod方法，得到了一个结果resolved bool resolved = msg(cls, resolve_sel, sel); // Cache the result (good or bad) so the resolver doesn't fire next time. // +resolveInstanceMethod adds to self a.k.a. cls IMP imp = lookUpImpOrNilTryCache(inst, sel, cls); // resolved只影响了信息的输出 if (resolved &amp;&amp; PrintResolving) { if (imp) { _objc_inform(&quot;RESOLVE: method %c[%s %s] &quot; &quot;dynamically resolved to %p&quot;, cls-&gt;isMetaClass() ? '+' : '-', cls-&gt;nameForLogging(), sel_getName(sel), imp); } else { // Method resolver didn't add anything? _objc_inform(&quot;RESOLVE: +[%s resolveInstanceMethod:%s] returned YES&quot; &quot;, but no new implementation of %c[%s %s] was found&quot;, cls-&gt;nameForLogging(), sel_getName(sel), cls-&gt;isMetaClass() ? '+' : '-', cls-&gt;nameForLogging(), sel_getName(sel)); } }} 第二步 快速转发阶段 | 快速查找 上一步未解决问题时触发。 返回一个能响应aSelector的实例，即将aSelector转发给另外的类。 12345678910111213141516171819/** 快速转发阶段 | 快速查找 上一步未解决问题时触发。 返回一个能响应aSelector的实例，即将aSelector转发给另外的类。 */- (id)forwardingTargetForSelector:(SEL)aSelector{ NSString *selectorString = NSStringFromSelector(aSelector); printf(&quot;%s %s\\n&quot;, __func__, selectorString.UTF8String); if ([selectorString isEqualToString:@&quot;no_imp_method&quot;]) { // 返回一个实现了aSelector函数的实例 // 如果该实例没有实现aSelector，则进入下一步methodSignatureForSelector printf(&quot;%s 转发消息至BackUpClass\\n&quot;,__func__); return [[BackUpClass alloc] init]; } // 返回self或者nil,则说明没有可以响应的目标,则进入下一步methodSignatureForSelector。 return nil;} 第三步 常规转发阶段 | 慢速查找 获得一个方法签名。签名由一个能响应aSelector的实例生成。 有签名则进入消息转发的最后一步forwardInvocation。 123456789101112131415/** 常规转发阶段 | 慢速查找 返回一个方法签名。签名由一个能响应aSelector的实例生成。 */- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector{ NSString *selectorString = NSStringFromSelector(aSelector); printf(&quot;%s %s\\n&quot;, __func__, selectorString.UTF8String); BackUpClass * backUp = [BackUpClass new]; NSMethodSignature * sign = [backUp methodSignatureForSelector:aSelector]; //有签名则进入消息转发的最后一步forwardInvocation return sign;} 也可以什么都不处理，至此本次消息转发结束，程序也不会crash。 12345678910111213/** 将sel转发给一个真正实现了sel的对象 也可以什么都不处理，至此本次消息转发结束，也不会crash。 */- (void)forwardInvocation:(NSInvocation *)anInvocation{ printf(&quot;%s %s\\n&quot;,__func__ , anInvocation.description.UTF8String); // 创建备用消息接收对象 BackUpClass * backUp = [[BackUpClass alloc] init]; printf(&quot;%s 转发消息至BackUpClass\\n&quot;,__func__); [anInvocation invokeWithTarget:backUp];} 写在后面浅谈。可以交流。","link":"/2021/10/18/ios-qian-tan-xiao-xi-zhuan-fa-ji-zhi/"},{"title":"iOS--长截图Demo测试","text":"","link":"/2021/10/19/ios-chang-jie-tu-demo-ce-shi/"},{"title":"iOS--objc-runtime-new源码","text":"源码objc-runtime-new.m 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319132013211322132313241325132613271328132913301331133213331334133513361337133813391340134113421343134413451346134713481349135013511352135313541355135613571358135913601361136213631364136513661367136813691370137113721373137413751376137713781379138013811382138313841385138613871388138913901391139213931394139513961397139813991400140114021403140414051406140714081409141014111412141314141415141614171418141914201421142214231424142514261427142814291430143114321433143414351436143714381439144014411442144314441445144614471448144914501451145214531454145514561457145814591460146114621463146414651466146714681469147014711472147314741475147614771478147914801481148214831484148514861487148814891490149114921493149414951496149714981499150015011502150315041505150615071508150915101511151215131514151515161517151815191520152115221523152415251526152715281529153015311532153315341535153615371538153915401541154215431544154515461547154815491550155115521553155415551556155715581559156015611562156315641565156615671568156915701571157215731574157515761577157815791580158115821583158415851586158715881589159015911592159315941595159615971598159916001601160216031604160516061607160816091610161116121613161416151616161716181619162016211622162316241625162616271628162916301631163216331634163516361637163816391640164116421643164416451646164716481649165016511652165316541655165616571658165916601661166216631664166516661667166816691670167116721673167416751676167716781679168016811682168316841685168616871688168916901691169216931694169516961697169816991700170117021703170417051706170717081709171017111712171317141715171617171718171917201721172217231724172517261727172817291730173117321733173417351736173717381739174017411742174317441745174617471748174917501751175217531754175517561757175817591760176117621763176417651766176717681769177017711772177317741775177617771778177917801781178217831784178517861787178817891790179117921793179417951796179717981799180018011802180318041805180618071808180918101811181218131814181518161817181818191820182118221823182418251826182718281829183018311832183318341835183618371838183918401841184218431844184518461847184818491850185118521853185418551856185718581859186018611862186318641865186618671868186918701871187218731874187518761877187818791880188118821883188418851886188718881889189018911892189318941895189618971898189919001901190219031904190519061907190819091910191119121913191419151916191719181919192019211922192319241925192619271928192919301931193219331934193519361937193819391940194119421943194419451946194719481949195019511952195319541955195619571958195919601961196219631964196519661967196819691970197119721973197419751976197719781979198019811982198319841985198619871988198919901991199219931994199519961997199819992000200120022003200420052006200720082009201020112012201320142015201620172018201920202021202220232024202520262027202820292030203120322033203420352036203720382039204020412042204320442045204620472048204920502051205220532054205520562057205820592060206120622063206420652066206720682069207020712072207320742075207620772078207920802081208220832084208520862087208820892090209120922093209420952096209720982099210021012102210321042105210621072108210921102111211221132114211521162117211821192120212121222123212421252126212721282129213021312132213321342135213621372138213921402141214221432144214521462147214821492150215121522153215421552156215721582159216021612162216321642165216621672168216921702171217221732174217521762177217821792180218121822183218421852186218721882189219021912192219321942195219621972198219922002201220222032204220522062207220822092210221122122213221422152216221722182219222022212222222322242225222622272228222922302231223222332234223522362237223822392240224122422243224422452246224722482249225022512252225322542255225622572258225922602261226222632264226522662267226822692270227122722273227422752276227722782279228022812282228322842285228622872288228922902291229222932294229522962297229822992300230123022303230423052306230723082309231023112312231323142315231623172318231923202321232223232324232523262327232823292330233123322333233423352336233723382339234023412342234323442345234623472348234923502351235223532354235523562357235823592360236123622363236423652366236723682369237023712372237323742375237623772378237923802381238223832384238523862387238823892390239123922393239423952396239723982399240024012402240324042405240624072408240924102411241224132414241524162417241824192420242124222423242424252426242724282429243024312432243324342435243624372438243924402441244224432444244524462447244824492450245124522453245424552456245724582459246024612462246324642465246624672468246924702471247224732474247524762477247824792480248124822483248424852486248724882489249024912492249324942495249624972498249925002501250225032504250525062507250825092510251125122513251425152516251725182519252025212522252325242525252625272528252925302531253225332534253525362537253825392540254125422543254425452546254725482549255025512552255325542555255625572558255925602561256225632564256525662567256825692570257125722573257425752576257725782579258025812582258325842585258625872588258925902591259225932594259525962597259825992600260126022603260426052606260726082609261026112612261326142615261626172618261926202621262226232624262526262627262826292630263126322633263426352636263726382639264026412642264326442645264626472648264926502651265226532654265526562657265826592660266126622663266426652666266726682669267026712672267326742675267626772678267926802681268226832684268526862687268826892690269126922693269426952696269726982699270027012702270327042705270627072708270927102711271227132714271527162717271827192720272127222723272427252726272727282729273027312732273327342735273627372738273927402741274227432744274527462747274827492750275127522753275427552756275727582759276027612762276327642765276627672768276927702771277227732774277527762777277827792780278127822783278427852786278727882789279027912792279327942795279627972798279928002801280228032804280528062807280828092810281128122813281428152816281728182819282028212822282328242825282628272828282928302831283228332834283528362837283828392840284128422843284428452846284728482849285028512852285328542855285628572858285928602861286228632864286528662867286828692870287128722873287428752876287728782879288028812882288328842885288628872888288928902891289228932894289528962897289828992900290129022903290429052906290729082909291029112912291329142915291629172918291929202921292229232924292529262927292829292930293129322933293429352936293729382939294029412942294329442945294629472948294929502951295229532954295529562957295829592960296129622963296429652966296729682969297029712972297329742975297629772978297929802981298229832984298529862987298829892990299129922993299429952996299729982999300030013002300330043005300630073008300930103011301230133014301530163017301830193020302130223023302430253026302730283029303030313032303330343035303630373038303930403041304230433044304530463047304830493050305130523053305430553056305730583059306030613062306330643065306630673068306930703071307230733074307530763077307830793080308130823083308430853086308730883089309030913092309330943095309630973098309931003101310231033104310531063107310831093110311131123113311431153116311731183119312031213122312331243125312631273128312931303131313231333134313531363137313831393140314131423143314431453146314731483149315031513152315331543155315631573158315931603161316231633164316531663167316831693170317131723173317431753176317731783179318031813182318331843185318631873188318931903191319231933194319531963197319831993200320132023203320432053206320732083209321032113212321332143215321632173218321932203221322232233224322532263227322832293230323132323233323432353236323732383239324032413242324332443245324632473248324932503251325232533254325532563257325832593260326132623263326432653266326732683269327032713272327332743275327632773278327932803281328232833284328532863287328832893290329132923293329432953296329732983299330033013302330333043305330633073308330933103311331233133314331533163317331833193320332133223323332433253326332733283329333033313332333333343335333633373338333933403341334233433344334533463347334833493350335133523353335433553356335733583359336033613362336333643365336633673368336933703371337233733374337533763377337833793380338133823383338433853386338733883389339033913392339333943395339633973398339934003401340234033404340534063407340834093410341134123413341434153416341734183419342034213422342334243425342634273428342934303431343234333434343534363437343834393440344134423443344434453446344734483449345034513452345334543455345634573458345934603461346234633464346534663467346834693470347134723473347434753476347734783479348034813482348334843485348634873488348934903491349234933494349534963497349834993500350135023503350435053506350735083509351035113512351335143515351635173518351935203521352235233524352535263527352835293530353135323533353435353536353735383539354035413542354335443545354635473548354935503551355235533554355535563557355835593560356135623563356435653566356735683569357035713572357335743575357635773578357935803581358235833584358535863587358835893590359135923593359435953596359735983599360036013602360336043605360636073608360936103611361236133614361536163617361836193620362136223623362436253626362736283629363036313632363336343635363636373638363936403641364236433644364536463647364836493650365136523653365436553656365736583659366036613662366336643665366636673668366936703671367236733674367536763677367836793680368136823683368436853686368736883689369036913692369336943695369636973698369937003701370237033704370537063707370837093710371137123713371437153716371737183719372037213722372337243725372637273728372937303731373237333734373537363737373837393740374137423743374437453746374737483749375037513752375337543755375637573758375937603761376237633764376537663767376837693770377137723773377437753776377737783779378037813782378337843785378637873788378937903791379237933794379537963797379837993800380138023803380438053806380738083809381038113812381338143815381638173818381938203821382238233824382538263827382838293830383138323833383438353836383738383839384038413842384338443845384638473848384938503851385238533854385538563857385838593860386138623863386438653866386738683869387038713872387338743875387638773878387938803881388238833884388538863887388838893890389138923893389438953896389738983899390039013902390339043905390639073908390939103911391239133914391539163917391839193920392139223923392439253926392739283929393039313932393339343935393639373938393939403941394239433944394539463947394839493950395139523953395439553956395739583959396039613962396339643965396639673968396939703971397239733974397539763977397839793980398139823983398439853986398739883989399039913992399339943995399639973998399940004001400240034004400540064007400840094010401140124013401440154016401740184019402040214022402340244025402640274028402940304031403240334034403540364037403840394040404140424043404440454046404740484049405040514052405340544055405640574058405940604061406240634064406540664067406840694070407140724073407440754076407740784079408040814082408340844085408640874088408940904091409240934094409540964097409840994100410141024103410441054106410741084109411041114112411341144115411641174118411941204121412241234124412541264127412841294130413141324133413441354136413741384139414041414142414341444145414641474148414941504151415241534154415541564157415841594160416141624163416441654166416741684169417041714172417341744175417641774178417941804181418241834184418541864187418841894190419141924193419441954196419741984199420042014202420342044205420642074208420942104211421242134214421542164217421842194220422142224223422442254226422742284229423042314232423342344235423642374238423942404241424242434244424542464247424842494250425142524253425442554256425742584259426042614262426342644265426642674268426942704271427242734274427542764277427842794280428142824283428442854286428742884289429042914292429342944295429642974298429943004301430243034304430543064307430843094310431143124313431443154316431743184319432043214322432343244325432643274328432943304331433243334334433543364337433843394340434143424343434443454346434743484349435043514352435343544355435643574358435943604361436243634364436543664367436843694370437143724373437443754376437743784379438043814382438343844385438643874388438943904391439243934394439543964397439843994400440144024403440444054406440744084409441044114412441344144415441644174418441944204421442244234424442544264427442844294430443144324433443444354436443744384439444044414442444344444445444644474448444944504451445244534454445544564457445844594460446144624463446444654466446744684469447044714472447344744475447644774478447944804481448244834484448544864487448844894490449144924493449444954496449744984499450045014502450345044505450645074508450945104511451245134514451545164517451845194520452145224523452445254526452745284529453045314532453345344535453645374538453945404541454245434544454545464547454845494550455145524553455445554556455745584559456045614562456345644565456645674568456945704571457245734574457545764577457845794580458145824583458445854586458745884589459045914592459345944595459645974598459946004601460246034604460546064607460846094610461146124613461446154616461746184619462046214622462346244625462646274628462946304631463246334634463546364637463846394640464146424643464446454646464746484649465046514652465346544655465646574658465946604661466246634664466546664667466846694670467146724673467446754676467746784679468046814682468346844685468646874688468946904691469246934694469546964697469846994700470147024703470447054706470747084709471047114712471347144715471647174718471947204721472247234724472547264727472847294730473147324733473447354736473747384739474047414742474347444745474647474748474947504751475247534754475547564757475847594760476147624763476447654766476747684769477047714772477347744775477647774778477947804781478247834784478547864787478847894790479147924793479447954796479747984799480048014802480348044805480648074808480948104811481248134814481548164817481848194820482148224823482448254826482748284829483048314832483348344835483648374838483948404841484248434844484548464847484848494850485148524853485448554856485748584859486048614862486348644865486648674868486948704871487248734874487548764877487848794880488148824883488448854886488748884889489048914892489348944895489648974898489949004901490249034904490549064907490849094910491149124913491449154916491749184919492049214922492349244925492649274928492949304931493249334934493549364937493849394940494149424943494449454946494749484949495049514952495349544955495649574958495949604961496249634964496549664967496849694970497149724973497449754976497749784979498049814982498349844985498649874988498949904991499249934994499549964997499849995000500150025003500450055006500750085009501050115012501350145015501650175018501950205021502250235024502550265027502850295030503150325033503450355036503750385039504050415042504350445045504650475048504950505051505250535054505550565057505850595060506150625063506450655066506750685069507050715072507350745075507650775078507950805081508250835084508550865087508850895090509150925093509450955096509750985099510051015102510351045105510651075108510951105111511251135114511551165117511851195120512151225123512451255126512751285129513051315132513351345135513651375138513951405141514251435144514551465147514851495150515151525153515451555156515751585159516051615162516351645165516651675168516951705171517251735174517551765177517851795180518151825183518451855186518751885189519051915192519351945195519651975198519952005201520252035204520552065207520852095210521152125213521452155216521752185219522052215222522352245225522652275228522952305231523252335234523552365237523852395240524152425243524452455246524752485249525052515252525352545255525652575258525952605261526252635264526552665267526852695270527152725273527452755276527752785279528052815282528352845285528652875288528952905291529252935294529552965297529852995300530153025303530453055306530753085309531053115312531353145315531653175318531953205321532253235324532553265327532853295330533153325333533453355336533753385339534053415342534353445345534653475348534953505351535253535354535553565357535853595360536153625363536453655366536753685369537053715372537353745375537653775378537953805381538253835384538553865387538853895390539153925393539453955396539753985399540054015402540354045405540654075408540954105411541254135414541554165417541854195420542154225423542454255426542754285429543054315432543354345435543654375438543954405441544254435444544554465447544854495450545154525453545454555456545754585459546054615462546354645465546654675468546954705471547254735474547554765477547854795480548154825483548454855486548754885489549054915492549354945495549654975498549955005501550255035504550555065507550855095510551155125513551455155516551755185519552055215522552355245525552655275528552955305531553255335534553555365537553855395540554155425543554455455546554755485549555055515552555355545555555655575558555955605561556255635564556555665567556855695570557155725573557455755576557755785579558055815582558355845585558655875588558955905591559255935594559555965597559855995600560156025603560456055606560756085609561056115612561356145615561656175618561956205621562256235624562556265627562856295630563156325633563456355636563756385639564056415642564356445645564656475648564956505651565256535654565556565657565856595660566156625663566456655666566756685669567056715672567356745675567656775678567956805681568256835684568556865687568856895690569156925693569456955696569756985699570057015702570357045705570657075708570957105711571257135714571557165717571857195720572157225723572457255726572757285729573057315732573357345735573657375738573957405741574257435744574557465747574857495750575157525753575457555756575757585759576057615762576357645765576657675768576957705771577257735774577557765777577857795780578157825783578457855786578757885789579057915792579357945795579657975798579958005801580258035804580558065807580858095810581158125813581458155816581758185819582058215822582358245825582658275828582958305831583258335834583558365837583858395840584158425843584458455846584758485849585058515852585358545855585658575858585958605861586258635864586558665867586858695870587158725873587458755876587758785879588058815882588358845885588658875888588958905891589258935894589558965897589858995900590159025903590459055906590759085909591059115912591359145915591659175918591959205921592259235924592559265927592859295930593159325933593459355936593759385939594059415942594359445945594659475948594959505951595259535954595559565957595859595960596159625963596459655966596759685969597059715972597359745975597659775978597959805981598259835984598559865987598859895990599159925993599459955996599759985999600060016002600360046005600660076008600960106011601260136014601560166017601860196020602160226023602460256026602760286029603060316032603360346035603660376038603960406041604260436044604560466047604860496050605160526053605460556056605760586059606060616062606360646065606660676068606960706071607260736074607560766077607860796080608160826083608460856086608760886089609060916092609360946095609660976098609961006101610261036104610561066107610861096110611161126113611461156116611761186119612061216122612361246125612661276128612961306131613261336134613561366137613861396140614161426143614461456146614761486149615061516152615361546155615661576158615961606161616261636164616561666167616861696170617161726173617461756176617761786179618061816182618361846185618661876188618961906191619261936194619561966197619861996200620162026203620462056206620762086209621062116212621362146215621662176218621962206221622262236224622562266227622862296230623162326233623462356236623762386239624062416242624362446245624662476248624962506251625262536254625562566257625862596260626162626263626462656266626762686269627062716272627362746275627662776278627962806281628262836284628562866287628862896290629162926293629462956296629762986299630063016302630363046305630663076308630963106311631263136314631563166317631863196320632163226323632463256326632763286329633063316332633363346335633663376338633963406341634263436344634563466347634863496350635163526353635463556356635763586359636063616362636363646365636663676368636963706371637263736374637563766377637863796380638163826383638463856386638763886389639063916392639363946395639663976398639964006401640264036404640564066407640864096410641164126413641464156416641764186419642064216422642364246425642664276428642964306431643264336434643564366437643864396440644164426443644464456446644764486449645064516452645364546455645664576458645964606461646264636464646564666467646864696470647164726473647464756476647764786479648064816482648364846485648664876488648964906491649264936494649564966497649864996500650165026503650465056506650765086509651065116512651365146515651665176518651965206521652265236524652565266527652865296530653165326533653465356536653765386539654065416542654365446545654665476548654965506551655265536554655565566557655865596560656165626563656465656566656765686569657065716572657365746575657665776578657965806581658265836584658565866587658865896590659165926593659465956596659765986599660066016602660366046605660666076608660966106611661266136614661566166617661866196620662166226623662466256626662766286629663066316632663366346635663666376638663966406641664266436644664566466647664866496650665166526653665466556656665766586659666066616662666366646665666666676668666966706671667266736674667566766677667866796680668166826683668466856686668766886689669066916692669366946695669666976698669967006701670267036704670567066707670867096710671167126713671467156716671767186719672067216722672367246725672667276728672967306731673267336734673567366737673867396740674167426743674467456746674767486749675067516752675367546755675667576758675967606761676267636764676567666767676867696770677167726773677467756776677767786779678067816782678367846785678667876788678967906791679267936794679567966797679867996800680168026803680468056806680768086809681068116812681368146815681668176818681968206821682268236824682568266827682868296830683168326833683468356836683768386839684068416842684368446845684668476848684968506851685268536854685568566857685868596860686168626863686468656866686768686869687068716872687368746875687668776878687968806881688268836884688568866887688868896890689168926893689468956896689768986899690069016902690369046905690669076908690969106911691269136914691569166917691869196920692169226923692469256926692769286929693069316932693369346935693669376938693969406941694269436944694569466947694869496950695169526953695469556956695769586959696069616962696369646965696669676968696969706971697269736974697569766977697869796980698169826983698469856986698769886989699069916992699369946995699669976998699970007001700270037004700570067007700870097010701170127013701470157016701770187019702070217022702370247025702670277028702970307031703270337034703570367037703870397040704170427043704470457046704770487049705070517052705370547055705670577058705970607061706270637064706570667067706870697070707170727073707470757076707770787079708070817082708370847085708670877088708970907091709270937094709570967097709870997100710171027103710471057106710771087109711071117112711371147115711671177118711971207121712271237124712571267127712871297130713171327133713471357136713771387139714071417142714371447145714671477148714971507151715271537154715571567157715871597160716171627163716471657166716771687169717071717172717371747175717671777178717971807181718271837184718571867187718871897190719171927193719471957196719771987199720072017202720372047205720672077208720972107211721272137214721572167217721872197220722172227223722472257226722772287229723072317232723372347235723672377238723972407241724272437244724572467247724872497250725172527253725472557256725772587259726072617262726372647265726672677268726972707271727272737274727572767277727872797280728172827283728472857286728772887289729072917292729372947295729672977298729973007301730273037304730573067307730873097310731173127313731473157316731773187319732073217322732373247325732673277328732973307331733273337334733573367337733873397340734173427343734473457346734773487349735073517352735373547355735673577358735973607361736273637364736573667367736873697370737173727373737473757376737773787379738073817382738373847385738673877388738973907391739273937394739573967397739873997400740174027403740474057406740774087409741074117412741374147415741674177418741974207421742274237424742574267427742874297430743174327433743474357436743774387439744074417442744374447445744674477448744974507451745274537454745574567457745874597460746174627463746474657466746774687469747074717472747374747475747674777478747974807481748274837484748574867487748874897490749174927493749474957496749774987499750075017502750375047505750675077508750975107511751275137514751575167517751875197520752175227523752475257526752775287529753075317532753375347535753675377538753975407541754275437544754575467547754875497550755175527553755475557556755775587559756075617562756375647565756675677568756975707571757275737574757575767577757875797580758175827583758475857586758775887589759075917592759375947595759675977598759976007601760276037604760576067607760876097610761176127613761476157616761776187619762076217622762376247625762676277628762976307631763276337634763576367637763876397640764176427643764476457646764776487649765076517652765376547655765676577658765976607661766276637664766576667667766876697670767176727673767476757676767776787679768076817682768376847685768676877688768976907691769276937694769576967697769876997700770177027703770477057706770777087709771077117712771377147715771677177718771977207721772277237724772577267727772877297730773177327733773477357736773777387739774077417742774377447745774677477748774977507751775277537754775577567757775877597760776177627763776477657766776777687769777077717772777377747775777677777778777977807781778277837784778577867787778877897790779177927793779477957796779777987799780078017802780378047805780678077808780978107811781278137814781578167817781878197820782178227823782478257826782778287829783078317832783378347835783678377838783978407841784278437844784578467847784878497850785178527853785478557856785778587859786078617862786378647865786678677868786978707871787278737874787578767877787878797880788178827883788478857886788778887889789078917892789378947895789678977898789979007901790279037904790579067907790879097910791179127913791479157916791779187919792079217922792379247925792679277928792979307931793279337934793579367937793879397940794179427943794479457946794779487949795079517952795379547955795679577958795979607961796279637964796579667967796879697970797179727973797479757976797779787979798079817982798379847985798679877988798979907991799279937994799579967997799879998000800180028003800480058006800780088009801080118012801380148015801680178018801980208021802280238024802580268027802880298030803180328033803480358036803780388039804080418042804380448045804680478048804980508051805280538054805580568057805880598060806180628063806480658066806780688069807080718072807380748075807680778078807980808081808280838084808580868087808880898090809180928093809480958096809780988099810081018102810381048105810681078108810981108111811281138114811581168117811881198120812181228123812481258126812781288129813081318132813381348135813681378138813981408141814281438144814581468147814881498150815181528153815481558156815781588159816081618162816381648165816681678168816981708171817281738174817581768177817881798180818181828183818481858186818781888189819081918192819381948195819681978198819982008201820282038204820582068207820882098210821182128213821482158216821782188219822082218222822382248225822682278228822982308231823282338234823582368237823882398240824182428243824482458246824782488249825082518252825382548255825682578258825982608261826282638264826582668267826882698270827182728273827482758276827782788279828082818282828382848285828682878288828982908291829282938294829582968297829882998300830183028303830483058306830783088309831083118312831383148315831683178318831983208321832283238324832583268327832883298330833183328333833483358336833783388339834083418342834383448345834683478348834983508351835283538354835583568357835883598360836183628363836483658366836783688369837083718372837383748375837683778378837983808381838283838384838583868387838883898390839183928393839483958396839783988399840084018402840384048405840684078408840984108411841284138414841584168417841884198420842184228423842484258426842784288429843084318432843384348435843684378438843984408441844284438444844584468447844884498450845184528453845484558456845784588459846084618462846384648465846684678468846984708471847284738474847584768477847884798480848184828483848484858486848784888489849084918492849384948495849684978498849985008501850285038504850585068507850885098510851185128513851485158516851785188519852085218522852385248525852685278528/* * Copyright (c) 2005-2009 Apple Inc. All Rights Reserved. * * @APPLE_LICENSE_HEADER_START@ * * This file contains Original Code and/or Modifications of Original Code * as defined in and that are subject to the Apple Public Source License * Version 2.0 (the 'License'). You may not use this file except in * compliance with the License. Please obtain a copy of the License at * http://www.opensource.apple.com/apsl/ and read it before using this * file. * * The Original Code and all software distributed under the License are * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES, * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. * Please see the License for the specific language governing rights and * limitations under the License. * * @APPLE_LICENSE_HEADER_END@ *//************************************************************************ objc-runtime-new.m* Support for new-ABI classes and images.**********************************************************************/#if __OBJC2__#include &quot;DenseMapExtras.h&quot;#include &quot;objc-private.h&quot;#include &quot;objc-runtime-new.h&quot;#include &quot;objc-file.h&quot;#include &quot;objc-zalloc.h&quot;#include &lt;Block.h&gt;#include &lt;objc/message.h&gt;#include &lt;mach/shared_region.h&gt;#define newprotocol(p) ((protocol_t *)p)static void disableTaggedPointers();static void detach_class(Class cls, bool isMeta);static void free_class(Class cls);static IMP addMethod(Class cls, SEL name, IMP imp, const char *types, bool replace);static void adjustCustomFlagsForMethodChange(Class cls, method_t *meth);static method_t *search_method_list(const method_list_t *mlist, SEL sel);template&lt;typename T&gt; static bool method_lists_contains_any(T *mlists, T *end, SEL sels[], size_t selcount);static void flushCaches(Class cls, const char *func, bool (^predicate)(Class c));static void initializeTaggedPointerObfuscator(void);#if SUPPORT_FIXUPstatic void fixupMessageRef(message_ref_t *msg);#endifstatic Class realizeClassMaybeSwiftAndUnlock(Class cls, mutex_t&amp; lock);static Class readClass(Class cls, bool headerIsBundle, bool headerIsPreoptimized);struct locstamped_category_t { category_t *cat; struct header_info *hi;};enum { ATTACH_CLASS = 1 &lt;&lt; 0, ATTACH_METACLASS = 1 &lt;&lt; 1, ATTACH_CLASS_AND_METACLASS = 1 &lt;&lt; 2, ATTACH_EXISTING = 1 &lt;&lt; 3,};static void attachCategories(Class cls, const struct locstamped_category_t *cats_list, uint32_t cats_count, int flags);/************************************************************************ Lock management**********************************************************************/mutex_t runtimeLock;mutex_t selLock;#if CONFIG_USE_CACHE_LOCKmutex_t cacheUpdateLock;#endifrecursive_mutex_t loadMethodLock;/************************************************************************ Class structure decoding**********************************************************************/const uintptr_t objc_debug_class_rw_data_mask = FAST_DATA_MASK;/************************************************************************ Non-pointer isa decoding**********************************************************************/#if SUPPORT_INDEXED_ISA// Indexed non-pointer isa.// These are used to mask the ISA and see if its got an index or not.const uintptr_t objc_debug_indexed_isa_magic_mask = ISA_INDEX_MAGIC_MASK;const uintptr_t objc_debug_indexed_isa_magic_value = ISA_INDEX_MAGIC_VALUE;// die if masks overlapSTATIC_ASSERT((ISA_INDEX_MASK &amp; ISA_INDEX_MAGIC_MASK) == 0);// die if magic is wrongSTATIC_ASSERT((~ISA_INDEX_MAGIC_MASK &amp; ISA_INDEX_MAGIC_VALUE) == 0);// Then these are used to extract the index from the ISA.const uintptr_t objc_debug_indexed_isa_index_mask = ISA_INDEX_MASK;const uintptr_t objc_debug_indexed_isa_index_shift = ISA_INDEX_SHIFT;asm(&quot;\\n .globl _objc_absolute_indexed_isa_magic_mask&quot; \\ &quot;\\n _objc_absolute_indexed_isa_magic_mask = &quot; STRINGIFY2(ISA_INDEX_MAGIC_MASK));asm(&quot;\\n .globl _objc_absolute_indexed_isa_magic_value&quot; \\ &quot;\\n _objc_absolute_indexed_isa_magic_value = &quot; STRINGIFY2(ISA_INDEX_MAGIC_VALUE));asm(&quot;\\n .globl _objc_absolute_indexed_isa_index_mask&quot; \\ &quot;\\n _objc_absolute_indexed_isa_index_mask = &quot; STRINGIFY2(ISA_INDEX_MASK));asm(&quot;\\n .globl _objc_absolute_indexed_isa_index_shift&quot; \\ &quot;\\n _objc_absolute_indexed_isa_index_shift = &quot; STRINGIFY2(ISA_INDEX_SHIFT));// And then we can use that index to get the class from this array. Note// the size is provided so that clients can ensure the index they get is in// bounds and not read off the end of the array.// Defined in the objc-msg-*.s files// const Class objc_indexed_classes[]// When we don't have enough bits to store a class*, we can instead store an// index in to this array. Classes are added here when they are realized.// Note, an index of 0 is illegal.uintptr_t objc_indexed_classes_count = 0;// SUPPORT_INDEXED_ISA#else// not SUPPORT_INDEXED_ISA// These variables exist but are all set to 0 so that they are ignored.const uintptr_t objc_debug_indexed_isa_magic_mask = 0;const uintptr_t objc_debug_indexed_isa_magic_value = 0;const uintptr_t objc_debug_indexed_isa_index_mask = 0;const uintptr_t objc_debug_indexed_isa_index_shift = 0;Class objc_indexed_classes[1] = { nil };uintptr_t objc_indexed_classes_count = 0;// not SUPPORT_INDEXED_ISA#endif#if SUPPORT_PACKED_ISA// Packed non-pointer isa.asm(&quot;\\n .globl _objc_absolute_packed_isa_class_mask&quot; \\ &quot;\\n _objc_absolute_packed_isa_class_mask = &quot; STRINGIFY2(ISA_MASK));// a better definition is// (uintptr_t)ptrauth_strip((void *)ISA_MASK, ISA_SIGNING_KEY)// however we know that PAC uses bits outside of MACH_VM_MAX_ADDRESS// so approximate the definition here to be constanttemplate &lt;typename T&gt;static constexpr T coveringMask(T n) { for (T mask = 0; mask != ~T{0}; mask = (mask &lt;&lt; 1) | 1) { if ((n &amp; mask) == n) return mask; } return ~T{0};}const uintptr_t objc_debug_isa_class_mask = ISA_MASK &amp; coveringMask(MACH_VM_MAX_ADDRESS - 1);const uintptr_t objc_debug_isa_magic_mask = ISA_MAGIC_MASK;const uintptr_t objc_debug_isa_magic_value = ISA_MAGIC_VALUE;// die if masks overlapSTATIC_ASSERT((ISA_MASK &amp; ISA_MAGIC_MASK) == 0);// die if magic is wrongSTATIC_ASSERT((~ISA_MAGIC_MASK &amp; ISA_MAGIC_VALUE) == 0);// die if virtual address space bound goes upSTATIC_ASSERT((~ISA_MASK &amp; MACH_VM_MAX_ADDRESS) == 0 || ISA_MASK + sizeof(void*) == MACH_VM_MAX_ADDRESS);// SUPPORT_PACKED_ISA#else// not SUPPORT_PACKED_ISA// These variables exist but enforce pointer alignment only.const uintptr_t objc_debug_isa_class_mask = (~WORD_MASK);const uintptr_t objc_debug_isa_magic_mask = WORD_MASK;const uintptr_t objc_debug_isa_magic_value = 0;// not SUPPORT_PACKED_ISA#endif/************************************************************************ Swift marker bits**********************************************************************/const uintptr_t objc_debug_swift_stable_abi_bit = FAST_IS_SWIFT_STABLE;/************************************************************************ allocatedClasses* A table of all classes (and metaclasses) which have been allocated* with objc_allocateClassPair.**********************************************************************/namespace objc {static ExplicitInitDenseSet&lt;Class&gt; allocatedClasses;}/************************************************************************ _firstRealizedClass* The root of all realized classes**********************************************************************/static Class _firstRealizedClass = nil;/************************************************************************ didInitialAttachCategories* Whether the initial attachment of categories present at startup has* been done.**********************************************************************/static bool didInitialAttachCategories = false;/************************************************************************ didCallDyldNotifyRegister* Whether the call to _dyld_objc_notify_register has completed.**********************************************************************/bool didCallDyldNotifyRegister = false;/************************************************************************ smallMethodIMPMap* The map from small method pointers to replacement IMPs.** Locking: runtimeLock must be held when accessing this map.**********************************************************************/namespace objc { static objc::LazyInitDenseMap&lt;const method_t *, IMP&gt; smallMethodIMPMap;}static IMP method_t_remappedImp_nolock(const method_t *m) { runtimeLock.assertLocked(); auto *map = objc::smallMethodIMPMap.get(false); if (!map) return nullptr; auto iter = map-&gt;find(m); if (iter == map-&gt;end()) return nullptr; return iter-&gt;second;}IMP method_t::remappedImp(bool needsLock) const { ASSERT(isSmall()); if (needsLock) { mutex_locker_t guard(runtimeLock); return method_t_remappedImp_nolock(this); } else { return method_t_remappedImp_nolock(this); }}void method_t::remapImp(IMP imp) { ASSERT(isSmall()); runtimeLock.assertLocked(); auto *map = objc::smallMethodIMPMap.get(true); (*map)[this] = imp;}objc_method_description *method_t::getSmallDescription() const { static objc::LazyInitDenseMap&lt;const method_t *, objc_method_description *&gt; map; mutex_locker_t guard(runtimeLock); auto &amp;ptr = (*map.get(true))[this]; if (!ptr) { ptr = (objc_method_description *)malloc(sizeof *ptr); ptr-&gt;name = name(); ptr-&gt;types = (char *)types(); } return ptr;}/* Low two bits of mlist-&gt;entsize is used as the fixed-up marker. Method lists from shared cache are 1 (uniqued) or 3 (uniqued and sorted). (Protocol method lists are not sorted because of their extra parallel data) Runtime fixed-up method lists get 3. High two bits of protocol-&gt;flags is used as the fixed-up marker. PREOPTIMIZED VERSION: Protocols from shared cache are 1&lt;&lt;30. Runtime fixed-up protocols get 1&lt;&lt;30. UN-PREOPTIMIZED VERSION: Protocols from shared cache are 1&lt;&lt;30. Shared cache's fixups are not trusted. Runtime fixed-up protocols get 3&lt;&lt;30.*/static const uint32_t fixed_up_method_list = 3;static const uint32_t uniqued_method_list = 1;static uint32_t fixed_up_protocol = PROTOCOL_FIXED_UP_1;static uint32_t canonical_protocol = PROTOCOL_IS_CANONICAL;voiddisableSharedCacheOptimizations(void){ fixed_up_protocol = PROTOCOL_FIXED_UP_1 | PROTOCOL_FIXED_UP_2; // Its safe to just set canonical protocol to 0 as we'll never call // clearIsCanonical() unless isCanonical() returned true, which can't happen // with a 0 mask canonical_protocol = 0;}bool method_list_t::isUniqued() const { return (flags() &amp; uniqued_method_list) != 0;}bool method_list_t::isFixedUp() const { // Ignore any flags in the top bits, just look at the bottom two. return (flags() &amp; 0x3) == fixed_up_method_list;}void method_list_t::setFixedUp() { runtimeLock.assertLocked(); ASSERT(!isFixedUp()); entsizeAndFlags = entsize() | fixed_up_method_list;}bool protocol_t::isFixedUp() const { return (flags &amp; PROTOCOL_FIXED_UP_MASK) == fixed_up_protocol;}void protocol_t::setFixedUp() { runtimeLock.assertLocked(); ASSERT(!isFixedUp()); flags = (flags &amp; ~PROTOCOL_FIXED_UP_MASK) | fixed_up_protocol;}bool protocol_t::isCanonical() const { return (flags &amp; canonical_protocol) != 0;}void protocol_t::clearIsCanonical() { runtimeLock.assertLocked(); ASSERT(isCanonical()); flags = flags &amp; ~canonical_protocol;}const method_list_t_authed_ptr&lt;method_list_t&gt; *method_array_t::endCategoryMethodLists(Class cls) const{ auto mlists = beginLists(); auto mlistsEnd = endLists(); if (mlists == mlistsEnd || !cls-&gt;data()-&gt;ro()-&gt;baseMethods()) { // No methods, or no base methods. // Everything here is a category method. return mlistsEnd; } // Have base methods. Category methods are // everything except the last method list. return mlistsEnd - 1;}static const char *sel_cname(SEL sel){ return (const char *)(void *)sel;}static size_t protocol_list_size(const protocol_list_t *plist){ return sizeof(protocol_list_t) + plist-&gt;count * sizeof(protocol_t *);}static void try_free(const void *p) { if (p &amp;&amp; malloc_size(p)) free((void *)p);}using ClassCopyFixupHandler = void (*)(Class _Nonnull oldClass, Class _Nonnull newClass);// Normally there's only one handler registered.static GlobalSmallVector&lt;ClassCopyFixupHandler, 1&gt; classCopyFixupHandlers;void _objc_setClassCopyFixupHandler(void (* _Nonnull newFixupHandler) (Class _Nonnull oldClass, Class _Nonnull newClass)) { mutex_locker_t lock(runtimeLock); classCopyFixupHandlers.append(newFixupHandler);}static Class alloc_class_for_subclass(Class supercls, size_t extraBytes){ if (!supercls || !supercls-&gt;isAnySwift()) { return _calloc_class(sizeof(objc_class) + extraBytes); } // Superclass is a Swift class. New subclass must duplicate its extra bits. // Allocate the new class, with space for super's prefix and suffix // and self's extraBytes. swift_class_t *swiftSupercls = (swift_class_t *)supercls; size_t superSize = swiftSupercls-&gt;classSize; void *superBits = swiftSupercls-&gt;baseAddress(); void *bits = malloc(superSize + extraBytes); // Copy all of the superclass's data to the new class. memcpy(bits, superBits, superSize); // Erase the objc data and the Swift description in the new class. swift_class_t *swcls = (swift_class_t *) ((uint8_t *)bits + swiftSupercls-&gt;classAddressOffset); bzero(swcls, sizeof(objc_class)); swcls-&gt;description = nil; for (auto handler : classCopyFixupHandlers) { handler(supercls, (Class)swcls); } // Mark this class as Swift-enhanced. if (supercls-&gt;isSwiftStable()) { swcls-&gt;bits.setIsSwiftStable(); } if (supercls-&gt;isSwiftLegacy()) { swcls-&gt;bits.setIsSwiftLegacy(); } return (Class)swcls;}/************************************************************************ object_getIndexedIvars.**********************************************************************/void *object_getIndexedIvars(id obj){ uint8_t *base = (uint8_t *)obj; if (obj-&gt;isTaggedPointerOrNil()) return nil; if (!obj-&gt;isClass()) return base + obj-&gt;ISA()-&gt;alignedInstanceSize(); Class cls = (Class)obj; if (!cls-&gt;isAnySwift()) return base + sizeof(objc_class); swift_class_t *swcls = (swift_class_t *)cls; return base - swcls-&gt;classAddressOffset + word_align(swcls-&gt;classSize);}/************************************************************************ make_ro_writeable* Reallocates rw-&gt;ro if necessary to make it writeable.* Locking: runtimeLock must be held by the caller.**********************************************************************/static class_ro_t *make_ro_writeable(class_rw_t *rw){ runtimeLock.assertLocked(); if (rw-&gt;flags &amp; RW_COPIED_RO) { // already writeable, do nothing } else { rw-&gt;set_ro(rw-&gt;ro()-&gt;duplicate()); rw-&gt;flags |= RW_COPIED_RO; } return const_cast&lt;class_ro_t *&gt;(rw-&gt;ro());}/************************************************************************ dataSegmentsContain* Returns true if the given address lies within a data segment in any* loaded image.**********************************************************************/NEVER_INLINEstatic booldataSegmentsContain(Class cls){ uint32_t index; if (objc::dataSegmentsRanges.find((uintptr_t)cls, index)) { // if the class is realized (hence has a class_rw_t), // memorize where we found the range if (cls-&gt;isRealized()) { cls-&gt;data()-&gt;witness = (uint16_t)index; } return true; } return false;}/************************************************************************ isKnownClass* Return true if the class is known to the runtime (located within the* shared cache, within the data segment of a loaded image, or has been* allocated with obj_allocateClassPair).** The result of this operation is cached on the class in a &quot;witness&quot;* value that is cheaply checked in the fastpath.**********************************************************************/ALWAYS_INLINEstatic boolisKnownClass(Class cls){ if (fastpath(objc::dataSegmentsRanges.contains(cls-&gt;data()-&gt;witness, (uintptr_t)cls))) { return true; } auto &amp;set = objc::allocatedClasses.get(); return set.find(cls) != set.end() || dataSegmentsContain(cls);}/************************************************************************ addClassTableEntry* Add a class to the table of all classes. If addMeta is true,* automatically adds the metaclass of the class as well.* Locking: runtimeLock must be held by the caller.**********************************************************************/static voidaddClassTableEntry(Class cls, bool addMeta = true){ runtimeLock.assertLocked(); // This class is allowed to be a known class via the shared cache or via // data segments, but it is not allowed to be in the dynamic table already. auto &amp;set = objc::allocatedClasses.get(); ASSERT(set.find(cls) == set.end()); if (!isKnownClass(cls)) set.insert(cls); if (addMeta) addClassTableEntry(cls-&gt;ISA(), false);}/************************************************************************ checkIsKnownClass* Checks the given class against the list of all known classes. Dies* with a fatal error if the class is not known.* Locking: runtimeLock must be held by the caller.**********************************************************************/ALWAYS_INLINEstatic voidcheckIsKnownClass(Class cls){ if (slowpath(!isKnownClass(cls))) { _objc_fatal(&quot;Attempt to use unknown class %p.&quot;, cls); }}/************************************************************************ classNSObject* Returns class NSObject.* Locking: none**********************************************************************/static Class classNSObject(void){ extern objc_class OBJC_CLASS_$_NSObject; return (Class)&amp;OBJC_CLASS_$_NSObject;}static Class metaclassNSObject(void){ extern objc_class OBJC_METACLASS_$_NSObject; return (Class)&amp;OBJC_METACLASS_$_NSObject;}/************************************************************************ printReplacements* Implementation of PrintReplacedMethods / OBJC_PRINT_REPLACED_METHODS.* Warn about methods from cats that override other methods in cats or cls.* Assumes no methods from cats have been added to cls yet.**********************************************************************/__attribute__((cold, noinline))static voidprintReplacements(Class cls, const locstamped_category_t *cats_list, uint32_t cats_count){ uint32_t c; bool isMeta = cls-&gt;isMetaClass(); // Newest categories are LAST in cats // Later categories override earlier ones. for (c = 0; c &lt; cats_count; c++) { category_t *cat = cats_list[c].cat; method_list_t *mlist = cat-&gt;methodsForMeta(isMeta); if (!mlist) continue; for (const auto&amp; meth : *mlist) { SEL s = sel_registerName(sel_cname(meth.name())); // Search for replaced methods in method lookup order. // Complain about the first duplicate only. // Look for method in earlier categories for (uint32_t c2 = 0; c2 &lt; c; c2++) { category_t *cat2 = cats_list[c2].cat; const method_list_t *mlist2 = cat2-&gt;methodsForMeta(isMeta); if (!mlist2) continue; for (const auto&amp; meth2 : *mlist2) { SEL s2 = sel_registerName(sel_cname(meth2.name())); if (s == s2) { logReplacedMethod(cls-&gt;nameForLogging(), s, cls-&gt;isMetaClass(), cat-&gt;name, meth2.imp(false), meth.imp(false)); goto complained; } } } // Look for method in cls for (const auto&amp; meth2 : cls-&gt;data()-&gt;methods()) { SEL s2 = sel_registerName(sel_cname(meth2.name())); if (s == s2) { logReplacedMethod(cls-&gt;nameForLogging(), s, cls-&gt;isMetaClass(), cat-&gt;name, meth2.imp(false), meth.imp(false)); goto complained; } } complained: ; } }}/************************************************************************ unreasonableClassCount* Provides an upper bound for any iteration of classes,* to prevent spins when runtime metadata is corrupted.**********************************************************************/static unsigned unreasonableClassCount(){ runtimeLock.assertLocked(); int base = NXCountMapTable(gdb_objc_realized_classes) + getPreoptimizedClassUnreasonableCount(); // Provide lots of slack here. Some iterations touch metaclasses too. // Some iterations backtrack (like realized class iteration). // We don't need an efficient bound, merely one that prevents spins. return (base + 1) * 16;}/************************************************************************ Class enumerators* The passed in block returns `false` if subclasses can be skipped* Locking: runtimeLock must be held by the caller.**********************************************************************/static inline voidforeach_realized_class_and_subclass_2(Class top, unsigned &amp;count, bool skip_metaclass, bool (^code)(Class) __attribute((noescape))){ Class cls = top; runtimeLock.assertLocked(); ASSERT(top); while (1) { if (--count == 0) { _objc_fatal(&quot;Memory corruption in class list.&quot;); } bool skip_subclasses; if (skip_metaclass &amp;&amp; cls-&gt;isMetaClass()) { skip_subclasses = true; } else { skip_subclasses = !code(cls); } if (!skip_subclasses &amp;&amp; cls-&gt;data()-&gt;firstSubclass) { cls = cls-&gt;data()-&gt;firstSubclass; } else { while (!cls-&gt;data()-&gt;nextSiblingClass &amp;&amp; cls != top) { cls = cls-&gt;getSuperclass(); if (--count == 0) { _objc_fatal(&quot;Memory corruption in class list.&quot;); } } if (cls == top) break; cls = cls-&gt;data()-&gt;nextSiblingClass; } }}// Enumerates a class and all of its realized subclasses.static voidforeach_realized_class_and_subclass(Class top, bool (^code)(Class) __attribute((noescape))){ unsigned int count = unreasonableClassCount(); foreach_realized_class_and_subclass_2(top, count, false, code);}// Enumerates all realized classes and metaclasses.static voidforeach_realized_class_and_metaclass(bool (^code)(Class) __attribute((noescape))){ unsigned int count = unreasonableClassCount(); for (Class top = _firstRealizedClass; top != nil; top = top-&gt;data()-&gt;nextSiblingClass) { foreach_realized_class_and_subclass_2(top, count, false, code); }}// Enumerates all realized classes (ignoring metaclasses).static voidforeach_realized_class(bool (^code)(Class) __attribute((noescape))){ unsigned int count = unreasonableClassCount(); for (Class top = _firstRealizedClass; top != nil; top = top-&gt;data()-&gt;nextSiblingClass) { foreach_realized_class_and_subclass_2(top, count, true, code); }}/*********************************************************************** * Method Scanners / Optimization tracking * Implementation of scanning for various implementations of methods. **********************************************************************/namespace objc {enum SelectorBundle { AWZ, RR, Core,};namespace scanner {// The current state of NSObject swizzling for every scanner//// It allows for cheap checks of global swizzles, and also lets// things like IMP Swizzling before NSObject has been initialized// to be remembered, as setInitialized() would miss these.//// Every pair of bits describes a SelectorBundle.// even bits: is NSObject class swizzled for this bundle// odd bits: is NSObject meta class swizzled for this bundlestatic uintptr_t NSObjectSwizzledMask;static ALWAYS_INLINE uintptr_tswizzlingBit(SelectorBundle bundle, bool isMeta){ return 1UL &lt;&lt; (2 * bundle + isMeta);}static void __attribute__((cold, noinline))printCustom(Class cls, SelectorBundle bundle, bool inherited){ static char const * const SelectorBundleName[] = { [AWZ] = &quot;CUSTOM AWZ&quot;, [RR] = &quot;CUSTOM RR&quot;, [Core] = &quot;CUSTOM Core&quot;, }; _objc_inform(&quot;%s: %s%s%s&quot;, SelectorBundleName[bundle], cls-&gt;nameForLogging(), cls-&gt;isMetaClass() ? &quot; (meta)&quot; : &quot;&quot;, inherited ? &quot; (inherited)&quot; : &quot;&quot;);}enum class Scope { Instances, Classes, Both };template &lt;typename Traits, SelectorBundle Bundle, bool &amp;ShouldPrint, Scope Domain = Scope::Both&gt;class Mixin { // work around compiler being broken with templates using Class/objc_class, // probably some weird confusion with Class being builtin ALWAYS_INLINE static objc_class *as_objc_class(Class cls) { return (objc_class *)cls; } static void setCustomRecursively(Class cls, bool inherited = false) { foreach_realized_class_and_subclass(cls, [=](Class c){ if (c != cls &amp;&amp; !as_objc_class(c)-&gt;isInitialized()) { // Subclass not yet initialized. Wait for setInitialized() to do it return false; } if (Traits::isCustom(c)) { return false; } Traits::setCustom(c); if (ShouldPrint) { printCustom(cls, Bundle, inherited || c != cls); } return true; }); } static bool isNSObjectSwizzled(bool isMeta) { return NSObjectSwizzledMask &amp; swizzlingBit(Bundle, isMeta); } static void setNSObjectSwizzled(Class NSOClass, bool isMeta) { NSObjectSwizzledMask |= swizzlingBit(Bundle, isMeta); if (as_objc_class(NSOClass)-&gt;isInitialized()) { setCustomRecursively(NSOClass); } } static void scanChangedMethodForUnknownClass(const method_t *meth) { Class cls; cls = classNSObject(); if (Domain != Scope::Classes &amp;&amp; !isNSObjectSwizzled(NO)) { for (const auto &amp;meth2: as_objc_class(cls)-&gt;data()-&gt;methods()) { if (meth == &amp;meth2) { setNSObjectSwizzled(cls, NO); break; } } } cls = metaclassNSObject(); if (Domain != Scope::Instances &amp;&amp; !isNSObjectSwizzled(YES)) { for (const auto &amp;meth2: as_objc_class(cls)-&gt;data()-&gt;methods()) { if (meth == &amp;meth2) { setNSObjectSwizzled(cls, YES); break; } } } } static void scanAddedClassImpl(Class cls, bool isMeta) { bool setCustom = NO, inherited = NO; if (isNSObjectSwizzled(isMeta)) { setCustom = YES; } else if (Traits::knownClassHasDefaultImpl(cls, isMeta)) { // This class is known to have the default implementations, // but we need to check categories. auto &amp;methods = as_objc_class(cls)-&gt;data()-&gt;methods(); setCustom = Traits::scanMethodLists(methods.beginCategoryMethodLists(), methods.endCategoryMethodLists(cls)); } else if (!isMeta &amp;&amp; !as_objc_class(cls)-&gt;getSuperclass()) { // Custom Root class setCustom = YES; } else if (Traits::isCustom(as_objc_class(cls)-&gt;getSuperclass())) { // Superclass is custom, therefore we are too. setCustom = YES; inherited = YES; } else { // Not NSObject. auto &amp;methods = as_objc_class(cls)-&gt;data()-&gt;methods(); setCustom = Traits::scanMethodLists(methods.beginLists(), methods.endLists()); } if (slowpath(setCustom)) { if (ShouldPrint) printCustom(cls, Bundle, inherited); } else { Traits::setDefault(cls); } }public: static bool knownClassHasDefaultImpl(Class cls, bool isMeta) { // Typically only NSObject has default implementations. // Allow this to be extended by overriding (to allow // SwiftObject, for example). Class NSOClass = (isMeta ? metaclassNSObject() : classNSObject()); return cls == NSOClass; } // Scan a class that is about to be marked Initialized for particular // bundles of selectors, and mark the class and its children // accordingly. // // This also handles inheriting properties from its superclass. // // Caller: objc_class::setInitialized() static void scanInitializedClass(Class cls, Class metacls) { if (Domain != Scope::Classes) { scanAddedClassImpl(cls, false); } if (Domain != Scope::Instances) { scanAddedClassImpl(metacls, true); } } // Inherit various properties from the superclass when a class // is being added to the graph. // // Caller: addSubclass() static void scanAddedSubClass(Class subcls, Class supercls) { if (slowpath(Traits::isCustom(supercls) &amp;&amp; !Traits::isCustom(subcls))) { setCustomRecursively(subcls, true); } } // Scan Method lists for selectors that would override things // in a Bundle. // // This is used to detect when categories override problematic selectors // are injected in a class after it has been initialized. // // Caller: prepareMethodLists() static void scanAddedMethodLists(Class cls, method_list_t **mlists, int count) { if (slowpath(Traits::isCustom(cls))) { return; } if (slowpath(Traits::scanMethodLists(mlists, mlists + count))) { setCustomRecursively(cls); } } // Handle IMP Swizzling (the IMP for an exisiting method being changed). // // In almost all cases, IMP swizzling does not affect custom bits. // Custom search will already find the method whether or not // it is swizzled, so it does not transition from non-custom to custom. // // The only cases where IMP swizzling can affect the custom bits is // if the swizzled method is one of the methods that is assumed to be // non-custom. These special cases are listed in setInitialized(). // We look for such cases here. // // Caller: Swizzling methods via adjustCustomFlagsForMethodChange() static void scanChangedMethod(Class cls, const method_t *meth) { if (fastpath(!Traits::isInterestingSelector(meth-&gt;name()))) { return; } if (cls) { bool isMeta = as_objc_class(cls)-&gt;isMetaClass(); if (isMeta &amp;&amp; Domain != Scope::Instances) { if (cls == metaclassNSObject() &amp;&amp; !isNSObjectSwizzled(isMeta)) { setNSObjectSwizzled(cls, isMeta); } } if (!isMeta &amp;&amp; Domain != Scope::Classes) { if (cls == classNSObject() &amp;&amp; !isNSObjectSwizzled(isMeta)) { setNSObjectSwizzled(cls, isMeta); } } } else { // We're called from method_exchangeImplementations, only NSObject // class and metaclass may be problematic (exchanging the default // builtin IMP of an interesting seleector, is a swizzling that, // may flip our scanned property. For other classes, the previous // value had already flipped the property). // // However, as we don't know the class, we need to scan all of // NSObject class and metaclass methods (this is SLOW). scanChangedMethodForUnknownClass(meth); } }};} // namespace scanner// AWZ methods: +alloc / +allocWithZone:struct AWZScanner : scanner::Mixin&lt;AWZScanner, AWZ, PrintCustomAWZ, scanner::Scope::Classes&gt; { static bool isCustom(Class cls) { return cls-&gt;hasCustomAWZ(); } static void setCustom(Class cls) { cls-&gt;setHasCustomAWZ(); } static void setDefault(Class cls) { cls-&gt;setHasDefaultAWZ(); } static bool isInterestingSelector(SEL sel) { return sel == @selector(alloc) || sel == @selector(allocWithZone:); } template&lt;typename T&gt; static bool scanMethodLists(T *mlists, T *end) { SEL sels[2] = { @selector(alloc), @selector(allocWithZone:), }; return method_lists_contains_any(mlists, end, sels, 2); }};// Retain/Release methods that are extremely rarely overridden//// retain/release/autorelease/retainCount/// _tryRetain/_isDeallocating/retainWeakReference/allowsWeakReferencestruct RRScanner : scanner::Mixin&lt;RRScanner, RR, PrintCustomRR#if !SUPPORT_NONPOINTER_ISA, scanner::Scope::Instances#endif&gt; { static bool isCustom(Class cls) { return cls-&gt;hasCustomRR(); } static void setCustom(Class cls) { cls-&gt;setHasCustomRR(); } static void setDefault(Class cls) { cls-&gt;setHasDefaultRR(); } static bool isInterestingSelector(SEL sel) { return sel == @selector(retain) || sel == @selector(release) || sel == @selector(autorelease) || sel == @selector(_tryRetain) || sel == @selector(_isDeallocating) || sel == @selector(retainCount) || sel == @selector(allowsWeakReference) || sel == @selector(retainWeakReference); } template &lt;typename T&gt; static bool scanMethodLists(T *mlists, T *end) { SEL sels[8] = { @selector(retain), @selector(release), @selector(autorelease), @selector(_tryRetain), @selector(_isDeallocating), @selector(retainCount), @selector(allowsWeakReference), @selector(retainWeakReference), }; return method_lists_contains_any(mlists, end, sels, 8); }};// Core NSObject methods that are extremely rarely overridden//// +new, ±class, ±self, ±isKindOfClass:, ±respondsToSelectorstruct CoreScanner : scanner::Mixin&lt;CoreScanner, Core, PrintCustomCore&gt; { static bool knownClassHasDefaultImpl(Class cls, bool isMeta) { if (scanner::Mixin&lt;CoreScanner, Core, PrintCustomCore&gt;::knownClassHasDefaultImpl(cls, isMeta)) return true; if ((cls-&gt;isRootClass() || cls-&gt;isRootMetaclass()) &amp;&amp; strcmp(cls-&gt;mangledName(), &quot;_TtCs12_SwiftObject&quot;) == 0) return true; return false; } static bool isCustom(Class cls) { return cls-&gt;hasCustomCore(); } static void setCustom(Class cls) { cls-&gt;setHasCustomCore(); } static void setDefault(Class cls) { cls-&gt;setHasDefaultCore(); } static bool isInterestingSelector(SEL sel) { return sel == @selector(new) || sel == @selector(self) || sel == @selector(class) || sel == @selector(isKindOfClass:) || sel == @selector(respondsToSelector:); } template &lt;typename T&gt; static bool scanMethodLists(T *mlists, T *end) { SEL sels[5] = { @selector(new), @selector(self), @selector(class), @selector(isKindOfClass:), @selector(respondsToSelector:) }; return method_lists_contains_any(mlists, end, sels, 5); }};class category_list : nocopy_t { union { locstamped_category_t lc; struct { locstamped_category_t *array; // this aliases with locstamped_category_t::hi // which is an aliased pointer uint32_t is_array : 1; uint32_t count : 31; uint32_t size : 32; }; } _u;public: category_list() : _u{{nullptr, nullptr}} { } category_list(locstamped_category_t lc) : _u{{lc}} { } category_list(category_list &amp;&amp;other) : category_list() { std::swap(_u, other._u); } ~category_list() { if (_u.is_array) { free(_u.array); } } uint32_t count() const { if (_u.is_array) return _u.count; return _u.lc.cat ? 1 : 0; } uint32_t arrayByteSize(uint32_t size) const { return sizeof(locstamped_category_t) * size; } const locstamped_category_t *array() const { return _u.is_array ? _u.array : &amp;_u.lc; } void append(locstamped_category_t lc) { if (_u.is_array) { if (_u.count == _u.size) { // Have a typical malloc growth: // - size &lt;= 8: grow by 2 // - size &lt;= 16: grow by 4 // - size &lt;= 32: grow by 8 // ... etc _u.size += _u.size &lt; 8 ? 2 : 1 &lt;&lt; (fls(_u.size) - 2); _u.array = (locstamped_category_t *)reallocf(_u.array, arrayByteSize(_u.size)); } _u.array[_u.count++] = lc; } else if (_u.lc.cat == NULL) { _u.lc = lc; } else { locstamped_category_t *arr = (locstamped_category_t *)malloc(arrayByteSize(2)); arr[0] = _u.lc; arr[1] = lc; _u.array = arr; _u.is_array = true; _u.count = 2; _u.size = 2; } } void erase(category_t *cat) { if (_u.is_array) { for (int i = 0; i &lt; _u.count; i++) { if (_u.array[i].cat == cat) { // shift entries to preserve list order memmove(&amp;_u.array[i], &amp;_u.array[i+1], arrayByteSize(_u.count - i - 1)); return; } } } else if (_u.lc.cat == cat) { _u.lc.cat = NULL; _u.lc.hi = NULL; } }};class UnattachedCategories : public ExplicitInitDenseMap&lt;Class, category_list&gt;{public: void addForClass(locstamped_category_t lc, Class cls) { runtimeLock.assertLocked(); if (slowpath(PrintConnecting)) { _objc_inform(&quot;CLASS: found category %c%s(%s)&quot;, cls-&gt;isMetaClassMaybeUnrealized() ? '+' : '-', cls-&gt;nameForLogging(), lc.cat-&gt;name); } auto result = get().try_emplace(cls, lc); if (!result.second) { result.first-&gt;second.append(lc); } } void attachToClass(Class cls, Class previously, int flags) { runtimeLock.assertLocked(); ASSERT((flags &amp; ATTACH_CLASS) || (flags &amp; ATTACH_METACLASS) || (flags &amp; ATTACH_CLASS_AND_METACLASS)); auto &amp;map = get(); auto it = map.find(previously); if (it != map.end()) { category_list &amp;list = it-&gt;second; if (flags &amp; ATTACH_CLASS_AND_METACLASS) { int otherFlags = flags &amp; ~ATTACH_CLASS_AND_METACLASS; attachCategories(cls, list.array(), list.count(), otherFlags | ATTACH_CLASS); attachCategories(cls-&gt;ISA(), list.array(), list.count(), otherFlags | ATTACH_METACLASS); } else { attachCategories(cls, list.array(), list.count(), flags); } map.erase(it); } } void eraseCategoryForClass(category_t *cat, Class cls) { runtimeLock.assertLocked(); auto &amp;map = get(); auto it = map.find(cls); if (it != map.end()) { category_list &amp;list = it-&gt;second; list.erase(cat); if (list.count() == 0) { map.erase(it); } } } void eraseClass(Class cls) { runtimeLock.assertLocked(); get().erase(cls); }};static UnattachedCategories unattachedCategories;} // namespace objcstatic bool isBundleClass(Class cls){ return cls-&gt;data()-&gt;ro()-&gt;flags &amp; RO_FROM_BUNDLE;}static void fixupMethodList(method_list_t *mlist, bool bundleCopy, bool sort){ runtimeLock.assertLocked(); ASSERT(!mlist-&gt;isFixedUp()); // fixme lock less in attachMethodLists ? // dyld3 may have already uniqued, but not sorted, the list if (!mlist-&gt;isUniqued()) { mutex_locker_t lock(selLock); // Unique selectors in list. for (auto&amp; meth : *mlist) { const char *name = sel_cname(meth.name()); meth.setName(sel_registerNameNoLock(name, bundleCopy)); } } // Sort by selector address. // Don't try to sort small lists, as they're immutable. // Don't try to sort big lists of nonstandard size, as stable_sort // won't copy the entries properly. if (sort &amp;&amp; !mlist-&gt;isSmallList() &amp;&amp; mlist-&gt;entsize() == method_t::bigSize) { method_t::SortBySELAddress sorter; std::stable_sort(&amp;mlist-&gt;begin()-&gt;big(), &amp;mlist-&gt;end()-&gt;big(), sorter); } // Mark method list as uniqued and sorted. // Can't mark small lists, since they're immutable. if (!mlist-&gt;isSmallList()) { mlist-&gt;setFixedUp(); }}static void prepareMethodLists(Class cls, method_list_t **addedLists, int addedCount, bool baseMethods, bool methodsFromBundle, const char *why){ runtimeLock.assertLocked(); if (addedCount == 0) return; // There exist RR/AWZ/Core special cases for some class's base methods. // But this code should never need to scan base methods for RR/AWZ/Core: // default RR/AWZ/Core cannot be set before setInitialized(). // Therefore we need not handle any special cases here. if (baseMethods) { ASSERT(cls-&gt;hasCustomAWZ() &amp;&amp; cls-&gt;hasCustomRR() &amp;&amp; cls-&gt;hasCustomCore()); } else if (cls-&gt;cache.isConstantOptimizedCache()) { cls-&gt;setDisallowPreoptCachesRecursively(why); } else if (cls-&gt;allowsPreoptInlinedSels()) {#if CONFIG_USE_PREOPT_CACHES SEL *sels = (SEL *)objc_opt_offsets[OBJC_OPT_INLINED_METHODS_START]; SEL *sels_end = (SEL *)objc_opt_offsets[OBJC_OPT_INLINED_METHODS_END]; if (method_lists_contains_any(addedLists, addedLists + addedCount, sels, sels_end - sels)) { cls-&gt;setDisallowPreoptInlinedSelsRecursively(why); }#endif } // Add method lists to array. // Reallocate un-fixed method lists. // The new methods are PREPENDED to the method list array. for (int i = 0; i &lt; addedCount; i++) { method_list_t *mlist = addedLists[i]; ASSERT(mlist); // Fixup selectors if necessary if (!mlist-&gt;isFixedUp()) { fixupMethodList(mlist, methodsFromBundle, true/*sort*/); } } // If the class is initialized, then scan for method implementations // tracked by the class's flags. If it's not initialized yet, // then objc_class::setInitialized() will take care of it. if (cls-&gt;isInitialized()) { objc::AWZScanner::scanAddedMethodLists(cls, addedLists, addedCount); objc::RRScanner::scanAddedMethodLists(cls, addedLists, addedCount); objc::CoreScanner::scanAddedMethodLists(cls, addedLists, addedCount); }}class_rw_ext_t *class_rw_t::extAlloc(const class_ro_t *ro, bool deepCopy){ runtimeLock.assertLocked(); auto rwe = objc::zalloc&lt;class_rw_ext_t&gt;(); rwe-&gt;version = (ro-&gt;flags &amp; RO_META) ? 7 : 0; method_list_t *list = ro-&gt;baseMethods(); if (list) { if (deepCopy) list = list-&gt;duplicate(); rwe-&gt;methods.attachLists(&amp;list, 1); } // See comments in objc_duplicateClass // property lists and protocol lists historically // have not been deep-copied // // This is probably wrong and ought to be fixed some day property_list_t *proplist = ro-&gt;baseProperties; if (proplist) { rwe-&gt;properties.attachLists(&amp;proplist, 1); } protocol_list_t *protolist = ro-&gt;baseProtocols; if (protolist) { rwe-&gt;protocols.attachLists(&amp;protolist, 1); } set_ro_or_rwe(rwe, ro); return rwe;}// Attach method lists and properties and protocols from categories to a class.// Assumes the categories in cats are all loaded and sorted by load order, // oldest categories first.static voidattachCategories(Class cls, const locstamped_category_t *cats_list, uint32_t cats_count, int flags){ if (slowpath(PrintReplacedMethods)) { printReplacements(cls, cats_list, cats_count); } if (slowpath(PrintConnecting)) { _objc_inform(&quot;CLASS: attaching %d categories to%s class '%s'%s&quot;, cats_count, (flags &amp; ATTACH_EXISTING) ? &quot; existing&quot; : &quot;&quot;, cls-&gt;nameForLogging(), (flags &amp; ATTACH_METACLASS) ? &quot; (meta)&quot; : &quot;&quot;); } /* * Only a few classes have more than 64 categories during launch. * This uses a little stack, and avoids malloc. * * Categories must be added in the proper order, which is back * to front. To do that with the chunking, we iterate cats_list * from front to back, build up the local buffers backwards, * and call attachLists on the chunks. attachLists prepends the * lists, so the final result is in the expected order. */ constexpr uint32_t ATTACH_BUFSIZ = 64; method_list_t *mlists[ATTACH_BUFSIZ]; property_list_t *proplists[ATTACH_BUFSIZ]; protocol_list_t *protolists[ATTACH_BUFSIZ]; uint32_t mcount = 0; uint32_t propcount = 0; uint32_t protocount = 0; bool fromBundle = NO; bool isMeta = (flags &amp; ATTACH_METACLASS); auto rwe = cls-&gt;data()-&gt;extAllocIfNeeded(); for (uint32_t i = 0; i &lt; cats_count; i++) { auto&amp; entry = cats_list[i]; method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta); if (mlist) { if (mcount == ATTACH_BUFSIZ) { prepareMethodLists(cls, mlists, mcount, NO, fromBundle, __func__); rwe-&gt;methods.attachLists(mlists, mcount); mcount = 0; } mlists[ATTACH_BUFSIZ - ++mcount] = mlist; fromBundle |= entry.hi-&gt;isBundle(); } property_list_t *proplist = entry.cat-&gt;propertiesForMeta(isMeta, entry.hi); if (proplist) { if (propcount == ATTACH_BUFSIZ) { rwe-&gt;properties.attachLists(proplists, propcount); propcount = 0; } proplists[ATTACH_BUFSIZ - ++propcount] = proplist; } protocol_list_t *protolist = entry.cat-&gt;protocolsForMeta(isMeta); if (protolist) { if (protocount == ATTACH_BUFSIZ) { rwe-&gt;protocols.attachLists(protolists, protocount); protocount = 0; } protolists[ATTACH_BUFSIZ - ++protocount] = protolist; } } if (mcount &gt; 0) { prepareMethodLists(cls, mlists + ATTACH_BUFSIZ - mcount, mcount, NO, fromBundle, __func__); rwe-&gt;methods.attachLists(mlists + ATTACH_BUFSIZ - mcount, mcount); if (flags &amp; ATTACH_EXISTING) { flushCaches(cls, __func__, [](Class c){ // constant caches have been dealt with in prepareMethodLists // if the class still is constant here, it's fine to keep return !c-&gt;cache.isConstantOptimizedCache(); }); } } rwe-&gt;properties.attachLists(proplists + ATTACH_BUFSIZ - propcount, propcount); rwe-&gt;protocols.attachLists(protolists + ATTACH_BUFSIZ - protocount, protocount);}/************************************************************************ methodizeClass* Fixes up cls's method list, protocol list, and property list.* Attaches any outstanding categories.* Locking: runtimeLock must be held by the caller**********************************************************************/static void methodizeClass(Class cls, Class previously){ runtimeLock.assertLocked(); bool isMeta = cls-&gt;isMetaClass(); auto rw = cls-&gt;data(); auto ro = rw-&gt;ro(); auto rwe = rw-&gt;ext(); // Methodizing for the first time if (PrintConnecting) { _objc_inform(&quot;CLASS: methodizing class '%s' %s&quot;, cls-&gt;nameForLogging(), isMeta ? &quot;(meta)&quot; : &quot;&quot;); } // Install methods and properties that the class implements itself. method_list_t *list = ro-&gt;baseMethods(); if (list) { prepareMethodLists(cls, &amp;list, 1, YES, isBundleClass(cls), nullptr); if (rwe) rwe-&gt;methods.attachLists(&amp;list, 1); } property_list_t *proplist = ro-&gt;baseProperties; if (rwe &amp;&amp; proplist) { rwe-&gt;properties.attachLists(&amp;proplist, 1); } protocol_list_t *protolist = ro-&gt;baseProtocols; if (rwe &amp;&amp; protolist) { rwe-&gt;protocols.attachLists(&amp;protolist, 1); } // Root classes get bonus method implementations if they don't have // them already. These apply before category replacements. if (cls-&gt;isRootMetaclass()) { // root metaclass addMethod(cls, @selector(initialize), (IMP)&amp;objc_noop_imp, &quot;&quot;, NO); } // Attach categories. if (previously) { if (isMeta) { objc::unattachedCategories.attachToClass(cls, previously, ATTACH_METACLASS); } else { // When a class relocates, categories with class methods // may be registered on the class itself rather than on // the metaclass. Tell attachToClass to look for those. objc::unattachedCategories.attachToClass(cls, previously, ATTACH_CLASS_AND_METACLASS); } } objc::unattachedCategories.attachToClass(cls, cls, isMeta ? ATTACH_METACLASS : ATTACH_CLASS);#if DEBUG // Debug: sanity-check all SELs; log method list contents for (const auto&amp; meth : rw-&gt;methods()) { if (PrintConnecting) { _objc_inform(&quot;METHOD %c[%s %s]&quot;, isMeta ? '+' : '-', cls-&gt;nameForLogging(), sel_getName(meth.name())); } ASSERT(sel_registerName(sel_getName(meth.name())) == meth.name()); }#endif}/************************************************************************ nonMetaClasses* Returns the secondary metaclass =&gt; class map* Used for some cases of +initialize and +resolveClassMethod:.* This map does not contain all class and metaclass pairs. It only * contains metaclasses whose classes would be in the runtime-allocated * named-class table, but are not because some other class with the same name * is in that table.* Classes with no duplicates are not included.* Classes in the preoptimized named-class table are not included.* Classes whose duplicates are in the preoptimized table are not included.* Most code should use getMaybeUnrealizedNonMetaClass() * instead of reading this table.* Locking: runtimeLock must be read- or write-locked by the caller**********************************************************************/static NXMapTable *nonmeta_class_map = nil;static NXMapTable *nonMetaClasses(void){ runtimeLock.assertLocked(); if (nonmeta_class_map) return nonmeta_class_map; // nonmeta_class_map is typically small INIT_ONCE_PTR(nonmeta_class_map, NXCreateMapTable(NXPtrValueMapPrototype, 32), NXFreeMapTable(v)); return nonmeta_class_map;}/************************************************************************ addNonMetaClass* Adds metacls =&gt; cls to the secondary metaclass map* Locking: runtimeLock must be held by the caller**********************************************************************/static void addNonMetaClass(Class cls){ runtimeLock.assertLocked(); void *old; old = NXMapInsert(nonMetaClasses(), cls-&gt;ISA(), cls); ASSERT(!cls-&gt;isMetaClassMaybeUnrealized()); ASSERT(cls-&gt;ISA()-&gt;isMetaClassMaybeUnrealized()); ASSERT(!old);}static void removeNonMetaClass(Class cls){ runtimeLock.assertLocked(); NXMapRemove(nonMetaClasses(), cls-&gt;ISA());}static bool scanMangledField(const char *&amp;string, const char *end, const char *&amp;field, int&amp; length){ // Leading zero not allowed. if (*string == '0') return false; length = 0; field = string; while (field &lt; end) { char c = *field; if (!isdigit(c)) break; field++; if (__builtin_smul_overflow(length, 10, &amp;length)) return false; if (__builtin_sadd_overflow(length, c - '0', &amp;length)) return false; } string = field + length; return length &gt; 0 &amp;&amp; string &lt;= end;}/************************************************************************ copySwiftV1DemangledName* Returns the pretty form of the given Swift-v1-mangled class or protocol name. * Returns nil if the string doesn't look like a mangled Swift v1 name.* The result must be freed with free().**********************************************************************/static char *copySwiftV1DemangledName(const char *string, bool isProtocol = false){ if (!string) return nil; // Swift mangling prefix. if (strncmp(string, isProtocol ? &quot;_TtP&quot; : &quot;_TtC&quot;, 4) != 0) return nil; string += 4; const char *end = string + strlen(string); // Module name. const char *prefix; int prefixLength; if (string[0] == 's') { // &quot;s&quot; is the Swift module. prefix = &quot;Swift&quot;; prefixLength = 5; string += 1; } else { if (! scanMangledField(string, end, prefix, prefixLength)) return nil; } // Class or protocol name. const char *suffix; int suffixLength; if (! scanMangledField(string, end, suffix, suffixLength)) return nil; if (isProtocol) { // Remainder must be &quot;_&quot;. if (strcmp(string, &quot;_&quot;) != 0) return nil; } else { // Remainder must be empty. if (string != end) return nil; } char *result; asprintf(&amp;result, &quot;%.*s.%.*s&quot;, prefixLength,prefix, suffixLength,suffix); return result;}/************************************************************************ copySwiftV1MangledName* Returns the Swift 1.0 mangled form of the given class or protocol name. * Returns nil if the string doesn't look like an unmangled Swift name.* The result must be freed with free().**********************************************************************/static char *copySwiftV1MangledName(const char *string, bool isProtocol = false){ if (!string) return nil; size_t dotCount = 0; size_t dotIndex; const char *s; for (s = string; *s; s++) { if (*s == '.') { dotCount++; dotIndex = s - string; } } size_t stringLength = s - string; if (dotCount != 1 || dotIndex == 0 || dotIndex &gt;= stringLength-1) { return nil; } const char *prefix = string; size_t prefixLength = dotIndex; const char *suffix = string + dotIndex + 1; size_t suffixLength = stringLength - (dotIndex + 1); char *name; if (prefixLength == 5 &amp;&amp; memcmp(prefix, &quot;Swift&quot;, 5) == 0) { asprintf(&amp;name, &quot;_Tt%cs%zu%.*s%s&quot;, isProtocol ? 'P' : 'C', suffixLength, (int)suffixLength, suffix, isProtocol ? &quot;_&quot; : &quot;&quot;); } else { asprintf(&amp;name, &quot;_Tt%c%zu%.*s%zu%.*s%s&quot;, isProtocol ? 'P' : 'C', prefixLength, (int)prefixLength, prefix, suffixLength, (int)suffixLength, suffix, isProtocol ? &quot;_&quot; : &quot;&quot;); } return name;}/************************************************************************ getClassExceptSomeSwift* Looks up a class by name. The class MIGHT NOT be realized.* Demangled Swift names are recognized.* Classes known to the Swift runtime but not yet used are NOT recognized.* (such as subclasses of un-instantiated generics)* Use look_up_class() to find them as well.* Locking: runtimeLock must be read- or write-locked by the caller.**********************************************************************/// This is a misnomer: gdb_objc_realized_classes is actually a list of // named classes not in the dyld shared cache, whether realized or not.// This list excludes lazily named classes, which have to be looked up// using a getClass hook.NXMapTable *gdb_objc_realized_classes; // exported for debuggers in objc-gdb.huintptr_t objc_debug_realized_class_generation_count;static Class getClass_impl(const char *name){ runtimeLock.assertLocked(); // allocated in _read_images ASSERT(gdb_objc_realized_classes); // Try runtime-allocated table Class result = (Class)NXMapGet(gdb_objc_realized_classes, name); if (result) return result; // Try table from dyld shared cache. // Note we do this last to handle the case where we dlopen'ed a shared cache // dylib with duplicates of classes already present in the main executable. // In that case, we put the class from the main executable in // gdb_objc_realized_classes and want to check that before considering any // newly loaded shared cache binaries. return getPreoptimizedClass(name);}static Class getClassExceptSomeSwift(const char *name){ runtimeLock.assertLocked(); // Try name as-is Class result = getClass_impl(name); if (result) return result; // Try Swift-mangled equivalent of the given name. if (char *swName = copySwiftV1MangledName(name)) { result = getClass_impl(swName); free(swName); return result; } return nil;}/************************************************************************ addNamedClass* Adds name =&gt; cls to the named non-meta class map.* Warns about duplicate class names and keeps the old mapping.* Locking: runtimeLock must be held by the caller**********************************************************************/static void addNamedClass(Class cls, const char *name, Class replacing = nil){ runtimeLock.assertLocked(); Class old; if ((old = getClassExceptSomeSwift(name)) &amp;&amp; old != replacing) { inform_duplicate(name, old, cls); // getMaybeUnrealizedNonMetaClass uses name lookups. // Classes not found by name lookup must be in the // secondary meta-&gt;nonmeta table. addNonMetaClass(cls); } else { NXMapInsert(gdb_objc_realized_classes, name, cls); } ASSERT(!(cls-&gt;data()-&gt;flags &amp; RO_META)); // wrong: constructed classes are already realized when they get here // ASSERT(!cls-&gt;isRealized());}/************************************************************************ removeNamedClass* Removes cls from the name =&gt; cls map.* Locking: runtimeLock must be held by the caller**********************************************************************/static void removeNamedClass(Class cls, const char *name){ runtimeLock.assertLocked(); ASSERT(!(cls-&gt;data()-&gt;flags &amp; RO_META)); if (cls == NXMapGet(gdb_objc_realized_classes, name)) { NXMapRemove(gdb_objc_realized_classes, name); } else { // cls has a name collision with another class - don't remove the other // but do remove cls from the secondary metaclass-&gt;class map. removeNonMetaClass(cls); }}/************************************************************************ futureNamedClasses* Returns the classname =&gt; future class map for unrealized future classes.* Locking: runtimeLock must be held by the caller**********************************************************************/static NXMapTable *future_named_class_map = nil;static NXMapTable *futureNamedClasses(){ runtimeLock.assertLocked(); if (future_named_class_map) return future_named_class_map; // future_named_class_map is big enough for CF's classes and a few others future_named_class_map = NXCreateMapTable(NXStrValueMapPrototype, 32); return future_named_class_map;}static bool haveFutureNamedClasses() { return future_named_class_map &amp;&amp; NXCountMapTable(future_named_class_map);}/************************************************************************ addFutureNamedClass* Installs cls as the class structure to use for the named class if it appears.* Locking: runtimeLock must be held by the caller**********************************************************************/static void addFutureNamedClass(const char *name, Class cls){ void *old; runtimeLock.assertLocked(); if (PrintFuture) { _objc_inform(&quot;FUTURE: reserving %p for %s&quot;, (void*)cls, name); } class_rw_t *rw = objc::zalloc&lt;class_rw_t&gt;(); class_ro_t *ro = (class_ro_t *)calloc(sizeof(class_ro_t), 1); ro-&gt;name.store(strdupIfMutable(name), std::memory_order_relaxed); rw-&gt;set_ro(ro); cls-&gt;setData(rw); cls-&gt;data()-&gt;flags = RO_FUTURE; old = NXMapKeyCopyingInsert(futureNamedClasses(), name, cls); ASSERT(!old);}/************************************************************************ popFutureNamedClass* Removes the named class from the unrealized future class list, * because it has been realized.* Returns nil if the name is not used by a future class.* Locking: runtimeLock must be held by the caller**********************************************************************/static Class popFutureNamedClass(const char *name){ runtimeLock.assertLocked(); Class cls = nil; if (future_named_class_map) { cls = (Class)NXMapKeyFreeingRemove(future_named_class_map, name); if (cls &amp;&amp; NXCountMapTable(future_named_class_map) == 0) { NXFreeMapTable(future_named_class_map); future_named_class_map = nil; } } return cls;}/************************************************************************ remappedClasses* Returns the oldClass =&gt; newClass map for realized future classes.* Returns the oldClass =&gt; nil map for ignored weak-linked classes.* Locking: runtimeLock must be read- or write-locked by the caller**********************************************************************/static objc::DenseMap&lt;Class, Class&gt; *remappedClasses(bool create){ static objc::LazyInitDenseMap&lt;Class, Class&gt; remapped_class_map; runtimeLock.assertLocked(); // start big enough to hold CF's classes and a few others return remapped_class_map.get(create, 32);}/************************************************************************ noClassesRemapped* Returns YES if no classes have been remapped* Locking: runtimeLock must be read- or write-locked by the caller**********************************************************************/static bool noClassesRemapped(void){ runtimeLock.assertLocked(); bool result = (remappedClasses(NO) == nil);#if DEBUG // Catch construction of an empty table, which defeats optimization. auto *map = remappedClasses(NO); if (map) ASSERT(map-&gt;size() &gt; 0);#endif return result;}/************************************************************************ addRemappedClass* newcls is a realized future class, replacing oldcls.* OR newcls is nil, replacing ignored weak-linked class oldcls.* Locking: runtimeLock must be write-locked by the caller**********************************************************************/static void addRemappedClass(Class oldcls, Class newcls){ runtimeLock.assertLocked(); if (PrintFuture) { _objc_inform(&quot;FUTURE: using %p instead of %p for %s&quot;, (void*)newcls, (void*)oldcls, oldcls-&gt;nameForLogging()); } auto result = remappedClasses(YES)-&gt;insert({ oldcls, newcls });#if DEBUG if (!std::get&lt;1&gt;(result)) { // An existing mapping was overwritten. This is not allowed // unless it was to nil. auto iterator = std::get&lt;0&gt;(result); auto value = std::get&lt;1&gt;(*iterator); ASSERT(value == nil); }#else (void)result;#endif}/************************************************************************ remapClass* Returns the live class pointer for cls, which may be pointing to * a class struct that has been reallocated.* Returns nil if cls is ignored because of weak linking.* Locking: runtimeLock must be read- or write-locked by the caller**********************************************************************/static Class remapClass(Class cls){ runtimeLock.assertLocked(); if (!cls) return nil; auto *map = remappedClasses(NO); if (!map) return cls; auto iterator = map-&gt;find(cls); if (iterator == map-&gt;end()) return cls; return std::get&lt;1&gt;(*iterator);}static Class remapClass(classref_t cls){ return remapClass((Class)cls);}Class _class_remap(Class cls){ mutex_locker_t lock(runtimeLock); return remapClass(cls);}/************************************************************************ remapClassRef* Fix up a class ref, in case the class referenced has been reallocated * or is an ignored weak-linked class.* Locking: runtimeLock must be read- or write-locked by the caller**********************************************************************/static void remapClassRef(Class *clsref){ runtimeLock.assertLocked(); Class newcls = remapClass(*clsref); if (*clsref != newcls) *clsref = newcls;}_Nullable Classobjc_loadClassref(_Nullable Class * _Nonnull clsref){ auto *atomicClsref = explicit_atomic&lt;uintptr_t&gt;::from_pointer((uintptr_t *)clsref); uintptr_t cls = atomicClsref-&gt;load(std::memory_order_relaxed); if (fastpath((cls &amp; 1) == 0)) return (Class)cls; auto stub = (stub_class_t *)(cls &amp; ~1ULL); Class initialized = stub-&gt;initializer((Class)stub, nil); atomicClsref-&gt;store((uintptr_t)initialized, std::memory_order_relaxed); return initialized;}/************************************************************************ getMaybeUnrealizedNonMetaClass* Return the ordinary class for this class or metaclass. * `inst` is an instance of `cls` or a subclass thereof, or nil. * Non-nil inst is faster.* The result may be unrealized.* Used by +initialize. * Locking: runtimeLock must be read- or write-locked by the caller**********************************************************************/static Class getMaybeUnrealizedNonMetaClass(Class metacls, id inst){ static int total, named, secondary, sharedcache, dyld3; runtimeLock.assertLocked(); ASSERT(metacls-&gt;isRealized()); total++; // return cls itself if it's already a non-meta class if (!metacls-&gt;isMetaClass()) return metacls; // metacls really is a metaclass // which means inst (if any) is a class // special case for root metaclass // where inst == inst-&gt;ISA() == metacls is possible if (metacls-&gt;ISA() == metacls) { Class cls = metacls-&gt;getSuperclass(); ASSERT(cls-&gt;isRealized()); ASSERT(!cls-&gt;isMetaClass()); ASSERT(cls-&gt;ISA() == metacls); if (cls-&gt;ISA() == metacls) return cls; } // use inst if available if (inst) { Class cls = remapClass((Class)inst); // cls may be a subclass - find the real class for metacls // fixme this probably stops working once Swift starts // reallocating classes if cls is unrealized. while (cls) { if (cls-&gt;ISA() == metacls) { ASSERT(!cls-&gt;isMetaClassMaybeUnrealized()); return cls; } cls = cls-&gt;getSuperclass(); }#if DEBUG _objc_fatal(&quot;cls is not an instance of metacls&quot;);#else // release build: be forgiving and fall through to slow lookups#endif } // See if the metaclass has a pointer to its nonmetaclass. if (Class cls = metacls-&gt;bits.safe_ro()-&gt;getNonMetaclass()) return cls; // try name lookup { Class cls = getClassExceptSomeSwift(metacls-&gt;mangledName()); if (cls &amp;&amp; cls-&gt;ISA() == metacls) { named++; if (PrintInitializing) { _objc_inform(&quot;INITIALIZE: %d/%d (%g%%) &quot; &quot;successful by-name metaclass lookups&quot;, named, total, named*100.0/total); } return cls; } } // try secondary table { Class cls = (Class)NXMapGet(nonMetaClasses(), metacls); if (cls) { secondary++; if (PrintInitializing) { _objc_inform(&quot;INITIALIZE: %d/%d (%g%%) &quot; &quot;successful secondary metaclass lookups&quot;, secondary, total, secondary*100.0/total); } ASSERT(cls-&gt;ISA() == metacls); return cls; } } // try the dyld closure table if (isPreoptimized()) { // Try table from dyld closure first. It was built to ignore the dupes it // knows will come from the cache, so anything left in here was there when // we launched Class cls = nil; // Note, we have to pass the lambda directly here as otherwise we would try // message copy and autorelease. _dyld_for_each_objc_class(metacls-&gt;mangledName(), [&amp;cls, metacls](void* classPtr, bool isLoaded, bool* stop) { // Skip images which aren't loaded. This supports the case where dyld // might soft link an image from the main binary so its possibly not // loaded yet. if (!isLoaded) return; // Found a loaded image with this class name, so check if its the right one Class result = (Class)classPtr; if (result-&gt;ISA() == metacls) { cls = result; *stop = true; } }); if (cls) { dyld3++; if (PrintInitializing) { _objc_inform(&quot;INITIALIZE: %d/%d (%g%%) &quot; &quot;successful dyld closure metaclass lookups&quot;, dyld3, total, dyld3*100.0/total); } return cls; } } // try any duplicates in the dyld shared cache { Class cls = nil; int count; Class *classes = copyPreoptimizedClasses(metacls-&gt;mangledName(),&amp;count); if (classes) { for (int i = 0; i &lt; count; i++) { if (classes[i]-&gt;ISA() == metacls) { cls = classes[i]; break; } } free(classes); } if (cls) { sharedcache++; if (PrintInitializing) { _objc_inform(&quot;INITIALIZE: %d/%d (%g%%) &quot; &quot;successful shared cache metaclass lookups&quot;, sharedcache, total, sharedcache*100.0/total); } return cls; } } _objc_fatal(&quot;no class for metaclass %p&quot;, (void*)metacls);}/************************************************************************ class_initialize. Send the '+initialize' message on demand to any* uninitialized class. Force initialization of superclasses first.* inst is an instance of cls, or nil. Non-nil is better for performance.* Returns the class pointer. If the class was unrealized then * it may be reallocated.* Locking: * runtimeLock must be held by the caller* This function may drop the lock.* On exit the lock is re-acquired or dropped as requested by leaveLocked.**********************************************************************/static Class initializeAndMaybeRelock(Class cls, id inst, mutex_t&amp; lock, bool leaveLocked){ lock.assertLocked(); ASSERT(cls-&gt;isRealized()); if (cls-&gt;isInitialized()) { if (!leaveLocked) lock.unlock(); return cls; } // Find the non-meta class for cls, if it is not already one. // The +initialize message is sent to the non-meta class object. Class nonmeta = getMaybeUnrealizedNonMetaClass(cls, inst); // Realize the non-meta class if necessary. if (nonmeta-&gt;isRealized()) { // nonmeta is cls, which was already realized // OR nonmeta is distinct, but is already realized // - nothing else to do lock.unlock(); } else { nonmeta = realizeClassMaybeSwiftAndUnlock(nonmeta, lock); // runtimeLock is now unlocked // fixme Swift can't relocate the class today, // but someday it will: cls = object_getClass(nonmeta); } // runtimeLock is now unlocked, for +initialize dispatch ASSERT(nonmeta-&gt;isRealized()); initializeNonMetaClass(nonmeta); if (leaveLocked) runtimeLock.lock(); return cls;}// Locking: acquires runtimeLockClass class_initialize(Class cls, id obj){ runtimeLock.lock(); return initializeAndMaybeRelock(cls, obj, runtimeLock, false);}// Locking: caller must hold runtimeLock; this may drop and re-acquire itstatic Class initializeAndLeaveLocked(Class cls, id obj, mutex_t&amp; lock){ return initializeAndMaybeRelock(cls, obj, lock, true);}/************************************************************************ addRootClass* Adds cls as a new realized root class.* Locking: runtimeLock must be held by the caller.**********************************************************************/static void addRootClass(Class cls){ runtimeLock.assertLocked(); ASSERT(cls-&gt;isRealized()); objc_debug_realized_class_generation_count++; cls-&gt;data()-&gt;nextSiblingClass = _firstRealizedClass; _firstRealizedClass = cls;}static void removeRootClass(Class cls){ runtimeLock.assertLocked(); objc_debug_realized_class_generation_count++; Class *classp; for (classp = &amp;_firstRealizedClass; *classp != cls; classp = &amp;(*classp)-&gt;data()-&gt;nextSiblingClass) { } *classp = (*classp)-&gt;data()-&gt;nextSiblingClass;}/************************************************************************ addSubclass* Adds subcls as a subclass of supercls.* Locking: runtimeLock must be held by the caller.**********************************************************************/static void addSubclass(Class supercls, Class subcls){ runtimeLock.assertLocked(); if (supercls &amp;&amp; subcls) { ASSERT(supercls-&gt;isRealized()); ASSERT(subcls-&gt;isRealized()); objc_debug_realized_class_generation_count++; subcls-&gt;data()-&gt;nextSiblingClass = supercls-&gt;data()-&gt;firstSubclass; supercls-&gt;data()-&gt;firstSubclass = subcls; if (supercls-&gt;hasCxxCtor()) { subcls-&gt;setHasCxxCtor(); } if (supercls-&gt;hasCxxDtor()) { subcls-&gt;setHasCxxDtor(); } objc::AWZScanner::scanAddedSubClass(subcls, supercls); objc::RRScanner::scanAddedSubClass(subcls, supercls); objc::CoreScanner::scanAddedSubClass(subcls, supercls); if (!supercls-&gt;allowsPreoptCaches()) { subcls-&gt;setDisallowPreoptCachesRecursively(__func__); } else if (!supercls-&gt;allowsPreoptInlinedSels()) { subcls-&gt;setDisallowPreoptInlinedSelsRecursively(__func__); } // Special case: instancesRequireRawIsa does not propagate // from root class to root metaclass if (supercls-&gt;instancesRequireRawIsa() &amp;&amp; supercls-&gt;getSuperclass()) { subcls-&gt;setInstancesRequireRawIsaRecursively(true); } }}/************************************************************************ removeSubclass* Removes subcls as a subclass of supercls.* Locking: runtimeLock must be held by the caller.**********************************************************************/static void removeSubclass(Class supercls, Class subcls){ runtimeLock.assertLocked(); ASSERT(supercls-&gt;isRealized()); ASSERT(subcls-&gt;isRealized()); ASSERT(subcls-&gt;getSuperclass() == supercls); objc_debug_realized_class_generation_count++; Class *cp; for (cp = &amp;supercls-&gt;data()-&gt;firstSubclass; *cp &amp;&amp; *cp != subcls; cp = &amp;(*cp)-&gt;data()-&gt;nextSiblingClass) ; ASSERT(*cp == subcls); *cp = subcls-&gt;data()-&gt;nextSiblingClass;}/************************************************************************ protocols* Returns the protocol name =&gt; protocol map for protocols.* Locking: runtimeLock must read- or write-locked by the caller**********************************************************************/static NXMapTable *protocols(void){ static NXMapTable *protocol_map = nil; runtimeLock.assertLocked(); INIT_ONCE_PTR(protocol_map, NXCreateMapTable(NXStrValueMapPrototype, 16), NXFreeMapTable(v) ); return protocol_map;}/************************************************************************ getProtocol* Looks up a protocol by name. Demangled Swift names are recognized.* Locking: runtimeLock must be read- or write-locked by the caller.**********************************************************************/static NEVER_INLINE Protocol *getProtocol(const char *name){ runtimeLock.assertLocked(); // Try name as-is. Protocol *result = (Protocol *)NXMapGet(protocols(), name); if (result) return result; // Try table from dyld3 closure and dyld shared cache result = getPreoptimizedProtocol(name); if (result) return result; // Try Swift-mangled equivalent of the given name. if (char *swName = copySwiftV1MangledName(name, true/*isProtocol*/)) { result = (Protocol *)NXMapGet(protocols(), swName); // Try table from dyld3 closure and dyld shared cache if (!result) result = getPreoptimizedProtocol(swName); free(swName); return result; } return nullptr;}/************************************************************************ remapProtocol* Returns the live protocol pointer for proto, which may be pointing to * a protocol struct that has been reallocated.* Locking: runtimeLock must be read- or write-locked by the caller**********************************************************************/static ALWAYS_INLINE protocol_t *remapProtocol(protocol_ref_t proto){ runtimeLock.assertLocked(); // Protocols in shared cache images have a canonical bit to mark that they // are the definition we should use if (((protocol_t *)proto)-&gt;isCanonical()) return (protocol_t *)proto; protocol_t *newproto = (protocol_t *) getProtocol(((protocol_t *)proto)-&gt;mangledName); return newproto ? newproto : (protocol_t *)proto;}/************************************************************************ remapProtocolRef* Fix up a protocol ref, in case the protocol referenced has been reallocated.* Locking: runtimeLock must be read- or write-locked by the caller**********************************************************************/static size_t UnfixedProtocolReferences;static void remapProtocolRef(protocol_t **protoref){ runtimeLock.assertLocked(); protocol_t *newproto = remapProtocol((protocol_ref_t)*protoref); if (*protoref != newproto) { *protoref = newproto; UnfixedProtocolReferences++; }}/************************************************************************ moveIvars* Slides a class's ivars to accommodate the given superclass size.* Ivars are NOT compacted to compensate for a superclass that shrunk.* Locking: runtimeLock must be held by the caller.**********************************************************************/static void moveIvars(class_ro_t *ro, uint32_t superSize){ runtimeLock.assertLocked(); uint32_t diff; ASSERT(superSize &gt; ro-&gt;instanceStart); diff = superSize - ro-&gt;instanceStart; if (ro-&gt;ivars) { // Find maximum alignment in this class's ivars uint32_t maxAlignment = 1; for (const auto&amp; ivar : *ro-&gt;ivars) { if (!ivar.offset) continue; // anonymous bitfield uint32_t alignment = ivar.alignment(); if (alignment &gt; maxAlignment) maxAlignment = alignment; } // Compute a slide value that preserves that alignment uint32_t alignMask = maxAlignment - 1; diff = (diff + alignMask) &amp; ~alignMask; // Slide all of this class's ivars en masse for (const auto&amp; ivar : *ro-&gt;ivars) { if (!ivar.offset) continue; // anonymous bitfield uint32_t oldOffset = (uint32_t)*ivar.offset; uint32_t newOffset = oldOffset + diff; *ivar.offset = newOffset; if (PrintIvars) { _objc_inform(&quot;IVARS: offset %u -&gt; %u for %s &quot; &quot;(size %u, align %u)&quot;, oldOffset, newOffset, ivar.name, ivar.size, ivar.alignment()); } } } *(uint32_t *)&amp;ro-&gt;instanceStart += diff; *(uint32_t *)&amp;ro-&gt;instanceSize += diff;}static void reconcileInstanceVariables(Class cls, Class supercls, const class_ro_t*&amp; ro) { class_rw_t *rw = cls-&gt;data(); ASSERT(supercls); ASSERT(!cls-&gt;isMetaClass()); /* debug: print them all before sliding if (ro-&gt;ivars) { for (const auto&amp; ivar : *ro-&gt;ivars) { if (!ivar.offset) continue; // anonymous bitfield _objc_inform(&quot;IVARS: %s.%s (offset %u, size %u, align %u)&quot;, ro-&gt;name, ivar.name, *ivar.offset, ivar.size, ivar.alignment()); } } */ // Non-fragile ivars - reconcile this class with its superclass const class_ro_t *super_ro = supercls-&gt;data()-&gt;ro(); if (DebugNonFragileIvars) { // Debugging: Force non-fragile ivars to slide. // Intended to find compiler, runtime, and program bugs. // If it fails with this and works without, you have a problem. // Operation: Reset everything to 0 + misalignment. // Then force the normal sliding logic to push everything back. // Exceptions: root classes, metaclasses, *NSCF* classes, // __CF* classes, NSConstantString, NSSimpleCString // (already know it's not root because supercls != nil) const char *clsname = cls-&gt;mangledName(); if (!strstr(clsname, &quot;NSCF&quot;) &amp;&amp; 0 != strncmp(clsname, &quot;__CF&quot;, 4) &amp;&amp; 0 != strcmp(clsname, &quot;NSConstantString&quot;) &amp;&amp; 0 != strcmp(clsname, &quot;NSSimpleCString&quot;)) { uint32_t oldStart = ro-&gt;instanceStart; class_ro_t *ro_w = make_ro_writeable(rw); ro = rw-&gt;ro(); // Find max ivar alignment in class. // default to word size to simplify ivar update uint32_t alignment = 1&lt;&lt;WORD_SHIFT; if (ro-&gt;ivars) { for (const auto&amp; ivar : *ro-&gt;ivars) { if (ivar.alignment() &gt; alignment) { alignment = ivar.alignment(); } } } uint32_t misalignment = ro-&gt;instanceStart % alignment; uint32_t delta = ro-&gt;instanceStart - misalignment; ro_w-&gt;instanceStart = misalignment; ro_w-&gt;instanceSize -= delta; if (PrintIvars) { _objc_inform(&quot;IVARS: DEBUG: forcing ivars for class '%s' &quot; &quot;to slide (instanceStart %zu -&gt; %zu)&quot;, cls-&gt;nameForLogging(), (size_t)oldStart, (size_t)ro-&gt;instanceStart); } if (ro-&gt;ivars) { for (const auto&amp; ivar : *ro-&gt;ivars) { if (!ivar.offset) continue; // anonymous bitfield *ivar.offset -= delta; } } } } if (ro-&gt;instanceStart &gt;= super_ro-&gt;instanceSize) { // Superclass has not overgrown its space. We're done here. return; } // fixme can optimize for &quot;class has no new ivars&quot;, etc if (ro-&gt;instanceStart &lt; super_ro-&gt;instanceSize) { // Superclass has changed size. This class's ivars must move. // Also slide layout bits in parallel. // This code is incapable of compacting the subclass to // compensate for a superclass that shrunk, so don't do that. if (PrintIvars) { _objc_inform(&quot;IVARS: sliding ivars for class %s &quot; &quot;(superclass was %u bytes, now %u)&quot;, cls-&gt;nameForLogging(), ro-&gt;instanceStart, super_ro-&gt;instanceSize); } class_ro_t *ro_w = make_ro_writeable(rw); ro = rw-&gt;ro(); moveIvars(ro_w, super_ro-&gt;instanceSize); gdb_objc_class_changed(cls, OBJC_CLASS_IVARS_CHANGED, ro-&gt;getName()); } }static void validateAlreadyRealizedClass(Class cls) { ASSERT(cls-&gt;isRealized());#if TARGET_OS_OSX class_rw_t *rw = cls-&gt;data(); size_t rwSize = malloc_size(rw); // Note: this check will need some adjustment if class_rw_t's // size changes to not match the malloc bucket. if (rwSize != sizeof(class_rw_t)) _objc_fatal(&quot;realized class %p has corrupt data pointer %p&quot;, cls, rw);#endif}/************************************************************************ realizeClassWithoutSwift* Performs first-time initialization on class cls, * including allocating its read-write data.* Does not perform any Swift-side initialization.* Returns the real class structure for the class. * Locking: runtimeLock must be write-locked by the caller**********************************************************************/static Class realizeClassWithoutSwift(Class cls, Class previously){ runtimeLock.assertLocked(); class_rw_t *rw; Class supercls; Class metacls; if (!cls) return nil; if (cls-&gt;isRealized()) { validateAlreadyRealizedClass(cls); return cls; } ASSERT(cls == remapClass(cls)); // fixme verify class is not in an un-dlopened part of the shared cache? auto ro = (const class_ro_t *)cls-&gt;data(); auto isMeta = ro-&gt;flags &amp; RO_META; if (ro-&gt;flags &amp; RO_FUTURE) { // This was a future class. rw data is already allocated. rw = cls-&gt;data(); ro = cls-&gt;data()-&gt;ro(); ASSERT(!isMeta); cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE); } else { // Normal class. Allocate writeable class data. rw = objc::zalloc&lt;class_rw_t&gt;(); rw-&gt;set_ro(ro); rw-&gt;flags = RW_REALIZED|RW_REALIZING|isMeta; cls-&gt;setData(rw); } cls-&gt;cache.initializeToEmptyOrPreoptimizedInDisguise();#if FAST_CACHE_META if (isMeta) cls-&gt;cache.setBit(FAST_CACHE_META);#endif // Choose an index for this class. // Sets cls-&gt;instancesRequireRawIsa if indexes no more indexes are available cls-&gt;chooseClassArrayIndex(); if (PrintConnecting) { _objc_inform(&quot;CLASS: realizing class '%s'%s %p %p #%u %s%s&quot;, cls-&gt;nameForLogging(), isMeta ? &quot; (meta)&quot; : &quot;&quot;, (void*)cls, ro, cls-&gt;classArrayIndex(), cls-&gt;isSwiftStable() ? &quot;(swift)&quot; : &quot;&quot;, cls-&gt;isSwiftLegacy() ? &quot;(pre-stable swift)&quot; : &quot;&quot;); } // Realize superclass and metaclass, if they aren't already. // This needs to be done after RW_REALIZED is set above, for root classes. // This needs to be done after class index is chosen, for root metaclasses. // This assumes that none of those classes have Swift contents, // or that Swift's initializers have already been called. // fixme that assumption will be wrong if we add support // for ObjC subclasses of Swift classes. supercls = realizeClassWithoutSwift(remapClass(cls-&gt;getSuperclass()), nil); metacls = realizeClassWithoutSwift(remapClass(cls-&gt;ISA()), nil);#if SUPPORT_NONPOINTER_ISA if (isMeta) { // Metaclasses do not need any features from non pointer ISA // This allows for a faspath for classes in objc_retain/objc_release. cls-&gt;setInstancesRequireRawIsa(); } else { // Disable non-pointer isa for some classes and/or platforms. // Set instancesRequireRawIsa. bool instancesRequireRawIsa = cls-&gt;instancesRequireRawIsa(); bool rawIsaIsInherited = false; static bool hackedDispatch = false; if (DisableNonpointerIsa) { // Non-pointer isa disabled by environment or app SDK version instancesRequireRawIsa = true; } else if (!hackedDispatch &amp;&amp; 0 == strcmp(ro-&gt;getName(), &quot;OS_object&quot;)) { // hack for libdispatch et al - isa also acts as vtable pointer hackedDispatch = true; instancesRequireRawIsa = true; } else if (supercls &amp;&amp; supercls-&gt;getSuperclass() &amp;&amp; supercls-&gt;instancesRequireRawIsa()) { // This is also propagated by addSubclass() // but nonpointer isa setup needs it earlier. // Special case: instancesRequireRawIsa does not propagate // from root class to root metaclass instancesRequireRawIsa = true; rawIsaIsInherited = true; } if (instancesRequireRawIsa) { cls-&gt;setInstancesRequireRawIsaRecursively(rawIsaIsInherited); } }// SUPPORT_NONPOINTER_ISA#endif // Update superclass and metaclass in case of remapping cls-&gt;setSuperclass(supercls); cls-&gt;initClassIsa(metacls); // Reconcile instance variable offsets / layout. // This may reallocate class_ro_t, updating our ro variable. if (supercls &amp;&amp; !isMeta) reconcileInstanceVariables(cls, supercls, ro); // Set fastInstanceSize if it wasn't set already. cls-&gt;setInstanceSize(ro-&gt;instanceSize); // Copy some flags from ro to rw if (ro-&gt;flags &amp; RO_HAS_CXX_STRUCTORS) { cls-&gt;setHasCxxDtor(); if (! (ro-&gt;flags &amp; RO_HAS_CXX_DTOR_ONLY)) { cls-&gt;setHasCxxCtor(); } } // Propagate the associated objects forbidden flag from ro or from // the superclass. if ((ro-&gt;flags &amp; RO_FORBIDS_ASSOCIATED_OBJECTS) || (supercls &amp;&amp; supercls-&gt;forbidsAssociatedObjects())) { rw-&gt;flags |= RW_FORBIDS_ASSOCIATED_OBJECTS; } // Connect this class to its superclass's subclass lists if (supercls) { addSubclass(supercls, cls); } else { addRootClass(cls); } // Attach categories methodizeClass(cls, previously); return cls;}/************************************************************************ _objc_realizeClassFromSwift* Called by Swift when it needs the ObjC part of a class to be realized.* There are four cases:* 1. cls != nil; previously == cls* Class cls is being realized in place* 2. cls != nil; previously == nil* Class cls is being constructed at runtime* 3. cls != nil; previously != cls* The class that was at previously has been reallocated to cls* 4. cls == nil, previously != nil* The class at previously is hereby disavowed** Only variants #1 and #2 are supported today.** Locking: acquires runtimeLock**********************************************************************/Class _objc_realizeClassFromSwift(Class cls, void *previously){ if (cls) { if (previously &amp;&amp; previously != (void*)cls) { // #3: relocation mutex_locker_t lock(runtimeLock); addRemappedClass((Class)previously, cls); addClassTableEntry(cls); addNamedClass(cls, cls-&gt;mangledName(), /*replacing*/nil); return realizeClassWithoutSwift(cls, (Class)previously); } else { // #1 and #2: realization in place, or new class mutex_locker_t lock(runtimeLock); if (!previously) { // #2: new class cls = readClass(cls, false/*bundle*/, false/*shared cache*/); } // #1 and #2: realization in place, or new class // We ignore the Swift metadata initializer callback. // We assume that's all handled since we're being called from Swift. return realizeClassWithoutSwift(cls, nil); } } else { // #4: disavowal // In the future this will mean remapping the old address to nil // and if necessary removing the old address from any other tables. _objc_fatal(&quot;Swift requested that class %p be ignored, &quot; &quot;but libobjc does not support that.&quot;, previously); }}/************************************************************************ realizeSwiftClass* Performs first-time initialization on class cls, * including allocating its read-write data, * and any Swift-side initialization.* Returns the real class structure for the class. * Locking: acquires runtimeLock indirectly**********************************************************************/static Class realizeSwiftClass(Class cls){ runtimeLock.assertUnlocked(); // Some assumptions: // * Metaclasses never have a Swift initializer. // * Root classes never have a Swift initializer. // (These two together avoid initialization order problems at the root.) // * Unrealized non-Swift classes have no Swift ancestry. // * Unrealized Swift classes with no initializer have no ancestry that // does have the initializer. // (These two together mean we don't need to scan superclasses here // and we don't need to worry about Swift superclasses inside // realizeClassWithoutSwift()). // fixme some of these assumptions will be wrong // if we add support for ObjC sublasses of Swift classes.#if DEBUG runtimeLock.lock(); ASSERT(remapClass(cls) == cls); ASSERT(cls-&gt;isSwiftStable_ButAllowLegacyForNow()); ASSERT(!cls-&gt;isMetaClassMaybeUnrealized()); ASSERT(cls-&gt;getSuperclass()); runtimeLock.unlock();#endif // Look for a Swift metadata initialization function // installed on the class. If it is present we call it. // That function in turn initializes the Swift metadata, // prepares the &quot;compiler-generated&quot; ObjC metadata if not // already present, and calls _objc_realizeSwiftClass() to finish // our own initialization. if (auto init = cls-&gt;swiftMetadataInitializer()) { if (PrintConnecting) { _objc_inform(&quot;CLASS: calling Swift metadata initializer &quot; &quot;for class '%s' (%p)&quot;, cls-&gt;nameForLogging(), cls); } Class newcls = init(cls, nil); // fixme someday Swift will need to relocate classes at this point, // but we don't accept that yet. if (cls != newcls) { mutex_locker_t lock(runtimeLock); addRemappedClass(cls, newcls); } return newcls; } else { // No Swift-side initialization callback. // Perform our own realization directly. mutex_locker_t lock(runtimeLock); return realizeClassWithoutSwift(cls, nil); }}/************************************************************************ realizeClassMaybeSwift (MaybeRelock / AndUnlock / AndLeaveLocked)* Realize a class that might be a Swift class.* Returns the real class structure for the class. * Locking: * runtimeLock must be held on entry* runtimeLock may be dropped during execution* ...AndUnlock function leaves runtimeLock unlocked on exit* ...AndLeaveLocked re-acquires runtimeLock if it was dropped* This complication avoids repeated lock transitions in some cases.**********************************************************************/static ClassrealizeClassMaybeSwiftMaybeRelock(Class cls, mutex_t&amp; lock, bool leaveLocked){ lock.assertLocked(); if (!cls-&gt;isSwiftStable_ButAllowLegacyForNow()) { // Non-Swift class. Realize it now with the lock still held. // fixme wrong in the future for objc subclasses of swift classes realizeClassWithoutSwift(cls, nil); if (!leaveLocked) lock.unlock(); } else { // Swift class. We need to drop locks and call the Swift // runtime to initialize it. lock.unlock(); cls = realizeSwiftClass(cls); ASSERT(cls-&gt;isRealized()); // callback must have provoked realization if (leaveLocked) lock.lock(); } return cls;}static ClassrealizeClassMaybeSwiftAndUnlock(Class cls, mutex_t&amp; lock){ return realizeClassMaybeSwiftMaybeRelock(cls, lock, false);}static ClassrealizeClassMaybeSwiftAndLeaveLocked(Class cls, mutex_t&amp; lock){ return realizeClassMaybeSwiftMaybeRelock(cls, lock, true);}/************************************************************************ missingWeakSuperclass* Return YES if some superclass of cls was weak-linked and is missing.**********************************************************************/static bool missingWeakSuperclass(Class cls){ ASSERT(!cls-&gt;isRealized()); if (!cls-&gt;getSuperclass()) { // superclass nil. This is normal for root classes only. return (!(cls-&gt;data()-&gt;flags &amp; RO_ROOT)); } else { // superclass not nil. Check if a higher superclass is missing. Class supercls = remapClass(cls-&gt;getSuperclass()); ASSERT(cls != cls-&gt;getSuperclass()); ASSERT(cls != supercls); if (!supercls) return YES; if (supercls-&gt;isRealized()) return NO; return missingWeakSuperclass(supercls); }}/************************************************************************ realizeAllClassesInImage* Non-lazily realizes all unrealized classes in the given image.* Locking: runtimeLock must be held by the caller.* Locking: this function may drop and re-acquire the lock.**********************************************************************/static void realizeAllClassesInImage(header_info *hi){ runtimeLock.assertLocked(); size_t count, i; classref_t const *classlist; if (hi-&gt;areAllClassesRealized()) return; classlist = _getObjc2ClassList(hi, &amp;count); for (i = 0; i &lt; count; i++) { Class cls = remapClass(classlist[i]); if (cls) { realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock); } } hi-&gt;setAllClassesRealized(YES);}/************************************************************************ realizeAllClasses* Non-lazily realizes all unrealized classes in all known images.* Locking: runtimeLock must be held by the caller.* Locking: this function may drop and re-acquire the lock.* Dropping the lock makes this function thread-unsafe with respect * to concurrent image unload, but the callers of this function * already ultimately do something that is also thread-unsafe with * respect to image unload (such as using the list of all classes).**********************************************************************/static void realizeAllClasses(void){ runtimeLock.assertLocked(); header_info *hi; for (hi = FirstHeader; hi; hi = hi-&gt;getNext()) { realizeAllClassesInImage(hi); // may drop and re-acquire runtimeLock }}/************************************************************************ _objc_allocateFutureClass* Allocate an unresolved future class for the given class name.* Returns any existing allocation if one was already made.* Assumes the named class doesn't exist yet.* Locking: acquires runtimeLock**********************************************************************/Class _objc_allocateFutureClass(const char *name){ mutex_locker_t lock(runtimeLock); Class cls; NXMapTable *map = futureNamedClasses(); if ((cls = (Class)NXMapGet(map, name))) { // Already have a future class for this name. return cls; } cls = _calloc_class(sizeof(objc_class)); addFutureNamedClass(name, cls); return cls;}/************************************************************************ objc_getFutureClass. Return the id of the named class.* If the class does not exist, return an uninitialized class * structure that will be used for the class when and if it * does get loaded.* Not thread safe. **********************************************************************/Class objc_getFutureClass(const char *name){ Class cls; // YES unconnected, NO class handler // (unconnected is OK because it will someday be the real class) cls = look_up_class(name, YES, NO); if (cls) { if (PrintFuture) { _objc_inform(&quot;FUTURE: found %p already in use for %s&quot;, (void*)cls, name); } return cls; } // No class or future class with that name yet. Make one. // fixme not thread-safe with respect to // simultaneous library load or getFutureClass. return _objc_allocateFutureClass(name);}BOOL _class_isFutureClass(Class cls){ return cls &amp;&amp; cls-&gt;isFuture();}BOOL _class_isSwift(Class _Nullable cls){ return cls &amp;&amp; cls-&gt;isSwiftStable();}/************************************************************************ _objc_flush_caches* Flushes all caches.* (Historical behavior: flush caches for cls, its metaclass, * and subclasses thereof. Nil flushes all classes.)* Locking: acquires runtimeLock**********************************************************************/static void flushCaches(Class cls, const char *func, bool (^predicate)(Class)){ runtimeLock.assertLocked();#if CONFIG_USE_CACHE_LOCK mutex_locker_t lock(cacheUpdateLock);#endif const auto handler = ^(Class c) { if (predicate(c)) { c-&gt;cache.eraseNolock(func); } return true; }; if (cls) { foreach_realized_class_and_subclass(cls, handler); } else { foreach_realized_class_and_metaclass(handler); }}void _objc_flush_caches(Class cls){ { mutex_locker_t lock(runtimeLock); flushCaches(cls, __func__, [](Class c){ return !c-&gt;cache.isConstantOptimizedCache(); }); if (cls &amp;&amp; !cls-&gt;isMetaClass() &amp;&amp; !cls-&gt;isRootClass()) { flushCaches(cls-&gt;ISA(), __func__, [](Class c){ return !c-&gt;cache.isConstantOptimizedCache(); }); } else { // cls is a root class or root metaclass. Its metaclass is itself // or a subclass so the metaclass caches were already flushed. } } if (!cls) { // collectALot if cls==nil#if CONFIG_USE_CACHE_LOCK mutex_locker_t lock(cacheUpdateLock);#else mutex_locker_t lock(runtimeLock);#endif cache_t::collectNolock(true); }}/************************************************************************ map_images* Process the given images which are being mapped in by dyld.* Calls ABI-agnostic code after taking ABI-specific locks.** Locking: write-locks runtimeLock**********************************************************************/voidmap_images(unsigned count, const char * const paths[], const struct mach_header * const mhdrs[]){ mutex_locker_t lock(runtimeLock); return map_images_nolock(count, paths, mhdrs);}static void load_categories_nolock(header_info *hi) { bool hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties(); size_t count; auto processCatlist = [&amp;](category_t * const *catlist) { for (unsigned i = 0; i &lt; count; i++) { category_t *cat = catlist[i]; Class cls = remapClass(cat-&gt;cls); locstamped_category_t lc{cat, hi}; if (!cls) { // Category's target class is missing (probably weak-linked). // Ignore the category. if (PrintConnecting) { _objc_inform(&quot;CLASS: IGNORING category \\?\\?\\?(%s) %p with &quot; &quot;missing weak-linked target class&quot;, cat-&gt;name, cat); } continue; } // Process this category. if (cls-&gt;isStubClass()) { // Stub classes are never realized. Stub classes // don't know their metaclass until they're // initialized, so we have to add categories with // class methods or properties to the stub itself. // methodizeClass() will find them and add them to // the metaclass as appropriate. if (cat-&gt;instanceMethods || cat-&gt;protocols || cat-&gt;instanceProperties || cat-&gt;classMethods || cat-&gt;protocols || (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) { objc::unattachedCategories.addForClass(lc, cls); } } else { // First, register the category with its target class. // Then, rebuild the class's method lists (etc) if // the class is realized. if (cat-&gt;instanceMethods || cat-&gt;protocols || cat-&gt;instanceProperties) { if (cls-&gt;isRealized()) { attachCategories(cls, &amp;lc, 1, ATTACH_EXISTING); } else { objc::unattachedCategories.addForClass(lc, cls); } } if (cat-&gt;classMethods || cat-&gt;protocols || (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) { if (cls-&gt;ISA()-&gt;isRealized()) { attachCategories(cls-&gt;ISA(), &amp;lc, 1, ATTACH_EXISTING | ATTACH_METACLASS); } else { objc::unattachedCategories.addForClass(lc, cls-&gt;ISA()); } } } } }; processCatlist(hi-&gt;catlist(&amp;count)); processCatlist(hi-&gt;catlist2(&amp;count));}static void loadAllCategories() { mutex_locker_t lock(runtimeLock); for (auto *hi = FirstHeader; hi != NULL; hi = hi-&gt;getNext()) { load_categories_nolock(hi); }}/************************************************************************ load_images* Process +load in the given images which are being mapped in by dyld.** Locking: write-locks runtimeLock and loadMethodLock**********************************************************************/extern bool hasLoadMethods(const headerType *mhdr);extern void prepare_load_methods(const headerType *mhdr);voidload_images(const char *path __unused, const struct mach_header *mh){ if (!didInitialAttachCategories &amp;&amp; didCallDyldNotifyRegister) { didInitialAttachCategories = true; loadAllCategories(); } // Return without taking locks if there are no +load methods here. if (!hasLoadMethods((const headerType *)mh)) return; recursive_mutex_locker_t lock(loadMethodLock); // Discover load methods { mutex_locker_t lock2(runtimeLock); prepare_load_methods((const headerType *)mh); } // Call +load methods (without runtimeLock - re-entrant) call_load_methods();}/************************************************************************ unmap_image* Process the given image which is about to be unmapped by dyld.** Locking: write-locks runtimeLock and loadMethodLock**********************************************************************/void unmap_image(const char *path __unused, const struct mach_header *mh){ recursive_mutex_locker_t lock(loadMethodLock); mutex_locker_t lock2(runtimeLock); unmap_image_nolock(mh);}/************************************************************************ mustReadClasses* Preflight check in advance of readClass() from an image.**********************************************************************/bool mustReadClasses(header_info *hi, bool hasDyldRoots){ const char *reason; // If the image is not preoptimized then we must read classes. if (!hi-&gt;hasPreoptimizedClasses()) { reason = nil; // Don't log this one because it is noisy. goto readthem; } // If iOS simulator then we must read classes.#if TARGET_OS_SIMULATOR reason = &quot;the image is for iOS simulator&quot;; goto readthem;#endif ASSERT(!hi-&gt;isBundle()); // no MH_BUNDLE in shared cache // If the image may have missing weak superclasses then we must read classes if (!noMissingWeakSuperclasses() || hasDyldRoots) { reason = &quot;the image may contain classes with missing weak superclasses&quot;; goto readthem; } // If there are unresolved future classes then we must read classes. if (haveFutureNamedClasses()) { reason = &quot;there are unresolved future classes pending&quot;; goto readthem; } // readClass() rewrites bits in backward-deploying Swift stable ABI code. // The assumption here is there there are no such classes // in the dyld shared cache.#if DEBUG { size_t count; classref_t const *classlist = _getObjc2ClassList(hi, &amp;count); for (size_t i = 0; i &lt; count; i++) { Class cls = remapClass(classlist[i]); ASSERT(!cls-&gt;isUnfixedBackwardDeployingStableSwift()); } }#endif // readClass() does not need to do anything. return NO; readthem: if (PrintPreopt &amp;&amp; reason) { _objc_inform(&quot;PREOPTIMIZATION: reading classes manually from %s &quot; &quot;because %s&quot;, hi-&gt;fname(), reason); } return YES;}/************************************************************************ readClass* Read a class and metaclass as written by a compiler.* Returns the new class pointer. This could be: * - cls* - nil (cls has a missing weak-linked superclass)* - something else (space for this class was reserved by a future class)** Note that all work performed by this function is preflighted by * mustReadClasses(). Do not change this function without updating that one.** Locking: runtimeLock acquired by map_images or objc_readClassPair**********************************************************************/Class readClass(Class cls, bool headerIsBundle, bool headerIsPreoptimized){ const char *mangledName = cls-&gt;nonlazyMangledName(); if (missingWeakSuperclass(cls)) { // No superclass (probably weak-linked). // Disavow any knowledge of this subclass. if (PrintConnecting) { _objc_inform(&quot;CLASS: IGNORING class '%s' with &quot; &quot;missing weak-linked superclass&quot;, cls-&gt;nameForLogging()); } addRemappedClass(cls, nil); cls-&gt;setSuperclass(nil); return nil; } cls-&gt;fixupBackwardDeployingStableSwift(); Class replacing = nil; if (mangledName != nullptr) { if (Class newCls = popFutureNamedClass(mangledName)) { // This name was previously allocated as a future class. // Copy objc_class to future class's struct. // Preserve future's rw data block. if (newCls-&gt;isAnySwift()) { _objc_fatal(&quot;Can't complete future class request for '%s' &quot; &quot;because the real class is too big.&quot;, cls-&gt;nameForLogging()); } class_rw_t *rw = newCls-&gt;data(); const class_ro_t *old_ro = rw-&gt;ro(); memcpy(newCls, cls, sizeof(objc_class)); // Manually set address-discriminated ptrauthed fields // so that newCls gets the correct signatures. newCls-&gt;setSuperclass(cls-&gt;getSuperclass()); newCls-&gt;initIsa(cls-&gt;getIsa()); rw-&gt;set_ro((class_ro_t *)newCls-&gt;data()); newCls-&gt;setData(rw); freeIfMutable((char *)old_ro-&gt;getName()); free((void *)old_ro); addRemappedClass(cls, newCls); replacing = cls; cls = newCls; } } if (headerIsPreoptimized &amp;&amp; !replacing) { // class list built in shared cache // fixme strict assert doesn't work because of duplicates // ASSERT(cls == getClass(name)); ASSERT(mangledName == nullptr || getClassExceptSomeSwift(mangledName)); } else { if (mangledName) { //some Swift generic classes can lazily generate their names addNamedClass(cls, mangledName, replacing); } else { Class meta = cls-&gt;ISA(); const class_ro_t *metaRO = meta-&gt;bits.safe_ro(); ASSERT(metaRO-&gt;getNonMetaclass() &amp;&amp; &quot;Metaclass with lazy name must have a pointer to the corresponding nonmetaclass.&quot;); ASSERT(metaRO-&gt;getNonMetaclass() == cls &amp;&amp; &quot;Metaclass nonmetaclass pointer must equal the original class.&quot;); } addClassTableEntry(cls); } // for future reference: shared cache never contains MH_BUNDLEs if (headerIsBundle) { cls-&gt;data()-&gt;flags |= RO_FROM_BUNDLE; cls-&gt;ISA()-&gt;data()-&gt;flags |= RO_FROM_BUNDLE; } return cls;}/************************************************************************ readProtocol* Read a protocol as written by a compiler.**********************************************************************/static voidreadProtocol(protocol_t *newproto, Class protocol_class, NXMapTable *protocol_map, bool headerIsPreoptimized, bool headerIsBundle){ // This is not enough to make protocols in unloaded bundles safe, // but it does prevent crashes when looking up unrelated protocols. auto insertFn = headerIsBundle ? NXMapKeyCopyingInsert : NXMapInsert; protocol_t *oldproto = (protocol_t *)getProtocol(newproto-&gt;mangledName); if (oldproto) { if (oldproto != newproto) { // Some other definition already won. if (PrintProtocols) { _objc_inform(&quot;PROTOCOLS: protocol at %p is %s &quot; &quot;(duplicate of %p)&quot;, newproto, oldproto-&gt;nameForLogging(), oldproto); } // If we are a shared cache binary then we have a definition of this // protocol, but if another one was chosen then we need to clear our // isCanonical bit so that no-one trusts it. // Note, if getProtocol returned a shared cache protocol then the // canonical definition is already in the shared cache and we don't // need to do anything. if (headerIsPreoptimized &amp;&amp; !oldproto-&gt;isCanonical()) { // Note newproto is an entry in our __objc_protolist section which // for shared cache binaries points to the original protocol in // that binary, not the shared cache uniqued one. auto cacheproto = (protocol_t *) getSharedCachePreoptimizedProtocol(newproto-&gt;mangledName); if (cacheproto &amp;&amp; cacheproto-&gt;isCanonical()) cacheproto-&gt;clearIsCanonical(); } } } else if (headerIsPreoptimized) { // Shared cache initialized the protocol object itself, // but in order to allow out-of-cache replacement we need // to add it to the protocol table now. protocol_t *cacheproto = (protocol_t *) getPreoptimizedProtocol(newproto-&gt;mangledName); protocol_t *installedproto; if (cacheproto &amp;&amp; cacheproto != newproto) { // Another definition in the shared cache wins (because // everything in the cache was fixed up to point to it). installedproto = cacheproto; } else { // This definition wins. installedproto = newproto; } ASSERT(installedproto-&gt;getIsa() == protocol_class); ASSERT(installedproto-&gt;size &gt;= sizeof(protocol_t)); insertFn(protocol_map, installedproto-&gt;mangledName, installedproto); if (PrintProtocols) { _objc_inform(&quot;PROTOCOLS: protocol at %p is %s&quot;, installedproto, installedproto-&gt;nameForLogging()); if (newproto != installedproto) { _objc_inform(&quot;PROTOCOLS: protocol at %p is %s &quot; &quot;(duplicate of %p)&quot;, newproto, installedproto-&gt;nameForLogging(), installedproto); } } } else { // New protocol from an un-preoptimized image. Fix it up in place. // fixme duplicate protocols from unloadable bundle newproto-&gt;initIsa(protocol_class); // fixme pinned insertFn(protocol_map, newproto-&gt;mangledName, newproto); if (PrintProtocols) { _objc_inform(&quot;PROTOCOLS: protocol at %p is %s&quot;, newproto, newproto-&gt;nameForLogging()); } }}/************************************************************************ _read_images* Perform initial processing of the headers in the linked * list beginning with headerList. ** Called by: map_images_nolock** Locking: runtimeLock acquired by map_images**********************************************************************/void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses){ header_info *hi; uint32_t hIndex; size_t count; size_t i; Class *resolvedFutureClasses = nil; size_t resolvedFutureClassCount = 0; static bool doneOnce; bool launchTime = NO; TimeLogger ts(PrintImageTimes); runtimeLock.assertLocked();#define EACH_HEADER \\ hIndex = 0; \\ hIndex &lt; hCount &amp;&amp; (hi = hList[hIndex]); \\ hIndex++ if (!doneOnce) { doneOnce = YES; launchTime = YES;#if SUPPORT_NONPOINTER_ISA // Disable non-pointer isa under some conditions.# if SUPPORT_INDEXED_ISA // Disable nonpointer isa if any image contains old Swift code for (EACH_HEADER) { if (hi-&gt;info()-&gt;containsSwift() &amp;&amp; hi-&gt;info()-&gt;swiftUnstableVersion() &lt; objc_image_info::SwiftVersion3) { DisableNonpointerIsa = true; if (PrintRawIsa) { _objc_inform(&quot;RAW ISA: disabling non-pointer isa because &quot; &quot;the app or a framework contains Swift code &quot; &quot;older than Swift 3.0&quot;); } break; } }# endif# if TARGET_OS_OSX // Disable non-pointer isa if the app is too old // (linked before OS X 10.11)// if (!dyld_program_sdk_at_least(dyld_platform_version_macOS_10_11)) {// DisableNonpointerIsa = true;// if (PrintRawIsa) {// _objc_inform(&quot;RAW ISA: disabling non-pointer isa because &quot;// &quot;the app is too old.&quot;);// }// } // Disable non-pointer isa if the app has a __DATA,__objc_rawisa section // New apps that load old extensions may need this. for (EACH_HEADER) { if (hi-&gt;mhdr()-&gt;filetype != MH_EXECUTE) continue; unsigned long size; if (getsectiondata(hi-&gt;mhdr(), &quot;__DATA&quot;, &quot;__objc_rawisa&quot;, &amp;size)) { DisableNonpointerIsa = true; if (PrintRawIsa) { _objc_inform(&quot;RAW ISA: disabling non-pointer isa because &quot; &quot;the app has a __DATA,__objc_rawisa section&quot;); } } break; // assume only one MH_EXECUTE image }# endif#endif if (DisableTaggedPointers) { disableTaggedPointers(); } initializeTaggedPointerObfuscator(); if (PrintConnecting) { _objc_inform(&quot;CLASS: found %d classes during launch&quot;, totalClasses); } // namedClasses // Preoptimized classes don't go in this table. // 4/3 is NXMapTable's load factor int namedClassesSize = (isPreoptimized() ? unoptimizedTotalClasses : totalClasses) * 4 / 3; gdb_objc_realized_classes = NXCreateMapTable(NXStrValueMapPrototype, namedClassesSize); ts.log(&quot;IMAGE TIMES: first time tasks&quot;); } // Fix up @selector references static size_t UnfixedSelectors; { mutex_locker_t lock(selLock); for (EACH_HEADER) { if (hi-&gt;hasPreoptimizedSelectors()) continue; bool isBundle = hi-&gt;isBundle(); SEL *sels = _getObjc2SelectorRefs(hi, &amp;count); UnfixedSelectors += count; for (i = 0; i &lt; count; i++) { const char *name = sel_cname(sels[i]); SEL sel = sel_registerNameNoLock(name, isBundle); if (sels[i] != sel) { sels[i] = sel; } } } } ts.log(&quot;IMAGE TIMES: fix up selector references&quot;); // Discover classes. Fix up unresolved future classes. Mark bundle classes. bool hasDyldRoots = dyld_shared_cache_some_image_overridden(); for (EACH_HEADER) { if (! mustReadClasses(hi, hasDyldRoots)) { // Image is sufficiently optimized that we need not call readClass() continue; } classref_t const *classlist = _getObjc2ClassList(hi, &amp;count); bool headerIsBundle = hi-&gt;isBundle(); bool headerIsPreoptimized = hi-&gt;hasPreoptimizedClasses(); for (i = 0; i &lt; count; i++) { Class cls = (Class)classlist[i]; Class newCls = readClass(cls, headerIsBundle, headerIsPreoptimized); if (newCls != cls &amp;&amp; newCls) { // Class was moved but not deleted. Currently this occurs // only when the new class resolved a future class. // Non-lazily realize the class below. resolvedFutureClasses = (Class *) realloc(resolvedFutureClasses, (resolvedFutureClassCount+1) * sizeof(Class)); resolvedFutureClasses[resolvedFutureClassCount++] = newCls; } } } ts.log(&quot;IMAGE TIMES: discover classes&quot;); // Fix up remapped classes // Class list and nonlazy class list remain unremapped. // Class refs and super refs are remapped for message dispatching. if (!noClassesRemapped()) { for (EACH_HEADER) { Class *classrefs = _getObjc2ClassRefs(hi, &amp;count); for (i = 0; i &lt; count; i++) { remapClassRef(&amp;classrefs[i]); } // fixme why doesn't test future1 catch the absence of this? classrefs = _getObjc2SuperRefs(hi, &amp;count); for (i = 0; i &lt; count; i++) { remapClassRef(&amp;classrefs[i]); } } } ts.log(&quot;IMAGE TIMES: remap classes&quot;);#if SUPPORT_FIXUP // Fix up old objc_msgSend_fixup call sites for (EACH_HEADER) { message_ref_t *refs = _getObjc2MessageRefs(hi, &amp;count); if (count == 0) continue; if (PrintVtables) { _objc_inform(&quot;VTABLES: repairing %zu unsupported vtable dispatch &quot; &quot;call sites in %s&quot;, count, hi-&gt;fname()); } for (i = 0; i &lt; count; i++) { fixupMessageRef(refs+i); } } ts.log(&quot;IMAGE TIMES: fix up objc_msgSend_fixup&quot;);#endif // Discover protocols. Fix up protocol refs. for (EACH_HEADER) { extern objc_class OBJC_CLASS_$_Protocol; Class cls = (Class)&amp;OBJC_CLASS_$_Protocol; ASSERT(cls); NXMapTable *protocol_map = protocols(); bool isPreoptimized = hi-&gt;hasPreoptimizedProtocols(); // Skip reading protocols if this is an image from the shared cache // and we support roots // Note, after launch we do need to walk the protocol as the protocol // in the shared cache is marked with isCanonical() and that may not // be true if some non-shared cache binary was chosen as the canonical // definition if (launchTime &amp;&amp; isPreoptimized) { if (PrintProtocols) { _objc_inform(&quot;PROTOCOLS: Skipping reading protocols in image: %s&quot;, hi-&gt;fname()); } continue; } bool isBundle = hi-&gt;isBundle(); protocol_t * const *protolist = _getObjc2ProtocolList(hi, &amp;count); for (i = 0; i &lt; count; i++) { readProtocol(protolist[i], cls, protocol_map, isPreoptimized, isBundle); } } ts.log(&quot;IMAGE TIMES: discover protocols&quot;); // Fix up @protocol references // Preoptimized images may have the right // answer already but we don't know for sure. for (EACH_HEADER) { // At launch time, we know preoptimized image refs are pointing at the // shared cache definition of a protocol. We can skip the check on // launch, but have to visit @protocol refs for shared cache images // loaded later. if (launchTime &amp;&amp; hi-&gt;isPreoptimized()) continue; protocol_t **protolist = _getObjc2ProtocolRefs(hi, &amp;count); for (i = 0; i &lt; count; i++) { remapProtocolRef(&amp;protolist[i]); } } ts.log(&quot;IMAGE TIMES: fix up @protocol references&quot;); // Discover categories. Only do this after the initial category // attachment has been done. For categories present at startup, // discovery is deferred until the first load_images call after // the call to _dyld_objc_notify_register completes. rdar://problem/53119145 if (didInitialAttachCategories) { for (EACH_HEADER) { load_categories_nolock(hi); } } ts.log(&quot;IMAGE TIMES: discover categories&quot;); // Category discovery MUST BE Late to avoid potential races // when other threads call the new category code before // this thread finishes its fixups. // +load handled by prepare_load_methods() // Realize non-lazy classes (for +load methods and static instances) for (EACH_HEADER) { classref_t const *classlist = hi-&gt;nlclslist(&amp;count); for (i = 0; i &lt; count; i++) { Class cls = remapClass(classlist[i]); if (!cls) continue; addClassTableEntry(cls); if (cls-&gt;isSwiftStable()) { if (cls-&gt;swiftMetadataInitializer()) { _objc_fatal(&quot;Swift class %s with a metadata initializer &quot; &quot;is not allowed to be non-lazy&quot;, cls-&gt;nameForLogging()); } // fixme also disallow relocatable classes // We can't disallow all Swift classes because of // classes like Swift.__EmptyArrayStorage } realizeClassWithoutSwift(cls, nil); } } ts.log(&quot;IMAGE TIMES: realize non-lazy classes&quot;); // Realize newly-resolved future classes, in case CF manipulates them if (resolvedFutureClasses) { for (i = 0; i &lt; resolvedFutureClassCount; i++) { Class cls = resolvedFutureClasses[i]; if (cls-&gt;isSwiftStable()) { _objc_fatal(&quot;Swift class is not allowed to be future&quot;); } realizeClassWithoutSwift(cls, nil); cls-&gt;setInstancesRequireRawIsaRecursively(false/*inherited*/); } free(resolvedFutureClasses); } ts.log(&quot;IMAGE TIMES: realize future classes&quot;); if (DebugNonFragileIvars) { realizeAllClasses(); } // Print preoptimization statistics if (PrintPreopt) { static unsigned int PreoptTotalMethodLists; static unsigned int PreoptOptimizedMethodLists; static unsigned int PreoptTotalClasses; static unsigned int PreoptOptimizedClasses; for (EACH_HEADER) { if (hi-&gt;hasPreoptimizedSelectors()) { _objc_inform(&quot;PREOPTIMIZATION: honoring preoptimized selectors &quot; &quot;in %s&quot;, hi-&gt;fname()); } else if (hi-&gt;info()-&gt;optimizedByDyld()) { _objc_inform(&quot;PREOPTIMIZATION: IGNORING preoptimized selectors &quot; &quot;in %s&quot;, hi-&gt;fname()); } classref_t const *classlist = _getObjc2ClassList(hi, &amp;count); for (i = 0; i &lt; count; i++) { Class cls = remapClass(classlist[i]); if (!cls) continue; PreoptTotalClasses++; if (hi-&gt;hasPreoptimizedClasses()) { PreoptOptimizedClasses++; } const method_list_t *mlist; if ((mlist = cls-&gt;bits.safe_ro()-&gt;baseMethods())) { PreoptTotalMethodLists++; if (mlist-&gt;isFixedUp()) { PreoptOptimizedMethodLists++; } } if ((mlist = cls-&gt;ISA()-&gt;bits.safe_ro()-&gt;baseMethods())) { PreoptTotalMethodLists++; if (mlist-&gt;isFixedUp()) { PreoptOptimizedMethodLists++; } } } } _objc_inform(&quot;PREOPTIMIZATION: %zu selector references not &quot; &quot;pre-optimized&quot;, UnfixedSelectors); _objc_inform(&quot;PREOPTIMIZATION: %u/%u (%.3g%%) method lists pre-sorted&quot;, PreoptOptimizedMethodLists, PreoptTotalMethodLists, PreoptTotalMethodLists ? 100.0*PreoptOptimizedMethodLists/PreoptTotalMethodLists : 0.0); _objc_inform(&quot;PREOPTIMIZATION: %u/%u (%.3g%%) classes pre-registered&quot;, PreoptOptimizedClasses, PreoptTotalClasses, PreoptTotalClasses ? 100.0*PreoptOptimizedClasses/PreoptTotalClasses : 0.0); _objc_inform(&quot;PREOPTIMIZATION: %zu protocol references not &quot; &quot;pre-optimized&quot;, UnfixedProtocolReferences); }#undef EACH_HEADER}/************************************************************************ prepare_load_methods* Schedule +load for classes in this image, any un-+load-ed * superclasses in other images, and any categories in this image.**********************************************************************/// Recursively schedule +load for cls and any un-+load-ed superclasses.// cls must already be connected.static void schedule_class_load(Class cls){ if (!cls) return; ASSERT(cls-&gt;isRealized()); // _read_images should realize if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return; // Ensure superclass-first ordering schedule_class_load(cls-&gt;getSuperclass()); add_class_to_loadable_list(cls); cls-&gt;setInfo(RW_LOADED); }// Quick scan for +load methods that doesn't take a lock.bool hasLoadMethods(const headerType *mhdr){ size_t count; if (_getObjc2NonlazyClassList(mhdr, &amp;count) &amp;&amp; count &gt; 0) return true; if (_getObjc2NonlazyCategoryList(mhdr, &amp;count) &amp;&amp; count &gt; 0) return true; return false;}void prepare_load_methods(const headerType *mhdr){ size_t count, i; runtimeLock.assertLocked(); classref_t const *classlist = _getObjc2NonlazyClassList(mhdr, &amp;count); for (i = 0; i &lt; count; i++) { schedule_class_load(remapClass(classlist[i])); } category_t * const *categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count); for (i = 0; i &lt; count; i++) { category_t *cat = categorylist[i]; Class cls = remapClass(cat-&gt;cls); if (!cls) continue; // category for ignored weak-linked class if (cls-&gt;isSwiftStable()) { _objc_fatal(&quot;Swift class extensions and categories on Swift &quot; &quot;classes are not allowed to have +load methods&quot;); } realizeClassWithoutSwift(cls, nil); ASSERT(cls-&gt;ISA()-&gt;isRealized()); add_category_to_loadable_list(cat); }}/************************************************************************ _unload_image* Only handles MH_BUNDLE for now.* Locking: write-lock and loadMethodLock acquired by unmap_image**********************************************************************/void _unload_image(header_info *hi){ size_t count, i; loadMethodLock.assertLocked(); runtimeLock.assertLocked(); // Unload unattached categories and categories waiting for +load. // Ignore __objc_catlist2. We don't support unloading Swift // and we never will. category_t * const *catlist = hi-&gt;catlist(&amp;count); for (i = 0; i &lt; count; i++) { category_t *cat = catlist[i]; Class cls = remapClass(cat-&gt;cls); if (!cls) continue; // category for ignored weak-linked class // fixme for MH_DYLIB cat's class may have been unloaded already // unattached list objc::unattachedCategories.eraseCategoryForClass(cat, cls); // +load queue remove_category_from_loadable_list(cat); } // Unload classes. // Gather classes from both __DATA,__objc_clslist // and __DATA,__objc_nlclslist. arclite's hack puts a class in the latter // only, and we need to unload that class if we unload an arclite image. objc::DenseSet&lt;Class&gt; classes{}; classref_t const *classlist; classlist = _getObjc2ClassList(hi, &amp;count); for (i = 0; i &lt; count; i++) { Class cls = remapClass(classlist[i]); if (cls) classes.insert(cls); } classlist = hi-&gt;nlclslist(&amp;count); for (i = 0; i &lt; count; i++) { Class cls = remapClass(classlist[i]); if (cls) classes.insert(cls); } // First detach classes from each other. Then free each class. // This avoid bugs where this loop unloads a subclass before its superclass for (Class cls: classes) { remove_class_from_loadable_list(cls); detach_class(cls-&gt;ISA(), YES); detach_class(cls, NO); } for (Class cls: classes) { free_class(cls-&gt;ISA()); free_class(cls); } // XXX FIXME -- Clean up protocols: // &lt;rdar://problem/9033191&gt; Support unloading protocols at dylib/image unload time // fixme DebugUnload}/************************************************************************ method_getDescription* Returns a pointer to this method's objc_method_description.* Locking: none**********************************************************************/struct objc_method_description *method_getDescription(Method m){ if (!m) return nil; return m-&gt;getDescription();}IMP method_getImplementation(Method m){ return m ? m-&gt;imp(true) : nil;}IMPAndSEL _method_getImplementationAndName(Method m){ return { m-&gt;imp(true), m-&gt;name() };}/************************************************************************ method_getName* Returns this method's selector.* The method must not be nil.* The method must already have been fixed-up.* Locking: none**********************************************************************/SEL method_getName(Method m){ if (!m) return nil; ASSERT(m-&gt;name() == sel_registerName(sel_getName(m-&gt;name()))); return m-&gt;name();}/************************************************************************ method_getTypeEncoding* Returns this method's old-style type encoding string.* The method must not be nil.* Locking: none**********************************************************************/const char *method_getTypeEncoding(Method m){ if (!m) return nil; return m-&gt;types();}/************************************************************************ method_setImplementation* Sets this method's implementation to imp.* The previous implementation is returned.**********************************************************************/static IMP _method_setImplementation(Class cls, method_t *m, IMP imp){ runtimeLock.assertLocked(); if (!m) return nil; if (!imp) return nil; IMP old = m-&gt;imp(false); SEL sel = m-&gt;name(); m-&gt;setImp(imp); // Cache updates are slow if cls is nil (i.e. unknown) // RR/AWZ updates are slow if cls is nil (i.e. unknown) // fixme build list of classes whose Methods are known externally? flushCaches(cls, __func__, [sel, old](Class c){ return c-&gt;cache.shouldFlush(sel, old); }); adjustCustomFlagsForMethodChange(cls, m); return old;}IMP method_setImplementation(Method m, IMP imp){ // Don't know the class - will be slow if RR/AWZ are affected // fixme build list of classes whose Methods are known externally? mutex_locker_t lock(runtimeLock); return _method_setImplementation(Nil, m, imp);}extern void _method_setImplementationRawUnsafe(Method m, IMP imp){ mutex_locker_t lock(runtimeLock); m-&gt;setImp(imp);}void method_exchangeImplementations(Method m1, Method m2){ if (!m1 || !m2) return; mutex_locker_t lock(runtimeLock); IMP imp1 = m1-&gt;imp(false); IMP imp2 = m2-&gt;imp(false); SEL sel1 = m1-&gt;name(); SEL sel2 = m2-&gt;name(); m1-&gt;setImp(imp2); m2-&gt;setImp(imp1); // RR/AWZ updates are slow because class is unknown // Cache updates are slow because class is unknown // fixme build list of classes whose Methods are known externally? flushCaches(nil, __func__, [sel1, sel2, imp1, imp2](Class c){ return c-&gt;cache.shouldFlush(sel1, imp1) || c-&gt;cache.shouldFlush(sel2, imp2); }); adjustCustomFlagsForMethodChange(nil, m1); adjustCustomFlagsForMethodChange(nil, m2);}/************************************************************************ ivar_getOffset* fixme* Locking: none**********************************************************************/ptrdiff_tivar_getOffset(Ivar ivar){ if (!ivar) return 0; return *ivar-&gt;offset;}/************************************************************************ ivar_getName* fixme* Locking: none**********************************************************************/const char *ivar_getName(Ivar ivar){ if (!ivar) return nil; return ivar-&gt;name;}/************************************************************************ ivar_getTypeEncoding* fixme* Locking: none**********************************************************************/const char *ivar_getTypeEncoding(Ivar ivar){ if (!ivar) return nil; return ivar-&gt;type;}const char *property_getName(objc_property_t prop){ return prop-&gt;name;}const char *property_getAttributes(objc_property_t prop){ return prop-&gt;attributes;}objc_property_attribute_t *property_copyAttributeList(objc_property_t prop, unsigned int *outCount){ if (!prop) { if (outCount) *outCount = 0; return nil; } mutex_locker_t lock(runtimeLock); return copyPropertyAttributeList(prop-&gt;attributes,outCount);}char * property_copyAttributeValue(objc_property_t prop, const char *name){ if (!prop || !name || *name == '\\0') return nil; mutex_locker_t lock(runtimeLock); return copyPropertyAttributeValue(prop-&gt;attributes, name);}/************************************************************************ getExtendedTypesIndexesForMethod* Returns:* a is the count of methods in all method lists before m's method list* b is the index of m in m's method list* a+b is the index of m's extended types in the extended types array**********************************************************************/static void getExtendedTypesIndexesForMethod(protocol_t *proto, const method_t *m, bool isRequiredMethod, bool isInstanceMethod, uint32_t&amp; a, uint32_t &amp;b){ a = 0; if (proto-&gt;instanceMethods) { if (isRequiredMethod &amp;&amp; isInstanceMethod) { b = proto-&gt;instanceMethods-&gt;indexOfMethod(m); return; } a += proto-&gt;instanceMethods-&gt;count; } if (proto-&gt;classMethods) { if (isRequiredMethod &amp;&amp; !isInstanceMethod) { b = proto-&gt;classMethods-&gt;indexOfMethod(m); return; } a += proto-&gt;classMethods-&gt;count; } if (proto-&gt;optionalInstanceMethods) { if (!isRequiredMethod &amp;&amp; isInstanceMethod) { b = proto-&gt;optionalInstanceMethods-&gt;indexOfMethod(m); return; } a += proto-&gt;optionalInstanceMethods-&gt;count; } if (proto-&gt;optionalClassMethods) { if (!isRequiredMethod &amp;&amp; !isInstanceMethod) { b = proto-&gt;optionalClassMethods-&gt;indexOfMethod(m); return; } a += proto-&gt;optionalClassMethods-&gt;count; }}/************************************************************************ getExtendedTypesIndexForMethod* Returns the index of m's extended types in proto's extended types array.**********************************************************************/static uint32_t getExtendedTypesIndexForMethod(protocol_t *proto, const method_t *m, bool isRequiredMethod, bool isInstanceMethod){ uint32_t a; uint32_t b; getExtendedTypesIndexesForMethod(proto, m, isRequiredMethod, isInstanceMethod, a, b); return a + b;}/************************************************************************ fixupProtocolMethodList* Fixes up a single method list in a protocol.**********************************************************************/static voidfixupProtocolMethodList(protocol_t *proto, method_list_t *mlist, bool required, bool instance){ runtimeLock.assertLocked(); if (!mlist) return; if (mlist-&gt;isFixedUp()) return; const char **extTypes = proto-&gt;extendedMethodTypes(); fixupMethodList(mlist, true/*always copy for simplicity*/, !extTypes/*sort if no extended method types*/); if (extTypes &amp;&amp; !mlist-&gt;isSmallList()) { // Sort method list and extended method types together. // fixupMethodList() can't do this. // fixme COW stomp uint32_t count = mlist-&gt;count; uint32_t prefix; uint32_t junk; getExtendedTypesIndexesForMethod(proto, &amp;mlist-&gt;get(0), required, instance, prefix, junk); for (uint32_t i = 0; i &lt; count; i++) { for (uint32_t j = i+1; j &lt; count; j++) { auto&amp; mi = mlist-&gt;get(i).big(); auto&amp; mj = mlist-&gt;get(j).big(); if (mi.name &gt; mj.name) { std::swap(mi, mj); std::swap(extTypes[prefix+i], extTypes[prefix+j]); } } } }}/************************************************************************ fixupProtocol* Fixes up all of a protocol's method lists.**********************************************************************/static void fixupProtocol(protocol_t *proto){ runtimeLock.assertLocked(); if (proto-&gt;protocols) { for (uintptr_t i = 0; i &lt; proto-&gt;protocols-&gt;count; i++) { protocol_t *sub = remapProtocol(proto-&gt;protocols-&gt;list[i]); if (!sub-&gt;isFixedUp()) fixupProtocol(sub); } } fixupProtocolMethodList(proto, proto-&gt;instanceMethods, YES, YES); fixupProtocolMethodList(proto, proto-&gt;classMethods, YES, NO); fixupProtocolMethodList(proto, proto-&gt;optionalInstanceMethods, NO, YES); fixupProtocolMethodList(proto, proto-&gt;optionalClassMethods, NO, NO); // fixme memory barrier so we can check this with no lock proto-&gt;setFixedUp();}/************************************************************************ fixupProtocolIfNeeded* Fixes up all of a protocol's method lists if they aren't fixed up already.* Locking: write-locks runtimeLock.**********************************************************************/static void fixupProtocolIfNeeded(protocol_t *proto){ runtimeLock.assertUnlocked(); ASSERT(proto); if (!proto-&gt;isFixedUp()) { mutex_locker_t lock(runtimeLock); fixupProtocol(proto); }}static method_list_t *getProtocolMethodList(protocol_t *proto, bool required, bool instance){ method_list_t **mlistp = nil; if (required) { if (instance) { mlistp = &amp;proto-&gt;instanceMethods; } else { mlistp = &amp;proto-&gt;classMethods; } } else { if (instance) { mlistp = &amp;proto-&gt;optionalInstanceMethods; } else { mlistp = &amp;proto-&gt;optionalClassMethods; } } return *mlistp;}/************************************************************************ protocol_getMethod_nolock* Locking: runtimeLock must be held by the caller**********************************************************************/static method_t *protocol_getMethod_nolock(protocol_t *proto, SEL sel, bool isRequiredMethod, bool isInstanceMethod, bool recursive){ runtimeLock.assertLocked(); if (!proto || !sel) return nil; ASSERT(proto-&gt;isFixedUp()); method_list_t *mlist = getProtocolMethodList(proto, isRequiredMethod, isInstanceMethod); if (mlist) { method_t *m = search_method_list(mlist, sel); if (m) return m; } if (recursive &amp;&amp; proto-&gt;protocols) { method_t *m; for (uint32_t i = 0; i &lt; proto-&gt;protocols-&gt;count; i++) { protocol_t *realProto = remapProtocol(proto-&gt;protocols-&gt;list[i]); m = protocol_getMethod_nolock(realProto, sel, isRequiredMethod, isInstanceMethod, true); if (m) return m; } } return nil;}/************************************************************************ protocol_getMethod* fixme* Locking: acquires runtimeLock**********************************************************************/Method protocol_getMethod(protocol_t *proto, SEL sel, bool isRequiredMethod, bool isInstanceMethod, bool recursive){ if (!proto) return nil; fixupProtocolIfNeeded(proto); mutex_locker_t lock(runtimeLock); return protocol_getMethod_nolock(proto, sel, isRequiredMethod, isInstanceMethod, recursive);}/************************************************************************ protocol_getMethodTypeEncoding_nolock* Return the @encode string for the requested protocol method.* Returns nil if the compiler did not emit any extended @encode data.* Locking: runtimeLock must be held by the caller**********************************************************************/const char * protocol_getMethodTypeEncoding_nolock(protocol_t *proto, SEL sel, bool isRequiredMethod, bool isInstanceMethod){ runtimeLock.assertLocked(); if (!proto) return nil; if (!proto-&gt;extendedMethodTypes()) return nil; ASSERT(proto-&gt;isFixedUp()); method_t *m = protocol_getMethod_nolock(proto, sel, isRequiredMethod, isInstanceMethod, false); if (m) { uint32_t i = getExtendedTypesIndexForMethod(proto, m, isRequiredMethod, isInstanceMethod); return proto-&gt;extendedMethodTypes()[i]; } // No method with that name. Search incorporated protocols. if (proto-&gt;protocols) { for (uintptr_t i = 0; i &lt; proto-&gt;protocols-&gt;count; i++) { const char *enc = protocol_getMethodTypeEncoding_nolock(remapProtocol(proto-&gt;protocols-&gt;list[i]), sel, isRequiredMethod, isInstanceMethod); if (enc) return enc; } } return nil;}/************************************************************************ _protocol_getMethodTypeEncoding* Return the @encode string for the requested protocol method.* Returns nil if the compiler did not emit any extended @encode data.* Locking: acquires runtimeLock**********************************************************************/const char * _protocol_getMethodTypeEncoding(Protocol *proto_gen, SEL sel, BOOL isRequiredMethod, BOOL isInstanceMethod){ protocol_t *proto = newprotocol(proto_gen); if (!proto) return nil; fixupProtocolIfNeeded(proto); mutex_locker_t lock(runtimeLock); return protocol_getMethodTypeEncoding_nolock(proto, sel, isRequiredMethod, isInstanceMethod);}/************************************************************************ protocol_t::demangledName* Returns the (Swift-demangled) name of the given protocol.* Locking: none**********************************************************************/const char *protocol_t::demangledName() { if (!hasDemangledNameField()) return mangledName; if (! _demangledName) { char *de = copySwiftV1DemangledName(mangledName, true/*isProtocol*/); if (! OSAtomicCompareAndSwapPtrBarrier(nil, (void*)(de ?: mangledName), (void**)&amp;_demangledName)) { if (de) free(de); } } return _demangledName;}/************************************************************************ protocol_getName* Returns the (Swift-demangled) name of the given protocol.* Locking: runtimeLock must not be held by the caller**********************************************************************/const char *protocol_getName(Protocol *proto){ if (!proto) return &quot;nil&quot;; else return newprotocol(proto)-&gt;demangledName();}/************************************************************************ protocol_getInstanceMethodDescription* Returns the description of a named instance method.* Locking: runtimeLock must not be held by the caller**********************************************************************/struct objc_method_description protocol_getMethodDescription(Protocol *p, SEL aSel, BOOL isRequiredMethod, BOOL isInstanceMethod){ Method m = protocol_getMethod(newprotocol(p), aSel, isRequiredMethod, isInstanceMethod, true); // method_getDescription is inefficient for small methods. Don't bother // trying to use it, just make our own. if (m) return (struct objc_method_description){m-&gt;name(), (char *)m-&gt;types()}; else return (struct objc_method_description){nil, nil};}/************************************************************************ protocol_conformsToProtocol_nolock* Returns YES if self conforms to other.* Locking: runtimeLock must be held by the caller.**********************************************************************/static bool protocol_conformsToProtocol_nolock(protocol_t *self, protocol_t *other){ runtimeLock.assertLocked(); if (!self || !other) { return NO; } // protocols need not be fixed up if (0 == strcmp(self-&gt;mangledName, other-&gt;mangledName)) { return YES; } if (self-&gt;protocols) { uintptr_t i; for (i = 0; i &lt; self-&gt;protocols-&gt;count; i++) { protocol_t *proto = remapProtocol(self-&gt;protocols-&gt;list[i]); if (other == proto) { return YES; } if (0 == strcmp(other-&gt;mangledName, proto-&gt;mangledName)) { return YES; } if (protocol_conformsToProtocol_nolock(proto, other)) { return YES; } } } return NO;}/************************************************************************ protocol_conformsToProtocol* Returns YES if self conforms to other.* Locking: acquires runtimeLock**********************************************************************/BOOL protocol_conformsToProtocol(Protocol *self, Protocol *other){ mutex_locker_t lock(runtimeLock); return protocol_conformsToProtocol_nolock(newprotocol(self), newprotocol(other));}/************************************************************************ protocol_isEqual* Return YES if two protocols are equal (i.e. conform to each other)* Locking: acquires runtimeLock**********************************************************************/BOOL protocol_isEqual(Protocol *self, Protocol *other){ if (self == other) return YES; if (!self || !other) return NO; if (!protocol_conformsToProtocol(self, other)) return NO; if (!protocol_conformsToProtocol(other, self)) return NO; return YES;}/************************************************************************ protocol_copyMethodDescriptionList* Returns descriptions of a protocol's methods.* Locking: acquires runtimeLock**********************************************************************/struct objc_method_description *protocol_copyMethodDescriptionList(Protocol *p, BOOL isRequiredMethod,BOOL isInstanceMethod, unsigned int *outCount){ protocol_t *proto = newprotocol(p); struct objc_method_description *result = nil; unsigned int count = 0; if (!proto) { if (outCount) *outCount = 0; return nil; } fixupProtocolIfNeeded(proto); mutex_locker_t lock(runtimeLock); method_list_t *mlist = getProtocolMethodList(proto, isRequiredMethod, isInstanceMethod); if (mlist) { result = (struct objc_method_description *) calloc(mlist-&gt;count + 1, sizeof(struct objc_method_description)); for (const auto&amp; meth : *mlist) { result[count].name = meth.name(); result[count].types = (char *)meth.types(); count++; } } if (outCount) *outCount = count; return result;}/************************************************************************ protocol_getProperty* fixme* Locking: runtimeLock must be held by the caller**********************************************************************/static property_t * protocol_getProperty_nolock(protocol_t *proto, const char *name, bool isRequiredProperty, bool isInstanceProperty){ runtimeLock.assertLocked(); if (!isRequiredProperty) { // Only required properties are currently supported. return nil; } property_list_t *plist = isInstanceProperty ? proto-&gt;instanceProperties : proto-&gt;classProperties(); if (plist) { for (auto&amp; prop : *plist) { if (0 == strcmp(name, prop.name)) { return &amp;prop; } } } if (proto-&gt;protocols) { uintptr_t i; for (i = 0; i &lt; proto-&gt;protocols-&gt;count; i++) { protocol_t *p = remapProtocol(proto-&gt;protocols-&gt;list[i]); property_t *prop = protocol_getProperty_nolock(p, name, isRequiredProperty, isInstanceProperty); if (prop) return prop; } } return nil;}objc_property_t protocol_getProperty(Protocol *p, const char *name, BOOL isRequiredProperty, BOOL isInstanceProperty){ if (!p || !name) return nil; mutex_locker_t lock(runtimeLock); return (objc_property_t) protocol_getProperty_nolock(newprotocol(p), name, isRequiredProperty, isInstanceProperty);}/************************************************************************ protocol_copyPropertyList* protocol_copyPropertyList2* fixme* Locking: acquires runtimeLock**********************************************************************/static property_t **copyPropertyList(property_list_t *plist, unsigned int *outCount){ property_t **result = nil; unsigned int count = 0; if (plist) { count = plist-&gt;count; } if (count &gt; 0) { result = (property_t **)malloc((count+1) * sizeof(property_t *)); count = 0; for (auto&amp; prop : *plist) { result[count++] = &amp;prop; } result[count] = nil; } if (outCount) *outCount = count; return result;}objc_property_t *protocol_copyPropertyList2(Protocol *proto, unsigned int *outCount, BOOL isRequiredProperty, BOOL isInstanceProperty){ if (!proto || !isRequiredProperty) { // Optional properties are not currently supported. if (outCount) *outCount = 0; return nil; } mutex_locker_t lock(runtimeLock); property_list_t *plist = isInstanceProperty ? newprotocol(proto)-&gt;instanceProperties : newprotocol(proto)-&gt;classProperties(); return (objc_property_t *)copyPropertyList(plist, outCount);}objc_property_t *protocol_copyPropertyList(Protocol *proto, unsigned int *outCount){ return protocol_copyPropertyList2(proto, outCount, YES/*required*/, YES/*instance*/);}/************************************************************************ protocol_copyProtocolList* Copies this protocol's incorporated protocols. * Does not copy those protocol's incorporated protocols in turn.* Locking: acquires runtimeLock**********************************************************************/Protocol * __unsafe_unretained * protocol_copyProtocolList(Protocol *p, unsigned int *outCount){ unsigned int count = 0; Protocol **result = nil; protocol_t *proto = newprotocol(p); if (!proto) { if (outCount) *outCount = 0; return nil; } mutex_locker_t lock(runtimeLock); if (proto-&gt;protocols) { count = (unsigned int)proto-&gt;protocols-&gt;count; } if (count &gt; 0) { result = (Protocol **)malloc((count+1) * sizeof(Protocol *)); unsigned int i; for (i = 0; i &lt; count; i++) { result[i] = (Protocol *)remapProtocol(proto-&gt;protocols-&gt;list[i]); } result[i] = nil; } if (outCount) *outCount = count; return result;}/************************************************************************ objc_allocateProtocol* Creates a new protocol. The protocol may not be used until * objc_registerProtocol() is called.* Returns nil if a protocol with the same name already exists.* Locking: acquires runtimeLock**********************************************************************/Protocol *objc_allocateProtocol(const char *name){ mutex_locker_t lock(runtimeLock); if (getProtocol(name)) { return nil; } protocol_t *result = (protocol_t *)calloc(sizeof(protocol_t), 1); extern objc_class OBJC_CLASS_$___IncompleteProtocol; Class cls = (Class)&amp;OBJC_CLASS_$___IncompleteProtocol; result-&gt;initProtocolIsa(cls); result-&gt;size = sizeof(protocol_t); // fixme mangle the name if it looks swift-y? result-&gt;mangledName = strdupIfMutable(name); // fixme reserve name without installing return (Protocol *)result;}/************************************************************************ objc_registerProtocol* Registers a newly-constructed protocol. The protocol is now * ready for use and immutable.* Locking: acquires runtimeLock**********************************************************************/void objc_registerProtocol(Protocol *proto_gen) { protocol_t *proto = newprotocol(proto_gen); mutex_locker_t lock(runtimeLock); extern objc_class OBJC_CLASS_$___IncompleteProtocol; Class oldcls = (Class)&amp;OBJC_CLASS_$___IncompleteProtocol; extern objc_class OBJC_CLASS_$_Protocol; Class cls = (Class)&amp;OBJC_CLASS_$_Protocol; if (proto-&gt;ISA() == cls) { _objc_inform(&quot;objc_registerProtocol: protocol '%s' was already &quot; &quot;registered!&quot;, proto-&gt;nameForLogging()); return; } if (proto-&gt;ISA() != oldcls) { _objc_inform(&quot;objc_registerProtocol: protocol '%s' was not allocated &quot; &quot;with objc_allocateProtocol!&quot;, proto-&gt;nameForLogging()); return; } // NOT initProtocolIsa(). The protocol object may already // have been retained and we must preserve that count. proto-&gt;changeIsa(cls); // Don't add this protocol if we already have it. // Should we warn on duplicates? if (getProtocol(proto-&gt;mangledName) == nil) { NXMapKeyCopyingInsert(protocols(), proto-&gt;mangledName, proto); }}/************************************************************************ protocol_addProtocol* Adds an incorporated protocol to another protocol.* No method enforcement is performed.* `proto` must be under construction. `addition` must not.* Locking: acquires runtimeLock**********************************************************************/void protocol_addProtocol(Protocol *proto_gen, Protocol *addition_gen) { protocol_t *proto = newprotocol(proto_gen); protocol_t *addition = newprotocol(addition_gen); extern objc_class OBJC_CLASS_$___IncompleteProtocol; Class cls = (Class)&amp;OBJC_CLASS_$___IncompleteProtocol; if (!proto_gen) return; if (!addition_gen) return; mutex_locker_t lock(runtimeLock); if (proto-&gt;ISA() != cls) { _objc_inform(&quot;protocol_addProtocol: modified protocol '%s' is not &quot; &quot;under construction!&quot;, proto-&gt;nameForLogging()); return; } if (addition-&gt;ISA() == cls) { _objc_inform(&quot;protocol_addProtocol: added protocol '%s' is still &quot; &quot;under construction!&quot;, addition-&gt;nameForLogging()); return; } protocol_list_t *protolist = proto-&gt;protocols; if (!protolist) { protolist = (protocol_list_t *) calloc(1, sizeof(protocol_list_t) + sizeof(protolist-&gt;list[0])); } else { protolist = (protocol_list_t *) realloc(protolist, protocol_list_size(protolist) + sizeof(protolist-&gt;list[0])); } protolist-&gt;list[protolist-&gt;count++] = (protocol_ref_t)addition; proto-&gt;protocols = protolist;}/************************************************************************ protocol_addMethodDescription* Adds a method to a protocol. The protocol must be under construction.* Locking: acquires runtimeLock**********************************************************************/static voidprotocol_addMethod_nolock(method_list_t*&amp; list, SEL name, const char *types){ if (!list) { list = (method_list_t *)calloc(method_list_t::byteSize(sizeof(struct method_t::big), 1), 1); list-&gt;entsizeAndFlags = sizeof(struct method_t::big); list-&gt;setFixedUp(); } else { size_t size = list-&gt;byteSize() + list-&gt;entsize(); list = (method_list_t *)realloc(list, size); } auto &amp;meth = list-&gt;get(list-&gt;count++).big(); meth.name = name; meth.types = types ? strdupIfMutable(types) : &quot;&quot;; meth.imp = nil;}void protocol_addMethodDescription(Protocol *proto_gen, SEL name, const char *types, BOOL isRequiredMethod, BOOL isInstanceMethod) { protocol_t *proto = newprotocol(proto_gen); extern objc_class OBJC_CLASS_$___IncompleteProtocol; Class cls = (Class)&amp;OBJC_CLASS_$___IncompleteProtocol; if (!proto_gen) return; mutex_locker_t lock(runtimeLock); if (proto-&gt;ISA() != cls) { _objc_inform(&quot;protocol_addMethodDescription: protocol '%s' is not &quot; &quot;under construction!&quot;, proto-&gt;nameForLogging()); return; } if (isRequiredMethod &amp;&amp; isInstanceMethod) { protocol_addMethod_nolock(proto-&gt;instanceMethods, name, types); } else if (isRequiredMethod &amp;&amp; !isInstanceMethod) { protocol_addMethod_nolock(proto-&gt;classMethods, name, types); } else if (!isRequiredMethod &amp;&amp; isInstanceMethod) { protocol_addMethod_nolock(proto-&gt;optionalInstanceMethods, name,types); } else /* !isRequiredMethod &amp;&amp; !isInstanceMethod) */ { protocol_addMethod_nolock(proto-&gt;optionalClassMethods, name, types); }}/************************************************************************ protocol_addProperty* Adds a property to a protocol. The protocol must be under construction.* Locking: acquires runtimeLock**********************************************************************/static void protocol_addProperty_nolock(property_list_t *&amp;plist, const char *name, const objc_property_attribute_t *attrs, unsigned int count){ if (!plist) { plist = (property_list_t *)calloc(property_list_t::byteSize(sizeof(property_t), 1), 1); plist-&gt;entsizeAndFlags = sizeof(property_t); plist-&gt;count = 1; } else { plist-&gt;count++; plist = (property_list_t *)realloc(plist, plist-&gt;byteSize()); } property_t&amp; prop = plist-&gt;get(plist-&gt;count - 1); prop.name = strdupIfMutable(name); prop.attributes = copyPropertyAttributeString(attrs, count);}void protocol_addProperty(Protocol *proto_gen, const char *name, const objc_property_attribute_t *attrs, unsigned int count, BOOL isRequiredProperty, BOOL isInstanceProperty){ protocol_t *proto = newprotocol(proto_gen); extern objc_class OBJC_CLASS_$___IncompleteProtocol; Class cls = (Class)&amp;OBJC_CLASS_$___IncompleteProtocol; if (!proto) return; if (!name) return; mutex_locker_t lock(runtimeLock); if (proto-&gt;ISA() != cls) { _objc_inform(&quot;protocol_addProperty: protocol '%s' is not &quot; &quot;under construction!&quot;, proto-&gt;nameForLogging()); return; } if (isRequiredProperty &amp;&amp; isInstanceProperty) { protocol_addProperty_nolock(proto-&gt;instanceProperties, name, attrs, count); } else if (isRequiredProperty &amp;&amp; !isInstanceProperty) { protocol_addProperty_nolock(proto-&gt;_classProperties, name, attrs, count); } //else if (!isRequiredProperty &amp;&amp; isInstanceProperty) { // protocol_addProperty_nolock(proto-&gt;optionalInstanceProperties, name, attrs, count); //} //else /* !isRequiredProperty &amp;&amp; !isInstanceProperty) */ { // protocol_addProperty_nolock(proto-&gt;optionalClassProperties, name, attrs, count); //}}static intobjc_getRealizedClassList_nolock(Class *buffer, int bufferLen){ int count = 0; if (buffer) { int c = 0; foreach_realized_class([=, &amp;count, &amp;c](Class cls) { count++; if (c &lt; bufferLen) { buffer[c++] = cls; } return true; }); } else { foreach_realized_class([&amp;count](Class cls) { count++; return true; }); } return count;}static Class *objc_copyRealizedClassList_nolock(unsigned int *outCount){ Class *result = nil; unsigned int count = 0; foreach_realized_class([&amp;count](Class cls) { count++; return true; }); if (count &gt; 0) { unsigned int c = 0; result = (Class *)malloc((1+count) * sizeof(Class)); foreach_realized_class([=, &amp;c](Class cls) { result[c++] = cls; return true; }); result[c] = nil; } if (outCount) *outCount = count; return result;}/*********************************************************************** * objc_getClassList * Returns pointers to all classes. * This requires all classes be realized, which is regretfully non-lazy. * Locking: acquires runtimeLock **********************************************************************/intobjc_getClassList(Class *buffer, int bufferLen){ mutex_locker_t lock(runtimeLock); realizeAllClasses(); return objc_getRealizedClassList_nolock(buffer, bufferLen);}/*********************************************************************** * objc_copyClassList * Returns pointers to Realized classes. * * outCount may be nil. *outCount is the number of classes returned. * If the returned array is not nil, it is nil-terminated and must be * freed with free(). * Locking: write-locks runtimeLock **********************************************************************/Class *objc_copyRealizedClassList(unsigned int *outCount){ mutex_locker_t lock(runtimeLock); return objc_copyRealizedClassList_nolock(outCount);}/************************************************************************ objc_copyClassList* Returns pointers to all classes.* This requires all classes be realized, which is regretfully non-lazy.* * outCount may be nil. *outCount is the number of classes returned. * If the returned array is not nil, it is nil-terminated and must be * freed with free().* Locking: write-locks runtimeLock**********************************************************************/Class *objc_copyClassList(unsigned int *outCount){ mutex_locker_t lock(runtimeLock); realizeAllClasses(); return objc_copyRealizedClassList_nolock(outCount);}/*********************************************************************** * class_copyImpCache * Returns the current content of the Class IMP Cache * * outCount may be nil. *outCount is the number of entries returned. * If the returned array is not nil, it is nil-terminated and must be * freed with free(). * Locking: write-locks cacheUpdateLock **********************************************************************/objc_imp_cache_entry *class_copyImpCache(Class cls, int *outCount){ objc_imp_cache_entry *buffer = nullptr;#if CONFIG_USE_CACHE_LOCK mutex_locker_t lock(cacheUpdateLock);#else mutex_locker_t lock(runtimeLock);#endif cache_t &amp;cache = cls-&gt;cache; int count = (int)cache.occupied(); if (count) { buffer = (objc_imp_cache_entry *)calloc(1+count, sizeof(objc_imp_cache_entry)); cache.copyCacheNolock(buffer, count); } if (outCount) *outCount = count; return buffer;}/************************************************************************ objc_copyProtocolList* Returns pointers to all protocols.* Locking: read-locks runtimeLock**********************************************************************/Protocol * __unsafe_unretained * objc_copyProtocolList(unsigned int *outCount) { mutex_locker_t lock(runtimeLock); NXMapTable *protocol_map = protocols(); // Find all the protocols from the pre-optimized images. These protocols // won't be in the protocol map. objc::DenseMap&lt;const char*, Protocol*&gt; preoptimizedProtocols; { header_info *hi; for (hi = FirstHeader; hi; hi = hi-&gt;getNext()) { if (!hi-&gt;hasPreoptimizedProtocols()) continue; size_t count, i; const protocol_t * const *protolist = _getObjc2ProtocolList(hi, &amp;count); for (i = 0; i &lt; count; i++) { const protocol_t* protocol = protolist[i]; // Skip protocols we have in the run time map. These likely // correspond to protocols added dynamically which have the same // name as a protocol found later in a dlopen'ed shared cache image. if (NXMapGet(protocol_map, protocol-&gt;mangledName) != nil) continue; // The protocols in the shared cache protolist point to their // original on-disk object, not the optimized one. We can use the name // to find the optimized one. Protocol* optimizedProto = getPreoptimizedProtocol(protocol-&gt;mangledName); preoptimizedProtocols.insert({ protocol-&gt;mangledName, optimizedProto }); } } } unsigned int count = NXCountMapTable(protocol_map) + (unsigned int)preoptimizedProtocols.size(); if (count == 0) { if (outCount) *outCount = 0; return nil; } Protocol **result = (Protocol **)malloc((count+1) * sizeof(Protocol*)); unsigned int i = 0; Protocol *proto; const char *name; NXMapState state = NXInitMapState(protocol_map); while (NXNextMapState(protocol_map, &amp;state, (const void **)&amp;name, (const void **)&amp;proto)) { result[i++] = proto; } // Add any protocols found in the pre-optimized table for (auto it : preoptimizedProtocols) { result[i++] = it.second; } result[i++] = nil; ASSERT(i == count+1); if (outCount) *outCount = count; return result;}/************************************************************************ objc_getProtocol* Get a protocol by name, or return nil* Locking: read-locks runtimeLock**********************************************************************/Protocol *objc_getProtocol(const char *name){ mutex_locker_t lock(runtimeLock); return getProtocol(name);}/************************************************************************ class_copyMethodList* fixme* Locking: read-locks runtimeLock**********************************************************************/Method *class_copyMethodList(Class cls, unsigned int *outCount){ unsigned int count = 0; Method *result = nil; if (!cls) { if (outCount) *outCount = 0; return nil; } mutex_locker_t lock(runtimeLock); const auto methods = cls-&gt;data()-&gt;methods(); ASSERT(cls-&gt;isRealized()); count = methods.count(); if (count &gt; 0) { result = (Method *)malloc((count + 1) * sizeof(Method)); count = 0; for (auto&amp; meth : methods) { result[count++] = &amp;meth; } result[count] = nil; } if (outCount) *outCount = count; return result;}/************************************************************************ class_copyIvarList* fixme* Locking: read-locks runtimeLock**********************************************************************/Ivar *class_copyIvarList(Class cls, unsigned int *outCount){ const ivar_list_t *ivars; Ivar *result = nil; unsigned int count = 0; if (!cls) { if (outCount) *outCount = 0; return nil; } mutex_locker_t lock(runtimeLock); ASSERT(cls-&gt;isRealized()); if ((ivars = cls-&gt;data()-&gt;ro()-&gt;ivars) &amp;&amp; ivars-&gt;count) { result = (Ivar *)malloc((ivars-&gt;count+1) * sizeof(Ivar)); for (auto&amp; ivar : *ivars) { if (!ivar.offset) continue; // anonymous bitfield result[count++] = &amp;ivar; } result[count] = nil; } if (outCount) *outCount = count; return result;}/************************************************************************ class_copyPropertyList. Returns a heap block containing the * properties declared in the class, or nil if the class * declares no properties. Caller must free the block.* Does not copy any superclass's properties.* Locking: read-locks runtimeLock**********************************************************************/objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount){ if (!cls) { if (outCount) *outCount = 0; return nil; } mutex_locker_t lock(runtimeLock); checkIsKnownClass(cls); ASSERT(cls-&gt;isRealized()); auto rw = cls-&gt;data(); property_t **result = nil; auto const properties = rw-&gt;properties(); unsigned int count = properties.count(); if (count &gt; 0) { result = (property_t **)malloc((count + 1) * sizeof(property_t *)); count = 0; for (auto&amp; prop : properties) { result[count++] = &amp;prop; } result[count] = nil; } if (outCount) *outCount = count; return (objc_property_t *)result;}/************************************************************************ objc_class::getLoadMethod* fixme* Called only from add_class_to_loadable_list.* Locking: runtimeLock must be read- or write-locked by the caller.**********************************************************************/IMP objc_class::getLoadMethod(){ runtimeLock.assertLocked(); const method_list_t *mlist; ASSERT(isRealized()); ASSERT(ISA()-&gt;isRealized()); ASSERT(!isMetaClass()); ASSERT(ISA()-&gt;isMetaClass()); mlist = ISA()-&gt;data()-&gt;ro()-&gt;baseMethods(); if (mlist) { for (const auto&amp; meth : *mlist) { const char *name = sel_cname(meth.name()); if (0 == strcmp(name, &quot;load&quot;)) { return meth.imp(false); } } } return nil;}/************************************************************************ _category_getName* Returns a category's name.* Locking: none**********************************************************************/const char *_category_getName(Category cat){ return cat-&gt;name;}/************************************************************************ _category_getClassName* Returns a category's class's name* Called only from add_category_to_loadable_list and * remove_category_from_loadable_list for logging purposes.* Locking: runtimeLock must be read- or write-locked by the caller**********************************************************************/const char *_category_getClassName(Category cat){ runtimeLock.assertLocked(); return remapClass(cat-&gt;cls)-&gt;nameForLogging();}/************************************************************************ _category_getClass* Returns a category's class* Called only by call_category_loads.* Locking: read-locks runtimeLock**********************************************************************/Class _category_getClass(Category cat){ mutex_locker_t lock(runtimeLock); Class result = remapClass(cat-&gt;cls); ASSERT(result-&gt;isRealized()); // ok for call_category_loads' usage return result;}/************************************************************************ _category_getLoadMethod* fixme* Called only from add_category_to_loadable_list* Locking: runtimeLock must be read- or write-locked by the caller**********************************************************************/IMP _category_getLoadMethod(Category cat){ runtimeLock.assertLocked(); const method_list_t *mlist; mlist = cat-&gt;classMethods; if (mlist) { for (const auto&amp; meth : *mlist) { const char *name = sel_cname(meth.name()); if (0 == strcmp(name, &quot;load&quot;)) { return meth.imp(false); } } } return nil;}/************************************************************************ category_t::propertiesForMeta* Return a category's instance or class properties.* hi is the image containing the category.**********************************************************************/property_list_t *category_t::propertiesForMeta(bool isMeta, struct header_info *hi){ if (!isMeta) return instanceProperties; else if (hi-&gt;info()-&gt;hasCategoryClassProperties()) return _classProperties; else return nil;}/************************************************************************ class_copyProtocolList* fixme* Locking: read-locks runtimeLock**********************************************************************/Protocol * __unsafe_unretained * class_copyProtocolList(Class cls, unsigned int *outCount){ unsigned int count = 0; Protocol **result = nil; if (!cls) { if (outCount) *outCount = 0; return nil; } mutex_locker_t lock(runtimeLock); const auto protocols = cls-&gt;data()-&gt;protocols(); checkIsKnownClass(cls); ASSERT(cls-&gt;isRealized()); count = protocols.count(); if (count &gt; 0) { result = (Protocol **)malloc((count+1) * sizeof(Protocol *)); count = 0; for (const auto&amp; proto : protocols) { result[count++] = (Protocol *)remapProtocol(proto); } result[count] = nil; } if (outCount) *outCount = count; return result;}/************************************************************************ objc_copyImageNames* Copies names of loaded images with ObjC contents.** Locking: acquires runtimeLock**********************************************************************/const char **objc_copyImageNames(unsigned int *outCount){ mutex_locker_t lock(runtimeLock); int HeaderCount = 0; for (header_info *hi = FirstHeader; hi != nil; hi = hi-&gt;getNext()) { HeaderCount++; }#if TARGET_OS_WIN32 const TCHAR **names = (const TCHAR **) malloc((HeaderCount+1) * sizeof(TCHAR *));#else const char **names = (const char **) malloc((HeaderCount+1) * sizeof(char *));#endif unsigned int count = 0; for (header_info *hi = FirstHeader; hi != nil; hi = hi-&gt;getNext()) {#if TARGET_OS_WIN32 if (hi-&gt;moduleName) { names[count++] = hi-&gt;moduleName; }#else const char *fname = hi-&gt;fname(); if (fname) { names[count++] = fname; }#endif } names[count] = nil; if (count == 0) { // Return nil instead of empty list if there are no images free((void *)names); names = nil; } if (outCount) *outCount = count; return names;}/************************************************************************ copyClassNamesForImage_nolock* Copies class names from the given image.* Missing weak-import classes are omitted.* Swift class names are demangled.** Locking: runtimeLock must be held by the caller**********************************************************************/const char **copyClassNamesForImage_nolock(header_info *hi, unsigned int *outCount){ runtimeLock.assertLocked(); ASSERT(hi); size_t count; classref_t const *classlist = _getObjc2ClassList(hi, &amp;count); const char **names = (const char **) malloc((count+1) * sizeof(const char *)); size_t shift = 0; for (size_t i = 0; i &lt; count; i++) { Class cls = remapClass(classlist[i]); if (cls) { names[i-shift] = cls-&gt;demangledName(/* needs lock */false); } else { shift++; // ignored weak-linked class } } count -= shift; names[count] = nil; if (outCount) *outCount = (unsigned int)count; return names;}Class *copyClassesForImage_nolock(header_info *hi, unsigned int *outCount){ runtimeLock.assertLocked(); ASSERT(hi); size_t count; classref_t const *classlist = _getObjc2ClassList(hi, &amp;count); Class *classes = (Class *) malloc((count+1) * sizeof(Class)); size_t shift = 0; for (size_t i = 0; i &lt; count; i++) { Class cls = remapClass(classlist[i]); if (cls) { classes[i-shift] = cls; } else { shift++; // ignored weak-linked class } } count -= shift; classes[count] = nil; if (outCount) *outCount = (unsigned int)count; return classes;}/************************************************************************ objc_copyClassNamesForImage* Copies class names from the named image.* The image name must be identical to dladdr's dli_fname value.* Missing weak-import classes are omitted.* Swift class names are demangled.** Locking: acquires runtimeLock**********************************************************************/const char **objc_copyClassNamesForImage(const char *image, unsigned int *outCount){ if (!image) { if (outCount) *outCount = 0; return nil; } mutex_locker_t lock(runtimeLock); // Find the image. header_info *hi; for (hi = FirstHeader; hi != nil; hi = hi-&gt;getNext()) {#if TARGET_OS_WIN32 if (0 == wcscmp((TCHAR *)image, hi-&gt;moduleName)) break;#else if (0 == strcmp(image, hi-&gt;fname())) break;#endif } if (!hi) { if (outCount) *outCount = 0; return nil; } return copyClassNamesForImage_nolock(hi, outCount);}Class *objc_copyClassesForImage(const char *image, unsigned int *outCount){ if (!image) { if (outCount) *outCount = 0; return nil; } mutex_locker_t lock(runtimeLock); // Find the image. header_info *hi; for (hi = FirstHeader; hi != nil; hi = hi-&gt;getNext()) { if (0 == strcmp(image, hi-&gt;fname())) break; } if (!hi) { if (outCount) *outCount = 0; return nil; } return copyClassesForImage_nolock(hi, outCount);}/************************************************************************ objc_copyClassNamesForImageHeader* Copies class names from the given image.* Missing weak-import classes are omitted.* Swift class names are demangled.** Locking: acquires runtimeLock**********************************************************************/const char **objc_copyClassNamesForImageHeader(const struct mach_header *mh, unsigned int *outCount){ if (!mh) { if (outCount) *outCount = 0; return nil; } mutex_locker_t lock(runtimeLock); // Find the image. header_info *hi; for (hi = FirstHeader; hi != nil; hi = hi-&gt;getNext()) { if (hi-&gt;mhdr() == (const headerType *)mh) break; } if (!hi) { if (outCount) *outCount = 0; return nil; } return copyClassNamesForImage_nolock(hi, outCount);}/************************************************************************ saveTemporaryString* Save a string in a thread-local FIFO buffer. * This is suitable for temporary strings generated for logging purposes.**********************************************************************/static voidsaveTemporaryString(char *str){ // Fixed-size FIFO. We free the first string, shift // the rest, and add the new string to the end. _objc_pthread_data *data = _objc_fetch_pthread_data(true); if (data-&gt;printableNames[0]) { free(data-&gt;printableNames[0]); } int last = countof(data-&gt;printableNames) - 1; for (int i = 0; i &lt; last; i++) { data-&gt;printableNames[i] = data-&gt;printableNames[i+1]; } data-&gt;printableNames[last] = str;}/************************************************************************ objc_class::nameForLogging* Returns the class's name, suitable for display.* The returned memory is TEMPORARY. Print it or copy it immediately.* Locking: none**********************************************************************/const char *objc_class::nameForLogging(){ // Handle the easy case directly. if (isRealized() || isFuture()) { if (!isAnySwift()) { return data()-&gt;ro()-&gt;getName(); } auto rwe = data()-&gt;ext(); if (rwe &amp;&amp; rwe-&gt;demangledName) { return rwe-&gt;demangledName; } } char *result; if (isStubClass()) { asprintf(&amp;result, &quot;&lt;stub class %p&gt;&quot;, this); } else if (const char *name = nonlazyMangledName()) { char *de = copySwiftV1DemangledName(name); if (de) result = de; else result = strdup(name); } else { asprintf(&amp;result, &quot;&lt;lazily named class %p&gt;&quot;, this); } saveTemporaryString(result); return result;}/************************************************************************ objc_class::demangledName* If realize=false, the class must already be realized or future.* Locking: runtimeLock may or may not be held by the caller.**********************************************************************/mutex_t DemangleCacheLock;static objc::DenseSet&lt;const char *&gt; *DemangleCache;const char *objc_class::demangledName(bool needsLock){ if (!needsLock) { runtimeLock.assertLocked(); } // Return previously demangled name if available. if (isRealized() || isFuture()) { // Swift metaclasses don't have the is-Swift bit. // We can't take this shortcut for them. if (isFuture() || (!isMetaClass() &amp;&amp; !isAnySwift())) { return data()-&gt;ro()-&gt;getName(); } auto rwe = data()-&gt;ext(); if (rwe &amp;&amp; rwe-&gt;demangledName) { return rwe-&gt;demangledName; } } // Try demangling the mangled name. const char *mangled = mangledName(); char *de = copySwiftV1DemangledName(mangled); class_rw_ext_t *rwe; if (isRealized() || isFuture()) { if (needsLock) { mutex_locker_t lock(runtimeLock); rwe = data()-&gt;extAllocIfNeeded(); } else { rwe = data()-&gt;extAllocIfNeeded(); } // Class is already realized or future. // Save demangling result in rw data. // We may not own runtimeLock so use an atomic operation instead. if (! OSAtomicCompareAndSwapPtrBarrier(nil, (void*)(de ?: mangled), (void**)&amp;rwe-&gt;demangledName)) { if (de) free(de); } return rwe-&gt;demangledName; } // Class is not yet realized. if (!de) { // Name is not mangled. Return it without caching. return mangled; } // Class is not yet realized and name is mangled. // Allocate the name but don't save it in the class. // Save the name in a side cache instead to prevent leaks. // When the class is actually realized we may allocate a second // copy of the name, but we don't care. // (Previously we would try to realize the class now and save the // name there, but realization is more complicated for Swift classes.) // Only objc_copyClassNamesForImage() should get here. // fixme lldb's calls to class_getName() can also get here when // interrogating the dyld shared cache. (rdar://27258517) // fixme ASSERT(realize); const char *cached; { mutex_locker_t lock(DemangleCacheLock); if (!DemangleCache) { DemangleCache = new objc::DenseSet&lt;const char *&gt;{}; } cached = *DemangleCache-&gt;insert(de).first; } if (cached != de) free(de); return cached;}/************************************************************************ class_getName* fixme* Locking: may acquire DemangleCacheLock**********************************************************************/const char *class_getName(Class cls){ if (!cls) return &quot;nil&quot;; // fixme lldb calls class_getName() on unrealized classes (rdar://27258517) // ASSERT(cls-&gt;isRealized() || cls-&gt;isFuture()); return cls-&gt;demangledName(/* needs lock */true);}/************************************************************************ objc_debug_class_getNameRaw* fixme* Locking: none**********************************************************************/const char *objc_debug_class_getNameRaw(Class cls){ if (!cls) return &quot;nil&quot;; return cls-&gt;mangledName();}/************************************************************************ class_getVersion* fixme* Locking: none**********************************************************************/int class_getVersion(Class cls){ if (!cls) return 0; ASSERT(cls-&gt;isRealized()); auto rwe = cls-&gt;data()-&gt;ext(); if (rwe) { return rwe-&gt;version; } return cls-&gt;isMetaClass() ? 7 : 0;}/************************************************************************ class_setVersion* fixme* Locking: none**********************************************************************/void class_setVersion(Class cls, int version){ if (!cls) return; ASSERT(cls-&gt;isRealized()); auto rwe = cls-&gt;data()-&gt;ext(); if (!rwe) { mutex_locker_t lock(runtimeLock); rwe = cls-&gt;data()-&gt;extAllocIfNeeded(); } rwe-&gt;version = version;}/*********************************************************************** * search_method_list_inline **********************************************************************/template&lt;class getNameFunc&gt;ALWAYS_INLINE static method_t *findMethodInSortedMethodList(SEL key, const method_list_t *list, const getNameFunc &amp;getName){ ASSERT(list); auto first = list-&gt;begin(); auto base = first; decltype(first) probe; uintptr_t keyValue = (uintptr_t)key; uint32_t count; for (count = list-&gt;count; count != 0; count &gt;&gt;= 1) { probe = base + (count &gt;&gt; 1); uintptr_t probeValue = (uintptr_t)getName(probe); if (keyValue == probeValue) { // `probe` is a match. // Rewind looking for the *first* occurrence of this value. // This is required for correct category overrides. while (probe &gt; first &amp;&amp; keyValue == (uintptr_t)getName((probe - 1))) { probe--; } return &amp;*probe; } if (keyValue &gt; probeValue) { base = probe + 1; count--; } } return nil;}ALWAYS_INLINE static method_t *findMethodInSortedMethodList(SEL key, const method_list_t *list){ if (list-&gt;isSmallList()) { if (CONFIG_SHARED_CACHE_RELATIVE_DIRECT_SELECTORS &amp;&amp; objc::inSharedCache((uintptr_t)list)) { return findMethodInSortedMethodList(key, list, [](method_t &amp;m) { return m.getSmallNameAsSEL(); }); } else { return findMethodInSortedMethodList(key, list, [](method_t &amp;m) { return m.getSmallNameAsSELRef(); }); } } else { return findMethodInSortedMethodList(key, list, [](method_t &amp;m) { return m.big().name; }); }}template&lt;class getNameFunc&gt;ALWAYS_INLINE static method_t *findMethodInUnsortedMethodList(SEL sel, const method_list_t *list, const getNameFunc &amp;getName){ for (auto&amp; meth : *list) { if (getName(meth) == sel) return &amp;meth; } return nil;}ALWAYS_INLINE static method_t *findMethodInUnsortedMethodList(SEL key, const method_list_t *list){ if (list-&gt;isSmallList()) { if (CONFIG_SHARED_CACHE_RELATIVE_DIRECT_SELECTORS &amp;&amp; objc::inSharedCache((uintptr_t)list)) { return findMethodInUnsortedMethodList(key, list, [](method_t &amp;m) { return m.getSmallNameAsSEL(); }); } else { return findMethodInUnsortedMethodList(key, list, [](method_t &amp;m) { return m.getSmallNameAsSELRef(); }); } } else { return findMethodInUnsortedMethodList(key, list, [](method_t &amp;m) { return m.big().name; }); }}ALWAYS_INLINE static method_t *search_method_list_inline(const method_list_t *mlist, SEL sel){ int methodListIsFixedUp = mlist-&gt;isFixedUp(); int methodListHasExpectedSize = mlist-&gt;isExpectedSize(); if (fastpath(methodListIsFixedUp &amp;&amp; methodListHasExpectedSize)) { return findMethodInSortedMethodList(sel, mlist); } else { // Linear search of unsorted method list if (auto *m = findMethodInUnsortedMethodList(sel, mlist)) return m; }#if DEBUG // sanity-check negative results if (mlist-&gt;isFixedUp()) { for (auto&amp; meth : *mlist) { if (meth.name() == sel) { _objc_fatal(&quot;linear search worked when binary search did not&quot;); } } }#endif return nil;}NEVER_INLINE static method_t *search_method_list(const method_list_t *mlist, SEL sel){ return search_method_list_inline(mlist, sel);}/*********************************************************************** * method_lists_contains_any **********************************************************************/template&lt;typename T&gt;static NEVER_INLINE boolmethod_lists_contains_any(T *mlists, T *end, SEL sels[], size_t selcount){ while (mlists &lt; end) { const method_list_t *mlist = *mlists++; int methodListIsFixedUp = mlist-&gt;isFixedUp(); int methodListHasExpectedSize = mlist-&gt;entsize() == sizeof(struct method_t::big); if (fastpath(methodListIsFixedUp &amp;&amp; methodListHasExpectedSize)) { for (size_t i = 0; i &lt; selcount; i++) { if (findMethodInSortedMethodList(sels[i], mlist)) { return true; } } } else { for (size_t i = 0; i &lt; selcount; i++) { if (findMethodInUnsortedMethodList(sels[i], mlist)) { return true; } } } } return false;}/*********************************************************************** * getMethodNoSuper_nolock * fixme * Locking: runtimeLock must be read- or write-locked by the caller **********************************************************************/static method_t *getMethodNoSuper_nolock(Class cls, SEL sel){ runtimeLock.assertLocked(); ASSERT(cls-&gt;isRealized()); // fixme nil cls? // fixme nil sel? auto const methods = cls-&gt;data()-&gt;methods(); for (auto mlists = methods.beginLists(), end = methods.endLists(); mlists != end; ++mlists) { // &lt;rdar://problem/46904873&gt; getMethodNoSuper_nolock is the hottest // caller of search_method_list, inlining it turns // getMethodNoSuper_nolock into a frame-less function and eliminates // any store from this codepath. method_t *m = search_method_list_inline(*mlists, sel); if (m) return m; } return nil;}/************************************************************************ getMethod_nolock* fixme* Locking: runtimeLock must be read- or write-locked by the caller**********************************************************************/static method_t *getMethod_nolock(Class cls, SEL sel){ method_t *m = nil; runtimeLock.assertLocked(); // fixme nil cls? // fixme nil sel? ASSERT(cls-&gt;isRealized()); while (cls &amp;&amp; ((m = getMethodNoSuper_nolock(cls, sel))) == nil) { cls = cls-&gt;getSuperclass(); } return m;}/************************************************************************ _class_getMethod* fixme* Locking: read-locks runtimeLock**********************************************************************/static Method _class_getMethod(Class cls, SEL sel){ mutex_locker_t lock(runtimeLock); return getMethod_nolock(cls, sel);}/************************************************************************ class_getInstanceMethod. Return the instance method for the* specified class and selector.**********************************************************************/Method class_getInstanceMethod(Class cls, SEL sel){ if (!cls || !sel) return nil; // This deliberately avoids +initialize because it historically did so. // This implementation is a bit weird because it's the only place that // wants a Method instead of an IMP.#warning fixme build and search caches // Search method lists, try method resolver, etc. lookUpImpOrForward(nil, sel, cls, LOOKUP_RESOLVER);#warning fixme build and search caches return _class_getMethod(cls, sel);}/************************************************************************ resolveClassMethod* Call +resolveClassMethod, looking for a method to be added to class cls.* cls should be a metaclass.* Does not check if the method already exists.**********************************************************************/static void resolveClassMethod(id inst, SEL sel, Class cls){ runtimeLock.assertUnlocked(); ASSERT(cls-&gt;isRealized()); ASSERT(cls-&gt;isMetaClass()); if (!lookUpImpOrNilTryCache(inst, @selector(resolveClassMethod:), cls)) { // Resolver not implemented. return; } Class nonmeta; { mutex_locker_t lock(runtimeLock); nonmeta = getMaybeUnrealizedNonMetaClass(cls, inst); // +initialize path should have realized nonmeta already if (!nonmeta-&gt;isRealized()) { _objc_fatal(&quot;nonmeta class %s (%p) unexpectedly not realized&quot;, nonmeta-&gt;nameForLogging(), nonmeta); } } BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend; bool resolved = msg(nonmeta, @selector(resolveClassMethod:), sel); // Cache the result (good or bad) so the resolver doesn't fire next time. // +resolveClassMethod adds to self-&gt;ISA() a.k.a. cls IMP imp = lookUpImpOrNilTryCache(inst, sel, cls); if (resolved &amp;&amp; PrintResolving) { if (imp) { _objc_inform(&quot;RESOLVE: method %c[%s %s] &quot; &quot;dynamically resolved to %p&quot;, cls-&gt;isMetaClass() ? '+' : '-', cls-&gt;nameForLogging(), sel_getName(sel), imp); } else { // Method resolver didn't add anything? _objc_inform(&quot;RESOLVE: +[%s resolveClassMethod:%s] returned YES&quot; &quot;, but no new implementation of %c[%s %s] was found&quot;, cls-&gt;nameForLogging(), sel_getName(sel), cls-&gt;isMetaClass() ? '+' : '-', cls-&gt;nameForLogging(), sel_getName(sel)); } }}/************************************************************************ resolveInstanceMethod* Call +resolveInstanceMethod, looking for a method to be added to class cls.* cls may be a metaclass or a non-meta class.* Does not check if the method already exists.**********************************************************************/static void resolveInstanceMethod(id inst, SEL sel, Class cls){ runtimeLock.assertUnlocked(); ASSERT(cls-&gt;isRealized()); SEL resolve_sel = @selector(resolveInstanceMethod:); if (!lookUpImpOrNilTryCache(cls, resolve_sel, cls-&gt;ISA(/*authenticated*/true))) { // Resolver not implemented. return; } BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend; bool resolved = msg(cls, resolve_sel, sel); // Cache the result (good or bad) so the resolver doesn't fire next time. // +resolveInstanceMethod adds to self a.k.a. cls IMP imp = lookUpImpOrNilTryCache(inst, sel, cls); if (resolved &amp;&amp; PrintResolving) { if (imp) { _objc_inform(&quot;RESOLVE: method %c[%s %s] &quot; &quot;dynamically resolved to %p&quot;, cls-&gt;isMetaClass() ? '+' : '-', cls-&gt;nameForLogging(), sel_getName(sel), imp); } else { // Method resolver didn't add anything? _objc_inform(&quot;RESOLVE: +[%s resolveInstanceMethod:%s] returned YES&quot; &quot;, but no new implementation of %c[%s %s] was found&quot;, cls-&gt;nameForLogging(), sel_getName(sel), cls-&gt;isMetaClass() ? '+' : '-', cls-&gt;nameForLogging(), sel_getName(sel)); } }}/************************************************************************ resolveMethod_locked* Call +resolveClassMethod or +resolveInstanceMethod.** Called with the runtimeLock held to avoid pressure in the caller* Tail calls into lookUpImpOrForward, also to avoid pressure in the callerb**********************************************************************/static NEVER_INLINE IMPresolveMethod_locked(id inst, SEL sel, Class cls, int behavior){ runtimeLock.assertLocked(); ASSERT(cls-&gt;isRealized()); runtimeLock.unlock(); if (! cls-&gt;isMetaClass()) { // try [cls resolveInstanceMethod:sel] resolveInstanceMethod(inst, sel, cls); } else { // try [nonMetaClass resolveClassMethod:sel] // and [cls resolveInstanceMethod:sel] resolveClassMethod(inst, sel, cls); if (!lookUpImpOrNilTryCache(inst, sel, cls)) { resolveInstanceMethod(inst, sel, cls); } } // chances are that calling the resolver have populated the cache // so attempt using it return lookUpImpOrForwardTryCache(inst, sel, cls, behavior);}/************************************************************************ log_and_fill_cache* Log this method call. If the logger permits it, fill the method cache.* cls is the method whose cache should be filled. * implementer is the class that owns the implementation in question.**********************************************************************/static voidlog_and_fill_cache(Class cls, IMP imp, SEL sel, id receiver, Class implementer){#if SUPPORT_MESSAGE_LOGGING if (slowpath(objcMsgLogEnabled &amp;&amp; implementer)) { bool cacheIt = logMessageSend(implementer-&gt;isMetaClass(), cls-&gt;nameForLogging(), implementer-&gt;nameForLogging(), sel); if (!cacheIt) return; }#endif cls-&gt;cache.insert(sel, imp, receiver);}/************************************************************************ realizeAndInitializeIfNeeded_locked* Realize the given class if not already realized, and initialize it if* not already initialized.* inst is an instance of cls or a subclass, or nil if none is known.* cls is the class to initialize and realize.* initializer is true to initialize the class, false to skip initialization.**********************************************************************/static ClassrealizeAndInitializeIfNeeded_locked(id inst, Class cls, bool initialize){ runtimeLock.assertLocked(); if (slowpath(!cls-&gt;isRealized())) { cls = realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock); // runtimeLock may have been dropped but is now locked again } if (slowpath(initialize &amp;&amp; !cls-&gt;isInitialized())) { cls = initializeAndLeaveLocked(cls, inst, runtimeLock); // runtimeLock may have been dropped but is now locked again // If sel == initialize, class_initialize will send +initialize and // then the messenger will send +initialize again after this // procedure finishes. Of course, if this is not being called // from the messenger then it won't happen. 2778172 } return cls;}/************************************************************************ lookUpImpOrForward / lookUpImpOrForwardTryCache / lookUpImpOrNilTryCache* The standard IMP lookup.** The TryCache variant attempts a fast-path lookup in the IMP Cache.* Most callers should use lookUpImpOrForwardTryCache with LOOKUP_INITIALIZE** Without LOOKUP_INITIALIZE: tries to avoid +initialize (but sometimes fails)* With LOOKUP_NIL: returns nil on negative cache hits** inst is an instance of cls or a subclass thereof, or nil if none is known.* If cls is an un-initialized metaclass then a non-nil inst is faster.* May return _objc_msgForward_impcache. IMPs destined for external use * must be converted to _objc_msgForward or _objc_msgForward_stret.* If you don't want forwarding at all, use LOOKUP_NIL.**********************************************************************/ALWAYS_INLINEstatic IMP _lookUpImpTryCache(id inst, SEL sel, Class cls, int behavior){ runtimeLock.assertUnlocked(); if (slowpath(!cls-&gt;isInitialized())) { // see comment in lookUpImpOrForward return lookUpImpOrForward(inst, sel, cls, behavior); } IMP imp = cache_getImp(cls, sel); if (imp != NULL) goto done;#if CONFIG_USE_PREOPT_CACHES if (fastpath(cls-&gt;cache.isConstantOptimizedCache(/* strict */true))) { imp = cache_getImp(cls-&gt;cache.preoptFallbackClass(), sel); }#endif if (slowpath(imp == NULL)) { return lookUpImpOrForward(inst, sel, cls, behavior); }done: if ((behavior &amp; LOOKUP_NIL) &amp;&amp; imp == (IMP)_objc_msgForward_impcache) { return nil; } return imp;}IMP lookUpImpOrForwardTryCache(id inst, SEL sel, Class cls, int behavior){ return _lookUpImpTryCache(inst, sel, cls, behavior);}IMP lookUpImpOrNilTryCache(id inst, SEL sel, Class cls, int behavior){ return _lookUpImpTryCache(inst, sel, cls, behavior | LOOKUP_NIL);}NEVER_INLINEIMP lookUpImpOrForward(id inst, SEL sel, Class cls, int behavior){ const IMP forward_imp = (IMP)_objc_msgForward_impcache; IMP imp = nil; Class curClass; runtimeLock.assertUnlocked(); if (slowpath(!cls-&gt;isInitialized())) { // The first message sent to a class is often +new or +alloc, or +self // which goes through objc_opt_* or various optimized entry points. // // However, the class isn't realized/initialized yet at this point, // and the optimized entry points fall down through objc_msgSend, // which ends up here. // // We really want to avoid caching these, as it can cause IMP caches // to be made with a single entry forever. // // Note that this check is racy as several threads might try to // message a given class for the first time at the same time, // in which case we might cache anyway. behavior |= LOOKUP_NOCACHE; } // runtimeLock is held during isRealized and isInitialized checking // to prevent races against concurrent realization. // runtimeLock is held during method search to make // method-lookup + cache-fill atomic with respect to method addition. // Otherwise, a category could be added but ignored indefinitely because // the cache was re-filled with the old value after the cache flush on // behalf of the category. runtimeLock.lock(); // We don't want people to be able to craft a binary blob that looks like // a class but really isn't one and do a CFI attack. // // To make these harder we want to make sure this is a class that was // either built into the binary or legitimately registered through // objc_duplicateClass, objc_initializeClassPair or objc_allocateClassPair. checkIsKnownClass(cls); cls = realizeAndInitializeIfNeeded_locked(inst, cls, behavior &amp; LOOKUP_INITIALIZE); // runtimeLock may have been dropped but is now locked again runtimeLock.assertLocked(); curClass = cls; // The code used to lookup the class's cache again right after // we take the lock but for the vast majority of the cases // evidence shows this is a miss most of the time, hence a time loss. // // The only codepath calling into this without having performed some // kind of cache lookup is class_getInstanceMethod(). for (unsigned attempts = unreasonableClassCount();;) { if (curClass-&gt;cache.isConstantOptimizedCache(/* strict */true)) {#if CONFIG_USE_PREOPT_CACHES imp = cache_getImp(curClass, sel); if (imp) goto done_unlock; curClass = curClass-&gt;cache.preoptFallbackClass();#endif } else { // curClass method list. Method meth = getMethodNoSuper_nolock(curClass, sel); if (meth) { imp = meth-&gt;imp(false); goto done; } if (slowpath((curClass = curClass-&gt;getSuperclass()) == nil)) { // No implementation found, and method resolver didn't help. // Use forwarding. imp = forward_imp; break; } } // Halt if there is a cycle in the superclass chain. if (slowpath(--attempts == 0)) { _objc_fatal(&quot;Memory corruption in class list.&quot;); } // Superclass cache. imp = cache_getImp(curClass, sel); if (slowpath(imp == forward_imp)) { // Found a forward:: entry in a superclass. // Stop searching, but don't cache yet; call method // resolver for this class first. break; } if (fastpath(imp)) { // Found the method in a superclass. Cache it in this class. goto done; } } // No implementation found. Try method resolver once. if (slowpath(behavior &amp; LOOKUP_RESOLVER)) { behavior ^= LOOKUP_RESOLVER; return resolveMethod_locked(inst, sel, cls, behavior); } done: if (fastpath((behavior &amp; LOOKUP_NOCACHE) == 0)) {#if CONFIG_USE_PREOPT_CACHES while (cls-&gt;cache.isConstantOptimizedCache(/* strict */true)) { cls = cls-&gt;cache.preoptFallbackClass(); }#endif log_and_fill_cache(cls, imp, sel, inst, curClass); } done_unlock: runtimeLock.unlock(); if (slowpath((behavior &amp; LOOKUP_NIL) &amp;&amp; imp == forward_imp)) { return nil; } return imp;}/************************************************************************ lookupMethodInClassAndLoadCache.* Like lookUpImpOrForward, but does not search superclasses.* Caches and returns objc_msgForward if the method is not found in the class.**********************************************************************/IMP lookupMethodInClassAndLoadCache(Class cls, SEL sel){ IMP imp; // fixme this is incomplete - no resolver, +initialize - // but it's only used for .cxx_construct/destruct so we don't care ASSERT(sel == SEL_cxx_construct || sel == SEL_cxx_destruct); // Search cache first. // // If the cache used for the lookup is preoptimized, // we ask for `_objc_msgForward_impcache` to be returned on cache misses, // so that there's no TOCTOU race between using `isConstantOptimizedCache` // and calling cache_getImp() when not under the runtime lock. // // For dynamic caches, a miss will return `nil` imp = cache_getImp(cls, sel, _objc_msgForward_impcache); if (slowpath(imp == nil)) { // Cache miss. Search method list. mutex_locker_t lock(runtimeLock); if (auto meth = getMethodNoSuper_nolock(cls, sel)) { // Hit in method list. Cache it. imp = meth-&gt;imp(false); } else { imp = _objc_msgForward_impcache; } // Note, because we do not hold the runtime lock above // isConstantOptimizedCache might flip, so we need to double check if (!cls-&gt;cache.isConstantOptimizedCache(true /* strict */)) { cls-&gt;cache.insert(sel, imp, nil); } } return imp;}/************************************************************************ class_getProperty* fixme* Locking: read-locks runtimeLock**********************************************************************/objc_property_t class_getProperty(Class cls, const char *name){ if (!cls || !name) return nil; mutex_locker_t lock(runtimeLock); checkIsKnownClass(cls); ASSERT(cls-&gt;isRealized()); for ( ; cls; cls = cls-&gt;getSuperclass()) { for (auto&amp; prop : cls-&gt;data()-&gt;properties()) { if (0 == strcmp(name, prop.name)) { return (objc_property_t)&amp;prop; } } } return nil;}/************************************************************************ Locking: fixme**********************************************************************/Class gdb_class_getClass(Class cls){ const char *className = cls-&gt;mangledName(); if(!className || !strlen(className)) return Nil; Class rCls = look_up_class(className, NO, NO); return rCls;}Class gdb_object_getClass(id obj){ if (!obj) return nil; return gdb_class_getClass(obj-&gt;getIsa());}/************************************************************************ Locking: write-locks runtimeLock**********************************************************************/void objc_class::setInitialized(){ Class metacls; Class cls; ASSERT(!isMetaClass()); cls = (Class)this; metacls = cls-&gt;ISA(); mutex_locker_t lock(runtimeLock); // Special cases: // - NSObject AWZ class methods are default. // - NSObject RR class and instance methods are default. // - NSObject Core class and instance methods are default. // adjustCustomFlagsForMethodChange() also knows these special cases. // attachMethodLists() also knows these special cases. objc::AWZScanner::scanInitializedClass(cls, metacls); objc::RRScanner::scanInitializedClass(cls, metacls); objc::CoreScanner::scanInitializedClass(cls, metacls);#if CONFIG_USE_PREOPT_CACHES cls-&gt;cache.maybeConvertToPreoptimized(); metacls-&gt;cache.maybeConvertToPreoptimized();#endif if (PrintInitializing) { _objc_inform(&quot;INITIALIZE: thread %p: setInitialized(%s)&quot;, objc_thread_self(), cls-&gt;nameForLogging()); } // Update the +initialize flags. // Do this last. metacls-&gt;changeInfo(RW_INITIALIZED, RW_INITIALIZING);}voidobjc_class::printInstancesRequireRawIsa(bool inherited){ ASSERT(PrintRawIsa); ASSERT(instancesRequireRawIsa()); _objc_inform(&quot;RAW ISA: %s%s%s&quot;, nameForLogging(), isMetaClass() ? &quot; (meta)&quot; : &quot;&quot;, inherited ? &quot; (inherited)&quot; : &quot;&quot;);}/************************************************************************ Mark this class and all of its subclasses as requiring raw isa pointers**********************************************************************/void objc_class::setInstancesRequireRawIsaRecursively(bool inherited){ Class cls = (Class)this; runtimeLock.assertLocked(); if (instancesRequireRawIsa()) return; foreach_realized_class_and_subclass(cls, [=](Class c){ if (c-&gt;instancesRequireRawIsa()) { return false; } c-&gt;setInstancesRequireRawIsa(); if (PrintRawIsa) c-&gt;printInstancesRequireRawIsa(inherited || c != cls); return true; });}#if CONFIG_USE_PREOPT_CACHESvoid objc_class::setDisallowPreoptCachesRecursively(const char *why){ Class cls = (Class)this; runtimeLock.assertLocked(); if (!allowsPreoptCaches()) return; foreach_realized_class_and_subclass(cls, [=](Class c){ if (!c-&gt;allowsPreoptCaches()) { return false; } if (c-&gt;cache.isConstantOptimizedCache(/* strict */true)) { c-&gt;cache.eraseNolock(why); } else { if (PrintCaches) { _objc_inform(&quot;CACHES: %sclass %s: disallow preopt cache (from %s)&quot;, isMetaClass() ? &quot;meta&quot; : &quot;&quot;, nameForLogging(), why); } c-&gt;setDisallowPreoptCaches(); } return true; });}void objc_class::setDisallowPreoptInlinedSelsRecursively(const char *why){ Class cls = (Class)this; runtimeLock.assertLocked(); if (!allowsPreoptInlinedSels()) return; foreach_realized_class_and_subclass(cls, [=](Class c){ if (!c-&gt;allowsPreoptInlinedSels()) { return false; } if (PrintCaches) { _objc_inform(&quot;CACHES: %sclass %s: disallow sel-inlined preopt cache (from %s)&quot;, isMetaClass() ? &quot;meta&quot; : &quot;&quot;, nameForLogging(), why); } c-&gt;setDisallowPreoptInlinedSels(); if (c-&gt;cache.isConstantOptimizedCacheWithInlinedSels()) { c-&gt;cache.eraseNolock(why); } return true; });}#endif/************************************************************************ Choose a class index. * Set instancesRequireRawIsa if no more class indexes are available.**********************************************************************/void objc_class::chooseClassArrayIndex(){#if SUPPORT_INDEXED_ISA Class cls = (Class)this; runtimeLock.assertLocked(); if (objc_indexed_classes_count &gt;= ISA_INDEX_COUNT) { // No more indexes available. ASSERT(cls-&gt;classArrayIndex() == 0); cls-&gt;setInstancesRequireRawIsaRecursively(false/*not inherited*/); return; } unsigned index = objc_indexed_classes_count++; if (index == 0) index = objc_indexed_classes_count++; // index 0 is unused classForIndex(index) = cls; cls-&gt;setClassArrayIndex(index);#endif}static const char *empty_lazyClassNamer(Class cls __unused) { return nullptr;}static ChainedHookFunction&lt;objc_hook_lazyClassNamer&gt; LazyClassNamerHook{empty_lazyClassNamer};void objc_setHook_lazyClassNamer(_Nonnull objc_hook_lazyClassNamer newValue, _Nonnull objc_hook_lazyClassNamer * _Nonnull oldOutValue) { LazyClassNamerHook.set(newValue, oldOutValue);}const char * objc_class::installMangledNameForLazilyNamedClass() { auto lazyClassNamer = LazyClassNamerHook.get(); if (!*lazyClassNamer) { _objc_fatal(&quot;Lazily named class %p with no lazy name handler registered&quot;, this); } // If this is called on a metaclass, extract the original class // and make it do the installation instead. It will install // the metaclass's name too. if (isMetaClass()) { Class nonMeta = bits.safe_ro()-&gt;getNonMetaclass(); return nonMeta-&gt;installMangledNameForLazilyNamedClass(); } Class cls = (Class)this; Class metaclass = ISA(); const char *name = lazyClassNamer((Class)this); if (!name) { _objc_fatal(&quot;Lazily named class %p wasn't named by lazy name handler&quot;, this); } // Emplace the name into the class_ro_t. If we lose the race, // then we'll free our name and use whatever got placed there // instead of our name. const char *previously = NULL; class_ro_t *ro = (class_ro_t *)cls-&gt;bits.safe_ro(); bool wonRace = ro-&gt;name.compare_exchange_strong(previously, name, std::memory_order_release, std::memory_order_acquire); if (!wonRace) { free((void *)name); name = previously; } // Emplace whatever name won the race in the metaclass too. class_ro_t *metaRO = (class_ro_t *)metaclass-&gt;bits.safe_ro(); // Write our pointer if the current value is NULL. There's no // need to loop or check success, since the only way this can // fail is if another thread succeeded in writing the exact // same pointer. const char *expected = NULL; metaRO-&gt;name.compare_exchange_strong(expected, name, std::memory_order_release, std::memory_order_acquire); return name;}/************************************************************************ Update custom RR and AWZ when a method changes its IMP**********************************************************************/static voidadjustCustomFlagsForMethodChange(Class cls, method_t *meth){ objc::AWZScanner::scanChangedMethod(cls, meth); objc::RRScanner::scanChangedMethod(cls, meth); objc::CoreScanner::scanChangedMethod(cls, meth);}/************************************************************************ class_getIvarLayout* Called by the garbage collector. * The class must be nil or already realized. * Locking: none**********************************************************************/const uint8_t *class_getIvarLayout(Class cls){ if (cls) return cls-&gt;data()-&gt;ro()-&gt;getIvarLayout(); else return nil;}/************************************************************************ class_getWeakIvarLayout* Called by the garbage collector. * The class must be nil or already realized. * Locking: none**********************************************************************/const uint8_t *class_getWeakIvarLayout(Class cls){ if (cls) return cls-&gt;data()-&gt;ro()-&gt;weakIvarLayout; else return nil;}/************************************************************************ class_setIvarLayout* Changes the class's ivar layout.* nil layout means no unscanned ivars* The class must be under construction.* fixme: sanity-check layout vs instance size?* fixme: sanity-check layout vs superclass?* Locking: acquires runtimeLock**********************************************************************/voidclass_setIvarLayout(Class cls, const uint8_t *layout){ if (!cls) return; ASSERT(!cls-&gt;isMetaClass()); mutex_locker_t lock(runtimeLock); checkIsKnownClass(cls); // Can only change layout of in-construction classes. // note: if modifications to post-construction classes were // allowed, there would be a race below (us vs. concurrent object_setIvar) if (!(cls-&gt;data()-&gt;flags &amp; RW_CONSTRUCTING)) { _objc_inform(&quot;*** Can't set ivar layout for already-registered &quot; &quot;class '%s'&quot;, cls-&gt;nameForLogging()); return; } class_ro_t *ro_w = make_ro_writeable(cls-&gt;data()); try_free(ro_w-&gt;getIvarLayout()); ro_w-&gt;ivarLayout = ustrdupMaybeNil(layout);}/************************************************************************ class_setWeakIvarLayout* Changes the class's weak ivar layout.* nil layout means no weak ivars* The class must be under construction.* fixme: sanity-check layout vs instance size?* fixme: sanity-check layout vs superclass?* Locking: acquires runtimeLock**********************************************************************/voidclass_setWeakIvarLayout(Class cls, const uint8_t *layout){ if (!cls) return; mutex_locker_t lock(runtimeLock); checkIsKnownClass(cls); // Can only change layout of in-construction classes. // note: if modifications to post-construction classes were // allowed, there would be a race below (us vs. concurrent object_setIvar) if (!(cls-&gt;data()-&gt;flags &amp; RW_CONSTRUCTING)) { _objc_inform(&quot;*** Can't set weak ivar layout for already-registered &quot; &quot;class '%s'&quot;, cls-&gt;nameForLogging()); return; } class_ro_t *ro_w = make_ro_writeable(cls-&gt;data()); try_free(ro_w-&gt;weakIvarLayout); ro_w-&gt;weakIvarLayout = ustrdupMaybeNil(layout);}/************************************************************************ getIvar* Look up an ivar by name.* Locking: runtimeLock must be read- or write-locked by the caller.**********************************************************************/static ivar_t *getIvar(Class cls, const char *name){ runtimeLock.assertLocked(); const ivar_list_t *ivars; ASSERT(cls-&gt;isRealized()); if ((ivars = cls-&gt;data()-&gt;ro()-&gt;ivars)) { for (auto&amp; ivar : *ivars) { if (!ivar.offset) continue; // anonymous bitfield // ivar.name may be nil for anonymous bitfields etc. if (ivar.name &amp;&amp; 0 == strcmp(name, ivar.name)) { return &amp;ivar; } } } return nil;}/************************************************************************ _class_getClassForIvar* Given a class and an ivar that is in it or one of its superclasses, * find the actual class that defined the ivar.**********************************************************************/Class _class_getClassForIvar(Class cls, Ivar ivar){ mutex_locker_t lock(runtimeLock); for ( ; cls; cls = cls-&gt;getSuperclass()) { if (auto ivars = cls-&gt;data()-&gt;ro()-&gt;ivars) { if (ivars-&gt;containsIvar(ivar)) { return cls; } } } return nil;}/************************************************************************ _class_getVariable* fixme* Locking: read-locks runtimeLock**********************************************************************/Ivar _class_getVariable(Class cls, const char *name){ mutex_locker_t lock(runtimeLock); for ( ; cls; cls = cls-&gt;getSuperclass()) { ivar_t *ivar = getIvar(cls, name); if (ivar) { return ivar; } } return nil;}/************************************************************************ class_conformsToProtocol* fixme* Locking: read-locks runtimeLock**********************************************************************/BOOL class_conformsToProtocol(Class cls, Protocol *proto_gen){ protocol_t *proto = newprotocol(proto_gen); if (!cls) return NO; if (!proto_gen) return NO; mutex_locker_t lock(runtimeLock); checkIsKnownClass(cls); ASSERT(cls-&gt;isRealized()); for (const auto&amp; proto_ref : cls-&gt;data()-&gt;protocols()) { protocol_t *p = remapProtocol(proto_ref); if (p == proto || protocol_conformsToProtocol_nolock(p, proto)) { return YES; } } return NO;}static voidaddMethods_finish(Class cls, method_list_t *newlist){ auto rwe = cls-&gt;data()-&gt;extAllocIfNeeded(); if (newlist-&gt;count &gt; 1) { method_t::SortBySELAddress sorter; std::stable_sort(&amp;newlist-&gt;begin()-&gt;big(), &amp;newlist-&gt;end()-&gt;big(), sorter); } prepareMethodLists(cls, &amp;newlist, 1, NO, NO, __func__); rwe-&gt;methods.attachLists(&amp;newlist, 1); // If the class being modified has a constant cache, // then all children classes are flattened constant caches // and need to be flushed as well. flushCaches(cls, __func__, [](Class c){ // constant caches have been dealt with in prepareMethodLists // if the class still is constant here, it's fine to keep return !c-&gt;cache.isConstantOptimizedCache(); });}/*********************************************************************** addMethod* fixme* Locking: runtimeLock must be held by the caller**********************************************************************/static IMP addMethod(Class cls, SEL name, IMP imp, const char *types, bool replace){ IMP result = nil; runtimeLock.assertLocked(); checkIsKnownClass(cls); ASSERT(types); ASSERT(cls-&gt;isRealized()); method_t *m; if ((m = getMethodNoSuper_nolock(cls, name))) { // already exists if (!replace) { result = m-&gt;imp(false); } else { result = _method_setImplementation(cls, m, imp); } } else { // fixme optimize method_list_t *newlist; newlist = (method_list_t *)calloc(method_list_t::byteSize(method_t::bigSize, 1), 1); newlist-&gt;entsizeAndFlags = (uint32_t)sizeof(struct method_t::big) | fixed_up_method_list; newlist-&gt;count = 1; auto &amp;first = newlist-&gt;begin()-&gt;big(); first.name = name; first.types = strdupIfMutable(types); first.imp = imp; addMethods_finish(cls, newlist); result = nil; } return result;}/*********************************************************************** addMethods* Add the given methods to a class in bulk.* Returns the selectors which could not be added, when replace == NO and a* method already exists. The returned selectors are NULL terminated and must be* freed by the caller. They are NULL if no failures occurred.* Locking: runtimeLock must be held by the caller**********************************************************************/static SEL *addMethods(Class cls, const SEL *names, const IMP *imps, const char **types, uint32_t count, bool replace, uint32_t *outFailedCount){ runtimeLock.assertLocked(); ASSERT(names); ASSERT(imps); ASSERT(types); ASSERT(cls-&gt;isRealized()); method_list_t *newlist; size_t newlistSize = method_list_t::byteSize(sizeof(struct method_t::big), count); newlist = (method_list_t *)calloc(newlistSize, 1); newlist-&gt;entsizeAndFlags = (uint32_t)sizeof(struct method_t::big) | fixed_up_method_list; newlist-&gt;count = 0; SEL *failedNames = nil; uint32_t failedCount = 0; for (uint32_t i = 0; i &lt; count; i++) { method_t *m; if ((m = getMethodNoSuper_nolock(cls, names[i]))) { // already exists if (!replace) { // report failure if (failedNames == nil) { // allocate an extra entry for a trailing NULL in case // every method fails failedNames = (SEL *)calloc(sizeof(*failedNames), count + 1); } failedNames[failedCount] = m-&gt;name(); failedCount++; } else { _method_setImplementation(cls, m, imps[i]); } } else { auto &amp;newmethod = newlist-&gt;end()-&gt;big(); newmethod.name = names[i]; newmethod.types = strdupIfMutable(types[i]); newmethod.imp = imps[i]; newlist-&gt;count++; } } if (newlist-&gt;count &gt; 0) { // fixme resize newlist because it may have been over-allocated above. // Note that realloc() alone doesn't work due to ptrauth. addMethods_finish(cls, newlist); } else { // Attaching the method list to the class consumes it. If we don't // do that, we have to free the memory ourselves. free(newlist); } if (outFailedCount) *outFailedCount = failedCount; return failedNames;}BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types){ if (!cls) return NO; mutex_locker_t lock(runtimeLock); return ! addMethod(cls, name, imp, types ?: &quot;&quot;, NO);}IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types){ if (!cls) return nil; mutex_locker_t lock(runtimeLock); return addMethod(cls, name, imp, types ?: &quot;&quot;, YES);}SEL *class_addMethodsBulk(Class cls, const SEL *names, const IMP *imps, const char **types, uint32_t count, uint32_t *outFailedCount){ if (!cls) { if (outFailedCount) *outFailedCount = count; return (SEL *)memdup(names, count * sizeof(*names)); } mutex_locker_t lock(runtimeLock); return addMethods(cls, names, imps, types, count, NO, outFailedCount);}voidclass_replaceMethodsBulk(Class cls, const SEL *names, const IMP *imps, const char **types, uint32_t count){ if (!cls) return; mutex_locker_t lock(runtimeLock); addMethods(cls, names, imps, types, count, YES, nil);}/************************************************************************ class_addIvar* Adds an ivar to a class.* Locking: acquires runtimeLock**********************************************************************/BOOL class_addIvar(Class cls, const char *name, size_t size, uint8_t alignment, const char *type){ if (!cls) return NO; if (!type) type = &quot;&quot;; if (name &amp;&amp; 0 == strcmp(name, &quot;&quot;)) name = nil; mutex_locker_t lock(runtimeLock); checkIsKnownClass(cls); ASSERT(cls-&gt;isRealized()); // No class variables if (cls-&gt;isMetaClass()) { return NO; } // Can only add ivars to in-construction classes. if (!(cls-&gt;data()-&gt;flags &amp; RW_CONSTRUCTING)) { return NO; } // Check for existing ivar with this name, unless it's anonymous. // Check for too-big ivar. // fixme check for superclass ivar too? if ((name &amp;&amp; getIvar(cls, name)) || size &gt; UINT32_MAX) { return NO; } class_ro_t *ro_w = make_ro_writeable(cls-&gt;data()); // fixme allocate less memory here ivar_list_t *oldlist, *newlist; if ((oldlist = (ivar_list_t *)cls-&gt;data()-&gt;ro()-&gt;ivars)) { size_t oldsize = oldlist-&gt;byteSize(); newlist = (ivar_list_t *)calloc(oldsize + oldlist-&gt;entsize(), 1); memcpy(newlist, oldlist, oldsize); free(oldlist); } else { newlist = (ivar_list_t *)calloc(ivar_list_t::byteSize(sizeof(ivar_t), 1), 1); newlist-&gt;entsizeAndFlags = (uint32_t)sizeof(ivar_t); } uint32_t offset = cls-&gt;unalignedInstanceSize(); uint32_t alignMask = (1&lt;&lt;alignment)-1; offset = (offset + alignMask) &amp; ~alignMask; ivar_t&amp; ivar = newlist-&gt;get(newlist-&gt;count++);#if __x86_64__ // Deliberately over-allocate the ivar offset variable. // Use calloc() to clear all 64 bits. See the note in struct ivar_t. ivar.offset = (int32_t *)(int64_t *)calloc(sizeof(int64_t), 1);#else ivar.offset = (int32_t *)malloc(sizeof(int32_t));#endif *ivar.offset = offset; ivar.name = name ? strdupIfMutable(name) : nil; ivar.type = strdupIfMutable(type); ivar.alignment_raw = alignment; ivar.size = (uint32_t)size; ro_w-&gt;ivars = newlist; cls-&gt;setInstanceSize((uint32_t)(offset + size)); // Ivar layout updated in registerClass. return YES;}/************************************************************************ class_addProtocol* Adds a protocol to a class.* Locking: acquires runtimeLock**********************************************************************/BOOL class_addProtocol(Class cls, Protocol *protocol_gen){ protocol_t *protocol = newprotocol(protocol_gen); if (!cls) return NO; if (class_conformsToProtocol(cls, protocol_gen)) return NO; mutex_locker_t lock(runtimeLock); auto rwe = cls-&gt;data()-&gt;extAllocIfNeeded(); ASSERT(cls-&gt;isRealized()); // fixme optimize protocol_list_t *protolist = (protocol_list_t *) malloc(sizeof(protocol_list_t) + sizeof(protocol_t *)); protolist-&gt;count = 1; protolist-&gt;list[0] = (protocol_ref_t)protocol; rwe-&gt;protocols.attachLists(&amp;protolist, 1); // fixme metaclass? return YES;}/************************************************************************ class_addProperty* Adds a property to a class.* Locking: acquires runtimeLock**********************************************************************/static bool _class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attrs, unsigned int count, bool replace){ if (!cls) return NO; if (!name) return NO; property_t *prop = class_getProperty(cls, name); if (prop &amp;&amp; !replace) { // already exists, refuse to replace return NO; } else if (prop) { // replace existing mutex_locker_t lock(runtimeLock); try_free(prop-&gt;attributes); prop-&gt;attributes = copyPropertyAttributeString(attrs, count); return YES; } else { mutex_locker_t lock(runtimeLock); auto rwe = cls-&gt;data()-&gt;extAllocIfNeeded(); ASSERT(cls-&gt;isRealized()); property_list_t *proplist = (property_list_t *) malloc(property_list_t::byteSize(sizeof(property_t), 1)); proplist-&gt;count = 1; proplist-&gt;entsizeAndFlags = sizeof(property_t); proplist-&gt;begin()-&gt;name = strdupIfMutable(name); proplist-&gt;begin()-&gt;attributes = copyPropertyAttributeString(attrs, count); rwe-&gt;properties.attachLists(&amp;proplist, 1); return YES; }}BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attrs, unsigned int n){ return _class_addProperty(cls, name, attrs, n, NO);}void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attrs, unsigned int n){ _class_addProperty(cls, name, attrs, n, YES);}/************************************************************************ look_up_class* Look up a class by name, and realize it.* Locking: acquires runtimeLock**********************************************************************/static BOOL empty_getClass(const char *name, Class *outClass){ *outClass = nil; return NO;}static ChainedHookFunction&lt;objc_hook_getClass&gt; GetClassHook{empty_getClass};void objc_setHook_getClass(objc_hook_getClass newValue, objc_hook_getClass *outOldValue){ GetClassHook.set(newValue, outOldValue);}Class look_up_class(const char *name, bool includeUnconnected __attribute__((unused)), bool includeClassHandler __attribute__((unused))){ if (!name) return nil; Class result; bool unrealized; { runtimeLock.lock(); result = getClassExceptSomeSwift(name); unrealized = result &amp;&amp; !result-&gt;isRealized(); if (unrealized) { result = realizeClassMaybeSwiftAndUnlock(result, runtimeLock); // runtimeLock is now unlocked } else { runtimeLock.unlock(); } } if (!result) { // Ask Swift about its un-instantiated classes. // We use thread-local storage to prevent infinite recursion // if the hook function provokes another lookup of the same name // (for example, if the hook calls objc_allocateClassPair) auto *tls = _objc_fetch_pthread_data(true); // Stop if this thread is already looking up this name. for (unsigned i = 0; i &lt; tls-&gt;classNameLookupsUsed; i++) { if (0 == strcmp(name, tls-&gt;classNameLookups[i])) { return nil; } } // Save this lookup in tls. if (tls-&gt;classNameLookupsUsed == tls-&gt;classNameLookupsAllocated) { tls-&gt;classNameLookupsAllocated = (tls-&gt;classNameLookupsAllocated * 2 ?: 1); size_t size = tls-&gt;classNameLookupsAllocated * sizeof(tls-&gt;classNameLookups[0]); tls-&gt;classNameLookups = (const char **) realloc(tls-&gt;classNameLookups, size); } tls-&gt;classNameLookups[tls-&gt;classNameLookupsUsed++] = name; // Call the hook. Class swiftcls = nil; if (GetClassHook.get()(name, &amp;swiftcls)) { ASSERT(swiftcls-&gt;isRealized()); result = swiftcls; } // Erase the name from tls. unsigned slot = --tls-&gt;classNameLookupsUsed; ASSERT(slot &gt;= 0 &amp;&amp; slot &lt; tls-&gt;classNameLookupsAllocated); ASSERT(name == tls-&gt;classNameLookups[slot]); tls-&gt;classNameLookups[slot] = nil; } return result;}/************************************************************************ objc_duplicateClass* fixme* Locking: acquires runtimeLock**********************************************************************/Class objc_duplicateClass(Class original, const char *name, size_t extraBytes){ Class duplicate; mutex_locker_t lock(runtimeLock); checkIsKnownClass(original); auto orig_rw = original-&gt;data(); auto orig_rwe = orig_rw-&gt;ext(); auto orig_ro = orig_rw-&gt;ro(); ASSERT(original-&gt;isRealized()); ASSERT(!original-&gt;isMetaClass()); duplicate = alloc_class_for_subclass(original, extraBytes); duplicate-&gt;initClassIsa(original-&gt;ISA()); duplicate-&gt;setSuperclass(original-&gt;getSuperclass()); duplicate-&gt;cache.initializeToEmpty(); class_rw_t *rw = objc::zalloc&lt;class_rw_t&gt;(); rw-&gt;flags = (orig_rw-&gt;flags | RW_COPIED_RO | RW_REALIZING); rw-&gt;firstSubclass = nil; rw-&gt;nextSiblingClass = nil; duplicate-&gt;bits = original-&gt;bits; duplicate-&gt;setData(rw); auto ro = orig_ro-&gt;duplicate(); *(char **)&amp;ro-&gt;name = strdupIfMutable(name); rw-&gt;set_ro(ro); if (orig_rwe) { auto rwe = rw-&gt;extAllocIfNeeded(); rwe-&gt;version = orig_rwe-&gt;version; orig_rwe-&gt;methods.duplicateInto(rwe-&gt;methods); // fixme dies when categories are added to the base rwe-&gt;properties = orig_rwe-&gt;properties; rwe-&gt;protocols = orig_rwe-&gt;protocols; } else if (ro-&gt;baseMethods()) { // if we have base methods, we need to make a deep copy // which requires a class_rw_ext_t to be allocated rw-&gt;deepCopy(ro); } duplicate-&gt;chooseClassArrayIndex(); if (duplicate-&gt;getSuperclass()) { addSubclass(duplicate-&gt;getSuperclass(), duplicate); // duplicate-&gt;isa == original-&gt;isa so don't addSubclass() for it } else { addRootClass(duplicate); } // Don't methodize class - construction above is correct addNamedClass(duplicate, ro-&gt;getName()); addClassTableEntry(duplicate, /*addMeta=*/false); if (PrintConnecting) { _objc_inform(&quot;CLASS: realizing class '%s' (duplicate of %s) %p %p&quot;, name, original-&gt;nameForLogging(), (void*)duplicate, ro); } duplicate-&gt;clearInfo(RW_REALIZING); return duplicate;}/************************************************************************ objc_initializeClassPair* Locking: runtimeLock must be write-locked by the caller**********************************************************************/// &amp;UnsetLayout is the default ivar layout during class constructionstatic const uint8_t UnsetLayout = 0;static void objc_initializeClassPair_internal(Class superclass, const char *name, Class cls, Class meta){ runtimeLock.assertLocked(); class_ro_t *cls_ro_w, *meta_ro_w; class_rw_t *cls_rw_w, *meta_rw_w; cls_rw_w = objc::zalloc&lt;class_rw_t&gt;(); meta_rw_w = objc::zalloc&lt;class_rw_t&gt;(); cls_ro_w = (class_ro_t *)calloc(sizeof(class_ro_t), 1); meta_ro_w = (class_ro_t *)calloc(sizeof(class_ro_t), 1); cls-&gt;setData(cls_rw_w); cls_rw_w-&gt;set_ro(cls_ro_w); meta-&gt;setData(meta_rw_w); meta_rw_w-&gt;set_ro(meta_ro_w); // Set basic info cls_rw_w-&gt;flags = RW_CONSTRUCTING | RW_COPIED_RO | RW_REALIZED | RW_REALIZING; meta_rw_w-&gt;flags = RW_CONSTRUCTING | RW_COPIED_RO | RW_REALIZED | RW_REALIZING | RW_META; cls_ro_w-&gt;flags = 0; meta_ro_w-&gt;flags = RO_META; if (superclass) { uint32_t flagsToCopy = RW_FORBIDS_ASSOCIATED_OBJECTS; cls_rw_w-&gt;flags |= superclass-&gt;data()-&gt;flags &amp; flagsToCopy; cls_ro_w-&gt;instanceStart = superclass-&gt;unalignedInstanceSize(); meta_ro_w-&gt;instanceStart = superclass-&gt;ISA()-&gt;unalignedInstanceSize(); cls-&gt;setInstanceSize(cls_ro_w-&gt;instanceStart); meta-&gt;setInstanceSize(meta_ro_w-&gt;instanceStart); } else { cls_ro_w-&gt;flags |= RO_ROOT; meta_ro_w-&gt;flags |= RO_ROOT; cls_ro_w-&gt;instanceStart = 0; meta_ro_w-&gt;instanceStart = (uint32_t)sizeof(objc_class); cls-&gt;setInstanceSize((uint32_t)sizeof(id)); // just an isa meta-&gt;setInstanceSize(meta_ro_w-&gt;instanceStart); } cls_ro_w-&gt;name.store(strdupIfMutable(name), std::memory_order_release); meta_ro_w-&gt;name.store(strdupIfMutable(name), std::memory_order_release); cls_ro_w-&gt;ivarLayout = &amp;UnsetLayout; cls_ro_w-&gt;weakIvarLayout = &amp;UnsetLayout; meta-&gt;chooseClassArrayIndex(); cls-&gt;chooseClassArrayIndex(); // This absolutely needs to be done before addSubclass // as initializeToEmpty() clobbers the FAST_CACHE bits cls-&gt;cache.initializeToEmpty(); meta-&gt;cache.initializeToEmpty();#if FAST_CACHE_META meta-&gt;cache.setBit(FAST_CACHE_META);#endif meta-&gt;setInstancesRequireRawIsa(); // Connect to superclasses and metaclasses cls-&gt;initClassIsa(meta); if (superclass) { meta-&gt;initClassIsa(superclass-&gt;ISA()-&gt;ISA()); cls-&gt;setSuperclass(superclass); meta-&gt;setSuperclass(superclass-&gt;ISA()); addSubclass(superclass, cls); addSubclass(superclass-&gt;ISA(), meta); } else { meta-&gt;initClassIsa(meta); cls-&gt;setSuperclass(Nil); meta-&gt;setSuperclass(cls); addRootClass(cls); addSubclass(cls, meta); } addClassTableEntry(cls);}/************************************************************************ verifySuperclass* Sanity-check the superclass provided to * objc_allocateClassPair, objc_initializeClassPair, or objc_readClassPair.**********************************************************************/boolverifySuperclass(Class superclass, bool rootOK){ if (!superclass) { // Superclass does not exist. // If subclass may be a root class, this is OK. // If subclass must not be a root class, this is bad. return rootOK; } // Superclass must be realized. if (! superclass-&gt;isRealized()) return false; // Superclass must not be under construction. if (superclass-&gt;data()-&gt;flags &amp; RW_CONSTRUCTING) return false; return true;}/************************************************************************ objc_initializeClassPair**********************************************************************/Class objc_initializeClassPair(Class superclass, const char *name, Class cls, Class meta){ // Fail if the class name is in use. if (look_up_class(name, NO, NO)) return nil; mutex_locker_t lock(runtimeLock); // Fail if the class name is in use. // Fail if the superclass isn't kosher. if (getClassExceptSomeSwift(name) || !verifySuperclass(superclass, true/*rootOK*/)) { return nil; } objc_initializeClassPair_internal(superclass, name, cls, meta); return cls;}/************************************************************************ objc_allocateClassPair* fixme* Locking: acquires runtimeLock**********************************************************************/Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes){ Class cls, meta; // Fail if the class name is in use. if (look_up_class(name, NO, NO)) return nil; mutex_locker_t lock(runtimeLock); // Fail if the class name is in use. // Fail if the superclass isn't kosher. if (getClassExceptSomeSwift(name) || !verifySuperclass(superclass, true/*rootOK*/)) { return nil; } // Allocate new classes. cls = alloc_class_for_subclass(superclass, extraBytes); meta = alloc_class_for_subclass(superclass, extraBytes); // fixme mangle the name if it looks swift-y? objc_initializeClassPair_internal(superclass, name, cls, meta); return cls;}/************************************************************************ objc_registerClassPair* fixme* Locking: acquires runtimeLock**********************************************************************/void objc_registerClassPair(Class cls){ mutex_locker_t lock(runtimeLock); checkIsKnownClass(cls); if ((cls-&gt;data()-&gt;flags &amp; RW_CONSTRUCTED) || (cls-&gt;ISA()-&gt;data()-&gt;flags &amp; RW_CONSTRUCTED)) { _objc_inform(&quot;objc_registerClassPair: class '%s' was already &quot; &quot;registered!&quot;, cls-&gt;data()-&gt;ro()-&gt;getName()); return; } if (!(cls-&gt;data()-&gt;flags &amp; RW_CONSTRUCTING) || !(cls-&gt;ISA()-&gt;data()-&gt;flags &amp; RW_CONSTRUCTING)) { _objc_inform(&quot;objc_registerClassPair: class '%s' was not &quot; &quot;allocated with objc_allocateClassPair!&quot;, cls-&gt;data()-&gt;ro()-&gt;getName()); return; } // Clear &quot;under construction&quot; bit, set &quot;done constructing&quot; bit cls-&gt;ISA()-&gt;changeInfo(RW_CONSTRUCTED, RW_CONSTRUCTING | RW_REALIZING); cls-&gt;changeInfo(RW_CONSTRUCTED, RW_CONSTRUCTING | RW_REALIZING); // Add to named class table. addNamedClass(cls, cls-&gt;data()-&gt;ro()-&gt;getName());}/************************************************************************ objc_readClassPair()* Read a class and metaclass as written by a compiler.* Assumes the class and metaclass are not referenced by other things * that might need to be fixed up (such as categories and subclasses).* Does not call +load.* Returns the class pointer, or nil.** Locking: runtimeLock acquired by map_images**********************************************************************/Class objc_readClassPair(Class bits, const struct objc_image_info *info){ mutex_locker_t lock(runtimeLock); // No info bits are significant yet. (void)info; // Fail if the superclass isn't kosher. bool rootOK = bits-&gt;data()-&gt;flags &amp; RO_ROOT; if (!verifySuperclass(bits-&gt;getSuperclass(), rootOK)){ return nil; } // Duplicate classes are allowed, just like they are for image loading. // readClass will complain about the duplicate. Class cls = readClass(bits, false/*bundle*/, false/*shared cache*/); if (cls != bits) { // This function isn't allowed to remap anything. _objc_fatal(&quot;objc_readClassPair for class %s changed %p to %p&quot;, cls-&gt;nameForLogging(), bits, cls); } // The only client of this function is old Swift. // Stable Swift won't use it. // fixme once Swift in the OS settles we can assert(!cls-&gt;isSwiftStable()). cls = realizeClassWithoutSwift(cls, nil); return cls;}/************************************************************************ detach_class* Disconnect a class from other data structures.* Exception: does not remove the class from the +load list* Call this before free_class.* Locking: runtimeLock must be held by the caller.**********************************************************************/static void detach_class(Class cls, bool isMeta){ runtimeLock.assertLocked(); // categories not yet attached to this class objc::unattachedCategories.eraseClass(cls); // superclass's subclass list if (cls-&gt;isRealized()) { Class supercls = cls-&gt;getSuperclass(); if (supercls) { removeSubclass(supercls, cls); } else { removeRootClass(cls); } } // class tables and +load queue if (!isMeta) { removeNamedClass(cls, cls-&gt;mangledName()); } objc::allocatedClasses.get().erase(cls);}/************************************************************************ free_class* Frees a class's data structures.* Call this after detach_class.* Locking: runtimeLock must be held by the caller**********************************************************************/static void free_class(Class cls){ runtimeLock.assertLocked(); if (! cls-&gt;isRealized()) return; auto rw = cls-&gt;data(); auto rwe = rw-&gt;ext(); auto ro = rw-&gt;ro(); cls-&gt;cache.destroy(); if (rwe) { for (auto&amp; meth : rwe-&gt;methods) { try_free(meth.types()); } rwe-&gt;methods.tryFree(); } const ivar_list_t *ivars = ro-&gt;ivars; if (ivars) { for (auto&amp; ivar : *ivars) { try_free(ivar.offset); try_free(ivar.name); try_free(ivar.type); } try_free(ivars); } if (rwe) { for (auto&amp; prop : rwe-&gt;properties) { try_free(prop.name); try_free(prop.attributes); } rwe-&gt;properties.tryFree(); rwe-&gt;protocols.tryFree(); } try_free(ro-&gt;getIvarLayout()); try_free(ro-&gt;weakIvarLayout); try_free(ro-&gt;getName()); try_free(ro); objc::zfree(rwe); objc::zfree(rw); try_free(cls);}void objc_disposeClassPair(Class cls){ mutex_locker_t lock(runtimeLock); checkIsKnownClass(cls); if (!(cls-&gt;data()-&gt;flags &amp; (RW_CONSTRUCTED|RW_CONSTRUCTING)) || !(cls-&gt;ISA()-&gt;data()-&gt;flags &amp; (RW_CONSTRUCTED|RW_CONSTRUCTING))) { // class not allocated with objc_allocateClassPair // disposing still-unregistered class is OK! _objc_inform(&quot;objc_disposeClassPair: class '%s' was not &quot; &quot;allocated with objc_allocateClassPair!&quot;, cls-&gt;data()-&gt;ro()-&gt;getName()); return; } if (cls-&gt;isMetaClass()) { _objc_inform(&quot;objc_disposeClassPair: class '%s' is a metaclass, &quot; &quot;not a class!&quot;, cls-&gt;data()-&gt;ro()-&gt;getName()); return; } // Shouldn't have any live subclasses. if (cls-&gt;data()-&gt;firstSubclass) { _objc_inform(&quot;objc_disposeClassPair: class '%s' still has subclasses, &quot; &quot;including '%s'!&quot;, cls-&gt;data()-&gt;ro()-&gt;getName(), cls-&gt;data()-&gt;firstSubclass-&gt;nameForLogging()); } if (cls-&gt;ISA()-&gt;data()-&gt;firstSubclass) { _objc_inform(&quot;objc_disposeClassPair: class '%s' still has subclasses, &quot; &quot;including '%s'!&quot;, cls-&gt;data()-&gt;ro()-&gt;getName(), cls-&gt;ISA()-&gt;data()-&gt;firstSubclass-&gt;nameForLogging()); } // don't remove_class_from_loadable_list() // - it's not there and we don't have the lock detach_class(cls-&gt;ISA(), YES); detach_class(cls, NO); free_class(cls-&gt;ISA()); free_class(cls);}/************************************************************************ objc_constructInstance* Creates an instance of `cls` at the location pointed to by `bytes`. * `bytes` must point to at least class_getInstanceSize(cls) bytes of * well-aligned zero-filled memory.* The new object's isa is set. Any C++ constructors are called.* Returns `bytes` if successful. Returns nil if `cls` or `bytes` is * nil, or if C++ constructors fail.* Note: class_createInstance() and class_createInstances() preflight this.**********************************************************************/id objc_constructInstance(Class cls, void *bytes){ if (!cls || !bytes) return nil; id obj = (id)bytes; // Read class's info bits all at once for performance bool hasCxxCtor = cls-&gt;hasCxxCtor(); bool hasCxxDtor = cls-&gt;hasCxxDtor(); bool fast = cls-&gt;canAllocNonpointer(); if (fast) { obj-&gt;initInstanceIsa(cls, hasCxxDtor); } else { obj-&gt;initIsa(cls); } if (hasCxxCtor) { return object_cxxConstructFromClass(obj, cls, OBJECT_CONSTRUCT_NONE); } else { return obj; }}/************************************************************************ class_createInstance* fixme* Locking: none** Note: this function has been carefully written so that the fastpath* takes no branch.**********************************************************************/static ALWAYS_INLINE id_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, int construct_flags = OBJECT_CONSTRUCT_NONE, bool cxxConstruct = true, size_t *outAllocatedSize = nil){ ASSERT(cls-&gt;isRealized()); // Read class's info bits all at once for performance bool hasCxxCtor = cxxConstruct &amp;&amp; cls-&gt;hasCxxCtor(); bool hasCxxDtor = cls-&gt;hasCxxDtor(); bool fast = cls-&gt;canAllocNonpointer(); size_t size; size = cls-&gt;instanceSize(extraBytes); if (outAllocatedSize) *outAllocatedSize = size; id obj; if (zone) { obj = (id)malloc_zone_calloc((malloc_zone_t *)zone, 1, size); } else { obj = (id)calloc(1, size); } if (slowpath(!obj)) { if (construct_flags &amp; OBJECT_CONSTRUCT_CALL_BADALLOC) { return _objc_callBadAllocHandler(cls); } return nil; } if (!zone &amp;&amp; fast) { obj-&gt;initInstanceIsa(cls, hasCxxDtor); } else { // Use raw pointer isa on the assumption that they might be // doing something weird with the zone or RR. obj-&gt;initIsa(cls); } if (fastpath(!hasCxxCtor)) { return obj; } construct_flags |= OBJECT_CONSTRUCT_FREE_ONFAILURE; return object_cxxConstructFromClass(obj, cls, construct_flags);}idclass_createInstance(Class cls, size_t extraBytes){ if (!cls) return nil; return _class_createInstanceFromZone(cls, extraBytes, nil);}NEVER_INLINEid_objc_rootAllocWithZone(Class cls, malloc_zone_t *zone __unused){ // allocWithZone under __OBJC2__ ignores the zone parameter return _class_createInstanceFromZone(cls, 0, nil, OBJECT_CONSTRUCT_CALL_BADALLOC);}/************************************************************************ class_createInstances* fixme* Locking: none**********************************************************************/#if SUPPORT_NONPOINTER_ISA#warning fixme optimize class_createInstances#endifunsigned class_createInstances(Class cls, size_t extraBytes, id *results, unsigned num_requested){ return _class_createInstancesFromZone(cls, extraBytes, nil, results, num_requested);}/************************************************************************ object_copyFromZone* fixme* Locking: none**********************************************************************/static id _object_copyFromZone(id oldObj, size_t extraBytes, void *zone){ if (oldObj-&gt;isTaggedPointerOrNil()) return oldObj; // fixme this doesn't handle C++ ivars correctly (#4619414) Class cls = oldObj-&gt;ISA(/*authenticated*/true); size_t size; id obj = _class_createInstanceFromZone(cls, extraBytes, zone, OBJECT_CONSTRUCT_NONE, false, &amp;size); if (!obj) return nil; // Copy everything except the isa, which was already set above. uint8_t *copyDst = (uint8_t *)obj + sizeof(Class); uint8_t *copySrc = (uint8_t *)oldObj + sizeof(Class); size_t copySize = size - sizeof(Class); memmove(copyDst, copySrc, copySize); fixupCopiedIvars(obj, oldObj); return obj;}/************************************************************************ object_copy* fixme* Locking: none**********************************************************************/id object_copy(id oldObj, size_t extraBytes){ return _object_copyFromZone(oldObj, extraBytes, malloc_default_zone());}#if SUPPORT_ZONES/************************************************************************ class_createInstanceFromZone* fixme* Locking: none**********************************************************************/idclass_createInstanceFromZone(Class cls, size_t extraBytes, void *zone){ if (!cls) return nil; return _class_createInstanceFromZone(cls, extraBytes, zone);}/************************************************************************ object_copyFromZone* fixme* Locking: none**********************************************************************/id object_copyFromZone(id oldObj, size_t extraBytes, void *zone){ return _object_copyFromZone(oldObj, extraBytes, zone);}#endif/************************************************************************ objc_destructInstance* Destroys an instance without freeing memory. * Calls C++ destructors.* Calls ARC ivar cleanup.* Removes associative references.* Returns `obj`. Does nothing if `obj` is nil.**********************************************************************/void *objc_destructInstance(id obj) { if (obj) { // Read all of the flags at once for performance. bool cxx = obj-&gt;hasCxxDtor(); bool assoc = obj-&gt;hasAssociatedObjects(); // This order is important. if (cxx) object_cxxDestruct(obj); if (assoc) _object_remove_assocations(obj, /*deallocating*/true); obj-&gt;clearDeallocating(); } return obj;}/************************************************************************ object_dispose* fixme* Locking: none**********************************************************************/id object_dispose(id obj){ if (!obj) return nil; objc_destructInstance(obj); free(obj); return nil;}/************************************************************************ _objc_getFreedObjectClass* fixme* Locking: none**********************************************************************/Class _objc_getFreedObjectClass (void){ return nil;}/************************************************************************ Tagged pointer objects.** Tagged pointer objects store the class and the object value in the * object pointer; the &quot;pointer&quot; does not actually point to anything.* * Tagged pointer objects currently use this representation:* (LSB)* 1 bit set if tagged, clear if ordinary object pointer* 3 bits tag index* 60 bits payload* (MSB)* The tag index defines the object's class. * The payload format is defined by the object's class.** If the tag index is 0b111, the tagged pointer object uses an * &quot;extended&quot; representation, allowing more classes but with smaller payloads:* (LSB)* 1 bit set if tagged, clear if ordinary object pointer* 3 bits 0b111* 8 bits extended tag index* 52 bits payload* (MSB)** Some architectures reverse the MSB and LSB in these representations.** This representation is subject to change. Representation-agnostic SPI is:* objc-internal.h for class implementers.* objc-gdb.h for debuggers.**********************************************************************/#if !SUPPORT_TAGGED_POINTERS// These variables are always provided for debuggers.uintptr_t objc_debug_taggedpointer_obfuscator = 0;uintptr_t objc_debug_taggedpointer_mask = 0;unsigned objc_debug_taggedpointer_slot_shift = 0;uintptr_t objc_debug_taggedpointer_slot_mask = 0;unsigned objc_debug_taggedpointer_payload_lshift = 0;unsigned objc_debug_taggedpointer_payload_rshift = 0;Class objc_debug_taggedpointer_classes[1] = { nil };uintptr_t objc_debug_taggedpointer_ext_mask = 0;unsigned objc_debug_taggedpointer_ext_slot_shift = 0;uintptr_t objc_debug_taggedpointer_ext_slot_mask = 0;unsigned objc_debug_taggedpointer_ext_payload_lshift = 0;unsigned objc_debug_taggedpointer_ext_payload_rshift = 0;Class objc_debug_taggedpointer_ext_classes[1] = { nil };uintptr_t objc_debug_constant_cfstring_tag_bits = 0;static voiddisableTaggedPointers() { }static voidinitializeTaggedPointerObfuscator(void) { }#else// The &quot;slot&quot; used in the class table and given to the debugger // includes the is-tagged bit. This makes objc_msgSend faster.// The &quot;ext&quot; representation doesn't do that.uintptr_t objc_debug_taggedpointer_obfuscator;uintptr_t objc_debug_taggedpointer_mask = _OBJC_TAG_MASK;unsigned objc_debug_taggedpointer_slot_shift = _OBJC_TAG_SLOT_SHIFT;uintptr_t objc_debug_taggedpointer_slot_mask = _OBJC_TAG_SLOT_MASK;unsigned objc_debug_taggedpointer_payload_lshift = _OBJC_TAG_PAYLOAD_LSHIFT;unsigned objc_debug_taggedpointer_payload_rshift = _OBJC_TAG_PAYLOAD_RSHIFT;// objc_debug_taggedpointer_classes is defined in objc-msg-*.suintptr_t objc_debug_taggedpointer_ext_mask = _OBJC_TAG_EXT_MASK;unsigned objc_debug_taggedpointer_ext_slot_shift = _OBJC_TAG_EXT_SLOT_SHIFT;uintptr_t objc_debug_taggedpointer_ext_slot_mask = _OBJC_TAG_EXT_SLOT_MASK;unsigned objc_debug_taggedpointer_ext_payload_lshift = _OBJC_TAG_EXT_PAYLOAD_LSHIFT;unsigned objc_debug_taggedpointer_ext_payload_rshift = _OBJC_TAG_EXT_PAYLOAD_RSHIFT;// objc_debug_taggedpointer_ext_classes is defined in objc-msg-*.s#if OBJC_SPLIT_TAGGED_POINTERSuint8_t objc_debug_tag60_permutations[8] = { 0, 1, 2, 3, 4, 5, 6, 7 };uintptr_t objc_debug_constant_cfstring_tag_bits = _OBJC_TAG_EXT_MASK | ((uintptr_t)(OBJC_TAG_Constant_CFString - OBJC_TAG_First52BitPayload) &lt;&lt; _OBJC_TAG_EXT_SLOT_SHIFT);#elseuintptr_t objc_debug_constant_cfstring_tag_bits = 0;#endifstatic voiddisableTaggedPointers(){ objc_debug_taggedpointer_mask = 0; objc_debug_taggedpointer_slot_shift = 0; objc_debug_taggedpointer_slot_mask = 0; objc_debug_taggedpointer_payload_lshift = 0; objc_debug_taggedpointer_payload_rshift = 0; objc_debug_taggedpointer_ext_mask = 0; objc_debug_taggedpointer_ext_slot_shift = 0; objc_debug_taggedpointer_ext_slot_mask = 0; objc_debug_taggedpointer_ext_payload_lshift = 0; objc_debug_taggedpointer_ext_payload_rshift = 0;}// Returns a pointer to the class's storage in the tagged class arrays.// Assumes the tag is a valid basic tag.static Class *classSlotForBasicTagIndex(objc_tag_index_t tag){#if OBJC_SPLIT_TAGGED_POINTERS uintptr_t obfuscatedTag = _objc_basicTagToObfuscatedTag(tag); return &amp;objc_tag_classes[obfuscatedTag];#else uintptr_t tagObfuscator = ((objc_debug_taggedpointer_obfuscator &gt;&gt; _OBJC_TAG_INDEX_SHIFT) &amp; _OBJC_TAG_INDEX_MASK); uintptr_t obfuscatedTag = tag ^ tagObfuscator; // Array index in objc_tag_classes includes the tagged bit itself# if SUPPORT_MSB_TAGGED_POINTERS return &amp;objc_tag_classes[0x8 | obfuscatedTag];# else return &amp;objc_tag_classes[(obfuscatedTag &lt;&lt; 1) | 1];# endif#endif}// Returns a pointer to the class's storage in the tagged class arrays, // or nil if the tag is out of range.static Class * classSlotForTagIndex(objc_tag_index_t tag){ if (tag &gt;= OBJC_TAG_First60BitPayload &amp;&amp; tag &lt;= OBJC_TAG_Last60BitPayload) { return classSlotForBasicTagIndex(tag); } if (tag &gt;= OBJC_TAG_First52BitPayload &amp;&amp; tag &lt;= OBJC_TAG_Last52BitPayload) { int index = tag - OBJC_TAG_First52BitPayload;#if OBJC_SPLIT_TAGGED_POINTERS if (tag &gt;= OBJC_TAG_FirstUnobfuscatedSplitTag) return &amp;objc_tag_ext_classes[index];#endif uintptr_t tagObfuscator = ((objc_debug_taggedpointer_obfuscator &gt;&gt; _OBJC_TAG_EXT_INDEX_SHIFT) &amp; _OBJC_TAG_EXT_INDEX_MASK); return &amp;objc_tag_ext_classes[index ^ tagObfuscator]; } return nil;}/************************************************************************ initializeTaggedPointerObfuscator* Initialize objc_debug_taggedpointer_obfuscator with randomness.** The tagged pointer obfuscator is intended to make it more difficult* for an attacker to construct a particular object as a tagged pointer,* in the presence of a buffer overflow or other write control over some* memory. The obfuscator is XORed with the tagged pointers when setting* or retrieving payload values. They are filled with randomness on first* use.**********************************************************************/static voidinitializeTaggedPointerObfuscator(void){// if (!DisableTaggedPointerObfuscation &amp;&amp; dyld_program_sdk_at_least(dyld_fall_2018_os_versions)) {// // Pull random data into the variable, then shift away all non-payload bits.// arc4random_buf(&amp;objc_debug_taggedpointer_obfuscator,// sizeof(objc_debug_taggedpointer_obfuscator));// objc_debug_taggedpointer_obfuscator &amp;= ~_OBJC_TAG_MASK;////#if OBJC_SPLIT_TAGGED_POINTERS// // The obfuscator doesn't apply to any of the extended tag mask or the no-obfuscation bit.// objc_debug_taggedpointer_obfuscator &amp;= ~(_OBJC_TAG_EXT_MASK | _OBJC_TAG_NO_OBFUSCATION_MASK);//// // Shuffle the first seven entries of the tag permutator.// int max = 7;// for (int i = max - 1; i &gt;= 0; i--) {// int target = arc4random_uniform(i + 1);// swap(objc_debug_tag60_permutations[i],// objc_debug_tag60_permutations[target]);// }//#endif// } else {// // Set the obfuscator to zero for apps linked against older SDKs,// // in case they're relying on the tagged pointer representation.// objc_debug_taggedpointer_obfuscator = 0;// }}/************************************************************************ _objc_registerTaggedPointerClass* Set the class to use for the given tagged pointer index.* Aborts if the tag is out of range, or if the tag is already * used by some other class.**********************************************************************/void_objc_registerTaggedPointerClass(objc_tag_index_t tag, Class cls){ if (objc_debug_taggedpointer_mask == 0) { _objc_fatal(&quot;tagged pointers are disabled&quot;); } Class *slot = classSlotForTagIndex(tag); if (!slot) { _objc_fatal(&quot;tag index %u is invalid&quot;, (unsigned int)tag); } Class oldCls = *slot; if (cls &amp;&amp; oldCls &amp;&amp; cls != oldCls) { _objc_fatal(&quot;tag index %u used for two different classes &quot; &quot;(was %p %s, now %p %s)&quot;, tag, oldCls, oldCls-&gt;nameForLogging(), cls, cls-&gt;nameForLogging()); } *slot = cls; // Store a placeholder class in the basic tag slot that is // reserved for the extended tag space, if it isn't set already. // Do this lazily when the first extended tag is registered so // that old debuggers characterize bogus pointers correctly more often. if (tag &lt; OBJC_TAG_First60BitPayload || tag &gt; OBJC_TAG_Last60BitPayload) { Class *extSlot = classSlotForBasicTagIndex(OBJC_TAG_RESERVED_7); if (*extSlot == nil) { extern objc_class OBJC_CLASS_$___NSUnrecognizedTaggedPointer; *extSlot = (Class)&amp;OBJC_CLASS_$___NSUnrecognizedTaggedPointer; } }}/************************************************************************ _objc_getClassForTag* Returns the class that is using the given tagged pointer tag.* Returns nil if no class is using that tag or the tag is out of range.**********************************************************************/Class_objc_getClassForTag(objc_tag_index_t tag){ Class *slot = classSlotForTagIndex(tag); if (slot) return *slot; else return nil;}#endif#if SUPPORT_FIXUPOBJC_EXTERN void objc_msgSend_fixup(void);OBJC_EXTERN void objc_msgSendSuper2_fixup(void);OBJC_EXTERN void objc_msgSend_stret_fixup(void);OBJC_EXTERN void objc_msgSendSuper2_stret_fixup(void);#if defined(__i386__) || defined(__x86_64__)OBJC_EXTERN void objc_msgSend_fpret_fixup(void);#endif#if defined(__x86_64__)OBJC_EXTERN void objc_msgSend_fp2ret_fixup(void);#endifOBJC_EXTERN void objc_msgSend_fixedup(void);OBJC_EXTERN void objc_msgSendSuper2_fixedup(void);OBJC_EXTERN void objc_msgSend_stret_fixedup(void);OBJC_EXTERN void objc_msgSendSuper2_stret_fixedup(void);#if defined(__i386__) || defined(__x86_64__)OBJC_EXTERN void objc_msgSend_fpret_fixedup(void);#endif#if defined(__x86_64__)OBJC_EXTERN void objc_msgSend_fp2ret_fixedup(void);#endif/************************************************************************ fixupMessageRef* Repairs an old vtable dispatch call site. * vtable dispatch itself is not supported.**********************************************************************/static void fixupMessageRef(message_ref_t *msg){ msg-&gt;sel = sel_registerName((const char *)msg-&gt;sel); if (msg-&gt;imp == &amp;objc_msgSend_fixup) { if (msg-&gt;sel == @selector(alloc)) { msg-&gt;imp = (IMP)&amp;objc_alloc; } else if (msg-&gt;sel == @selector(allocWithZone:)) { msg-&gt;imp = (IMP)&amp;objc_allocWithZone; } else if (msg-&gt;sel == @selector(retain)) { msg-&gt;imp = (IMP)&amp;objc_retain; } else if (msg-&gt;sel == @selector(release)) { msg-&gt;imp = (IMP)&amp;objc_release; } else if (msg-&gt;sel == @selector(autorelease)) { msg-&gt;imp = (IMP)&amp;objc_autorelease; } else { msg-&gt;imp = &amp;objc_msgSend_fixedup; } } else if (msg-&gt;imp == &amp;objc_msgSendSuper2_fixup) { msg-&gt;imp = &amp;objc_msgSendSuper2_fixedup; } else if (msg-&gt;imp == &amp;objc_msgSend_stret_fixup) { msg-&gt;imp = &amp;objc_msgSend_stret_fixedup; } else if (msg-&gt;imp == &amp;objc_msgSendSuper2_stret_fixup) { msg-&gt;imp = &amp;objc_msgSendSuper2_stret_fixedup; } #if defined(__i386__) || defined(__x86_64__) else if (msg-&gt;imp == &amp;objc_msgSend_fpret_fixup) { msg-&gt;imp = &amp;objc_msgSend_fpret_fixedup; } #endif#if defined(__x86_64__) else if (msg-&gt;imp == &amp;objc_msgSend_fp2ret_fixup) { msg-&gt;imp = &amp;objc_msgSend_fp2ret_fixedup; } #endif}// SUPPORT_FIXUP#endif// ProKit SPIstatic Class setSuperclass(Class cls, Class newSuper){ Class oldSuper; runtimeLock.assertLocked(); ASSERT(cls-&gt;isRealized()); ASSERT(newSuper-&gt;isRealized()); oldSuper = cls-&gt;getSuperclass(); removeSubclass(oldSuper, cls); removeSubclass(oldSuper-&gt;ISA(), cls-&gt;ISA()); cls-&gt;setSuperclass(newSuper); cls-&gt;ISA()-&gt;setSuperclass(newSuper-&gt;ISA(/*authenticated*/true)); addSubclass(newSuper, cls); addSubclass(newSuper-&gt;ISA(), cls-&gt;ISA()); // Flush subclass's method caches. flushCaches(cls, __func__, [](Class c){ return true; }); flushCaches(cls-&gt;ISA(), __func__, [](Class c){ return true; }); return oldSuper;}Class class_setSuperclass(Class cls, Class newSuper){ mutex_locker_t lock(runtimeLock); return setSuperclass(cls, newSuper);}void runtime_init(void){ objc::unattachedCategories.init(32); objc::allocatedClasses.init();}// __OBJC2__#endif","link":"/2021/10/19/ios-objc-runtime-new-yuan-ma/"}],"tags":[{"name":"转载","slug":"转载","link":"/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"原创","slug":"原创","link":"/tags/%E5%8E%9F%E5%88%9B/"}],"categories":[{"name":"iOS","slug":"iOS","link":"/categories/iOS/"},{"name":"Windows","slug":"Windows","link":"/categories/Windows/"},{"name":"macOS","slug":"macOS","link":"/categories/macOS/"}]}