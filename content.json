{"pages":[{"title":"404","text":"","link":"/404/index.html"},{"title":"about","text":"","link":"/about/index.html"},{"title":"friends","text":"","link":"/friends/index.html"},{"title":"contact","text":"","link":"/contact/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"CentOS7.2配置LNMP环境记录","text":"CentOS7.2配置LNMP环境记录1php 7.0+ nginx 1.10+ mysql 5.5+ LNMP是Linux、Nginx、MySQL(MariaDB)和PHP的缩写，这个组合是最常见的WEB服务器的运行环境之一。本文将带领大家在CentOS 7操作系统上搭建一套LNMP环境。 本教程适用于CentOS 7.x版本。 准备工作更新 yum 源,自带的源没有 PHP7:1rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm 1rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm 安装 epel:1yum install epel-release 升级系统1yum update 准备工作完成,开始安装! 安装NginxCentOS系统模板中配置了内网源，下载速度较快，推荐使用yum安装Nginx： 1sudo yum install nginx 按照提示，输入yes后开始安装。安装完毕后，Nginx的配置文件在/etc/nginx目录下。使用以下命令启动Nginx： 1sudo systemctl start nginx 检查系统中firewalld防火墙服务是否开启，如果已开启，我们需要修改防火墙配置，开启Nginx外网端口访问。 1sudo systemctl status firewalld 如果显示**active (running)**，则需要调整防火墙规则的配置。 修改/etc/firewalld/zones/public.xml文件，在zone一节中增加： 1234&lt;zone&gt; ... &lt;service name=&quot;nginx&quot;/&gt;&lt;zone&gt; 保存后重新加载firewalld服务： 1sudo systemctl restart firewalld 您可以通过浏览器访问 http://外网IP地址 来确定Nginx是否已经启动。 【注意：很重要！！！】部分童鞋发现按照教程操作最后无法访问，这是云服务器默认关闭了80端口。这个请移步云服务里控制台打开80端口的外网访问，如需步骤，请自行百度！ 最后将Nginx设置为开机启动： 1sudo systemctl enable nginx.service 这么Nginx就安装成功了！ 安装MySQL(MariaDB)MariaDB是MySQL的一个分支，主要由开源社区进行维护和升级，而MySQL被Oracle收购以后，发展较慢。在CentOS 7的软件仓库中，将MySQL更替为了MariaDB。 我们可以使用yum直接安装MariaDB： 1sudo yum install mariadb-server 安装完成之后，执行以下命令重启MariaDB服务： 1sudo systemctl restart mariadb MariaDB默认root密码为空，我们需要设置一下，执行脚本： 1sudo /usr/bin/mysql_secure_installation 这个脚本会经过一些列的交互问答来进行MariaDB的安全设置。 首先提示输入当前的root密码： Enter current password for root (enter for none): 初始root密码为空，我们直接敲回车进行下一步。* Set root password? [Y/n] 设置root密码，默认选项为Yes，我们直接回车，提示输入密码，在这里设置您的MariaDB的root账户密码。* Remove anonymous users? [Y/n] 是否移除匿名用户，默认选项为Yes，建议按默认设置，回车继续。 Disallow root login remotely? [Y/n] 是否禁止root用户远程登录？如果您只在本机内访问MariaDB，建议按默认设置，回车继续。 如果您还有其他云主机需要使用root账号访问该数据库，则需要选择n。* Remove test database and access to it? [Y/n] 是否删除测试用的数据库和权限？建议按照默认设置，回车继续。 Reload privilege tables now? [Y/n] 是否重新加载权限表？因为我们上面更新了root的密码，这里需要重新加载，回车。* 完成后你会看到Success!的提示，MariaDB的安全设置已经完成。我们可以使用以下命令登录MariaDB： 1mysql -uroot -p 按提示输入root密码，就会进入MariaDB的交互界面，说明已经安装成功。 最后我们将MariaDB设置为开机启动。 1sudo systemctl enable mariadb php70w 安装PHP我们可以直接使用yum安装PHP： 123sudo yum install php70w-fpm php70w-mysql php70w-mysqli php70w php70w-opcache php70w-gd php70w-intl php70w-mbstring php70w-exif php70w-mcrypt php70w-openssl//把该安装的一次性装到位 安装完成后我们将php-fpm启动： 1sudo systemctl start php-fpm 将php-fpm设置为开机启动： 1sudo systemctl enable php-fpm 接下来需要注意了！配置Nginx–多个站点我给大家提供一个范本作为参考： 12nginx.conf//里面我会详细的给予中文注释 12vi /etc/nginx/nginx.conf//编辑nginx.conf的命令 以下为conf文件内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104# For more information on configuration, see:# * Official English Documentation: http://nginx.org/en/docs/# * Official Russian Documentation: http://nginx.org/ru/docs/user nginx;worker_processes auto;error_log /var/log/nginx/error.log; #错误日志记录的位置pid /run/nginx.pid; #nginx.pid为记录nginx主进程pid文件；切勿修改、移动# Load dynamic modules. See /usr/share/nginx/README.dynamic.include /usr/share/nginx/modules/*.conf;#引入/usr/share/nginx/modules/ 目录下的所有以.conf结尾的文件events { worker_connections 1024;}http { log_format main '$remote_addr - $remote_user [$time_local] &quot;$request&quot; ' '$status $body_bytes_sent &quot;$http_referer&quot; ' '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;'; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; # Load modular configuration files from the /etc/nginx/conf.d directory. # See http://nginx.org/en/docs/ngx_core_module.html#include # for more information. include /etc/nginx/conf.d/*.conf; #这句很重要，引入所有etc/nginx/conf.d/目录下的.conf文件 #***etc/nginx/conf.d/目录存放的就是分站点的文件（下面会给出实例代码）*** server { #由于我们的nginx需要配置多站点，所以在此就需要注释一些东西 listen 80 default_server; listen [::]:80 default_server; #保留监听的端口 # server_name _; # root /usr/share/nginx/php; # Load configuration files for the default server block. # include /etc/nginx/default.d/*.conf; # location / { # } # error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } # location ~ \\.php$ { # root /usr/share/php; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; # include fastcgi_params; # } }# Settings for a TLS enabled server.## server {# listen 443 ssl http2 default_server;# listen [::]:443 ssl http2 default_server;# server_name _;# root /usr/share/nginx/html;## ssl_certificate &quot;/etc/pki/nginx/server.crt&quot;;# ssl_certificate_key &quot;/etc/pki/nginx/private/server.key&quot;;# ssl_session_cache shared:SSL:1m;# ssl_session_timeout 10m;# ssl_ciphers HIGH:!aNULL:!MD5;# ssl_prefer_server_ciphers on;## # Load configuration files for the default server block.# include /etc/nginx/default.d/*.conf;## location / {# }## error_page 404 /404.html;# location = /40x.html {# }## error_page 500 502 503 504 /50x.html;# location = /50x.html {# }# }}#注意：此份nginx.conf可以直接复制了去使用！~好用了就给博主打个赏钱！谢谢！ 配置完nginx之后我们该干啥、？当然是重启nginx呗 1sudo systemctl restart nginx #重启nginx 重启完毕，继续打开 http://外网IP地址 来确定Nginx是否已经启动。 此时，服务器启动的是nginx和apache。 而且php-fpm默认发送到apache。 所以咱们还得继续修改一下php-fpm。 配置 php-fpm123vi /etc/php-fpm.d/www.conf #编辑php-fpm配置文件 修改user和group （源代码为：user = apache group = apache） 12user = nginx group = nginx 修改完了之后，还是老样子，重启php-fpm服务 12systemctl restart php-fpm #重启php-fpm 最后，咱们需要为nginx添加站点了添加站点这我先给大家一个截图，以帮助大家迅速的了解是怎么回事 大家应该看的很清楚了，猜都可以猜到，博主这一共配置了三个站点，这三个站点是怎么被nginx引入的呢？ 1我给大家贴出nginx的配置文件的里面应该有这么一句(注意图中的红框，上面的是地址) 123include /etc/nginx/conf.d/*.conf;#这句很重要，引入所有etc/nginx/conf.d/目录下的.conf文件#***etc/nginx/conf.d/目录存放的就是分站点的文件（下面会给出实例代码）*** 好的，大家应该能准确理解了，如果还是理解不了的话只能缺你回去喝点三鹿了！ 下面我给大家贴出nginx站点配置文件的代码，修改修改就可以用看代码的时候请注意看里面的路径，当然我也还是会给一定的中文注释 123456789101112131415161718#这个文件是上面的qopmall.com.confserver { server_name qopmall.com www.qopmall.com;#这里就是你要绑定的域名了，空格分开 location / { root /usr/share/php/weixin; #这里是你站点存放的文件夹名称（也就是说，你当前这个站点的文件全部都丢在这个路径的weixin文件夹里面） index index.php index.html index.htm; #这里照抄即可 } # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # location ~ \\.php$ { root /usr/share/php/weixin; #这里的配置等同于上面的那个root配置 fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /usr/share/php/weixin/$fastcgi_script_name; #这里的配置也是和上面的root配置一样 include fastcgi_params; }} 代码非常简单，我没注释到的不用修改就行。 上面的路径，比如/usr/share/php/weixin 这就是你站点的根目录，我给大家截图参考： 各位童鞋，创建好站点了，先写个简单的php程序测试一下是否正常，比如info。 完","link":"/2017/12/31/centos7-pei-zhi-lnmp-huan-jing-ji-lu/"},{"title":"Centos7配置yum源","text":"Centos7配置yum源我们安装完成CentOS系统，默认都是系统自带的yum源，因为你懂得原因会导致国内用户用yum安装软件的时候比较慢，为了提高效率，一般我们会配置国内的yum源。 目前国内比较好的yum源有网易yum源、搜狐yum源等，现在介绍下怎么配置网易163yum源： 1、首先备份/etc/yum.repos.d/CentOS-Base.repo(不一定是这个名称 你可以看一下 具体叫啥) 1mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 2、根据CentOS不同版本选择下载对应的repo文件，放到/etc/yum.repos.d/ 目录首先进入yum.repos.d目录12cd /etc/yum.repos.d/ CentOS 5.x12wget http://mirrors.163.com/.help/CentOS5-Base-163.repo CentOS 6.x12wget http://mirrors.163.com/.help/CentOS6-Base-163.repo CentOS 7.x12wget http://mirrors.163.com/.help/CentOS7-Base-163.repo 3、最后，执行yum makecache生成缓存清除缓存1yum clean all 生成新缓存1yum makecache OK, 简单3步操作即可配置完成。","link":"/2018/01/12/centos7-pei-zhi-yum-yuan/"},{"title":"台式组装机简单故障的排查与清除","text":"台式组装机简单故障的排查与清除本文主要讲述台式机部分简单故障的排查与清除。 故障一：不能正常开机此故障在电脑使用中最为常见，原因也是五花八门，下面我给大家梳理一些常见的故障以及清除方法： 电脑开机，反复重启这种问题十有八九就是**内存**的问题，下图就是内存：目前主流内存有DDR3和DDR4 如果有空闲的内存插槽，请尝试调整内存安装位置；如不能解决下一条。 如果无法调整位置，请尝试使用橡皮擦蘸酒精擦拭内存金手指位置；如不能解决下一条。 如果无法调整位置，请尝试交换内存安装位置；如不能解决下一条。 如果无法调整位置，请尝试选择拆卸内存，然后每装一根开机一次看看问题是否得到解决，如果确定问题内存建议联系卖家；如不能解决下一条。 实在无法解决请更换内存； 此问题目前我多见于威刚内存 电脑开机主机启动正常，但显示器无反应 这种问题可能是内存的问题，也可能是**显卡问题，下图就是显卡：目前主流显卡很多，AMD的 RX 400、RX 500系列，Nvidia**的 GTX 9 、GTX 10系列； 如果是NVIDIA的10系显卡，请不要使用不带芯片的VGA转接头，尽量使用HDMI线连接显示器； 按照上个故障来排查；如不能解决下一条。 使用核显，将独立显卡从主板中拆除，将原先插在独立显卡上的视频线接到主板上，如果无相应插头建议自行寻找转换接口，如能正常开机则问题出在显卡上，建议联系卖家； 电脑开机自动进入**BIOS**这种问题基本就是电脑的启动项设置不对造成的。 进入电脑主板BIOS，进入启动设置：（没错的话叫 BOOT），选择自己系统所在的硬盘作为首选启动项，保存并退出。如不能解决下一条。 如出系统盘外还有其他硬盘请拆除后开机，看看是否正常。 电脑开机显示下面几张图：CPU Fan Error请尝试检查CPU散热风扇的接线柱，是否正确安装到了CPU_FAN位置，CPU_OPT安装的应该是副风扇（一体水冷的时候基本是水泵） Please enter Setup to recover BIOS setting这个问题基本出现在上了年纪的电脑上，也就是是两年以上的电脑，原因就是主板电池没电了，造成了主板的设置不能正常保存，去附近的电脑店里面一个就OK了，5块钱吧。 故障二：无法上网网络标志显示红叉或者根本没有网络标志这种问题基本就是**网卡**没有启动导致的可能的原因就是驱动没装好 去下载主板网卡在当前系统版本下的驱动，系统版本有32位（X86）和64位（X64）之分，请看清楚 能用部分聊天软件，就是不能打开网页基本**DNS的问题没的跑了,需要修改IP地址** 修改本机当前ip配置。如何修改这个就要看系统版本了，不一样的版本入口不一样 对于win7可以点击小电脑图标-&gt;打开网络与共享设置-&gt;然后左侧边栏更改适配器设置-&gt;找到目前在用的链接(本地连接或者是无线网络)-&gt;右键属性-&gt;选择ipV4-&gt;属性-&gt;勾选手动设置 其他的例如win8 win8.1，win10 基本都一样，如果找不到那么就去搜索控制面板，然后进入网络与Internet 进入网络与共享中心 进入网络适配器页面 进入连接属性 进入ipv4协议属性 手动填写IP地址 这里面的东西如何填写需要根据你的路由器来决定的，基本上家里的设置都是192.168.1.* (* 号填写100-254) 子网掩码 基本都是255.255.255.0 网关也是根据路由器来 192.168.1.1 DNS 第一行也可以根据路由器来：192.168.1.1 或者 指定固定的DNS，比如114.114.114.114 第二行随意 保存 如果上述方法不能解决建议重置网络服务 重置网络服务* 进入命令行工具（管理员模式）* 输入 netsh winsock reset 然后回车* 完成之后重启","link":"/2018/01/10/computer-normal-problem-check-and-fix/"},{"title":"Computer--U盘引导盘制作工具集合","text":"写作目的为了向电脑小白科普目前，使用人数较多的PE引导盘的制作工具软件，这玩意的用处真的是很大很大了。 千万不要说PE只能重装系统。 新硬盘无操作系统无分区，需要PE。 系统忘记登录密码不想重装，需要PE。 系统崩溃还有资料在桌面或者C盘，需要PE。 全盘数据恢复，需要PE。 重建主引导记录（MBR），重建分区表（修复分区表）、修复Windows系统引导，需要PE。 这么有用的东西到底有多少呢，我也不是很清楚，看看下面就知道了。（排名不分先后，想到哪个写哪个） 电脑店这个是我第一次用的制作工具，不知道怎么就给找到了。使用电脑店制作U盘PE系统比较的简单，基本上一键即可轻松制作，支持多种启动模式选择，支持个性化设置，别小看这个个性化设置，里边还隐藏着一些奥妙，为了测试的需要，我们采用默认设置进行PE系统的制作。 电脑店U盘启动盘制作工具，也是常称为的U盘启动制作工具的功能升格版，能更方便电脑技术人员装机、维护电脑使用的超强工具。此作品制作简单，支持所有U盘一键制作成启动盘；兼容多种机型；支持GHO、ISO系统文件，更支持原版系统安装，集成更全面工具，完全可以应对电脑技术人员常见的电脑故障维护工作。 主页：电脑店 - - &gt; http://u.diannaodian.com/ U深度这个是我比较喜欢里面的傲梅分区助手 主页：U深度 - - &gt; http://www.ushendu.info/ 大白菜基本和电脑店差不多，大白菜制作U盘PE系统同样简单，还是一键即可搞定，也支持多种启动模式选择，支持个性化设置，个性化设置里同样隐藏着一些东西，可以自己去研究。 老牌经典PE之一，同时集成服务器版的server 2003和win8PE，支持BIOS/UEFI双启，对古董机器兼容非常好。内置工具比微PE多。集成一键装机，硬盘数据恢复，密码破解，等等实用的程序。 但是个人觉得部分工具重复，工具版本偏老旧、且略为臃肿。另！大白菜PE制作时要事先取消360赞助，否则安装系统后将装上360，不介意用户请忽略。 我觉得大白菜亮点是支持读写苹果分区格式（注意是读写，不是读取！），非常适合黑苹果用户。我也是个黑苹果用户。 主页：大白菜 - - &gt; http://www.dabaicaipe.cn/dbcpe/ 老毛桃基本和电脑店差不多 主页：老毛桃 - - &gt; http://www.laomaotao.org/","link":"/2018/04/05/computer-pe-boot-usb-disk-tools-set/"},{"title":"Cocoapods的安装","text":"重新配置gem源替换1gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/ 查看1gem sources -l 请确保只有一个gem源—“https://gems.ruby-china.org/” 123*** CURRENT SOURCES ***https://gems.ruby-china.org/","link":"/2017/07/14/mac-cocoapods-de-an-zhuang/"},{"title":"制作Mac引导盘","text":"如何制作Mac引导盘制作mac的引导盘方法不止这一种，请严格按照要求来操作，出毛病我是不负责的哦。 准备工作 8GB U盘一个（这个是容量下限，最低8GB，最好是USB3.0或者以上） 一个正常使用的macOS 下载原版系统 (已下载可以忽略) 打开AppStore 看AppStore窗口右侧 macOS ······ 点击 下载 等（这个看网速的） 制作引导盘【注意】每个输入都和之前的一句隔着一个 空格 打开终端（terminal） 输入 “sudo” 1sudo 打开Finder（新版系统叫访达） 进入应用程序 点击刚刚下载的系统 右键–显示包内容 找到路径**”Contents/Resources/createinstallmedia”**，直接拖至终端,然后代码应该是下面这种 123sudo /Applications/Install\\ macOS\\ High\\ Sierra.app/Contents/Resources/createinstallmedia 注意 sudo 后有 空格 接着输入以下代码 12--volume 语句现在是这样的 123sudo /Applications/Install\\ macOS\\ High\\ Sierra.app/Contents/Resources/createinstallmedia --volume 然后输入你的U盘盘符 123/Volumes/macOS 语句现在是这样的 123sudo /Applications/Install\\ macOS\\ High\\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/macOS 下一步 123--applicationpath 语句现在是这样的 123sudo /Applications/Install\\ macOS\\ High\\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/macOS --applicationpath 下一步 直接把应用程序内的“安装macOS High Sierra.app”拖进终端 语句现在是这样的 123sudo /Applications/Install\\ macOS\\ High\\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/macOS --applicationpath /Applications/Install\\ macOS\\ High\\ Sierra.app 下一步 123--nointeraction 语句现在是这样的 123sudo /Applications/Install\\ macOS\\ High\\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/macOS --applicationpath /Applications/Install\\ macOS\\ High\\ Sierra.app --nointeraction 回车 （提示输入密码） 123Password: 输入管理员密码 回车 正在格式化磁盘 123Erasing Disk: 0%... 10%... 20%... 30%...100%... 正在拷贝安装器文件 123Copying installer files to disk... 这个时候你就可以看到你的U盘名称变了，而且里面多了一个系统，不过这个时候并没有完成 大概需要等待5-10分钟，这个时间长短主要取决于你U盘的写入速率 当显示下面信息是就代表制作完成 1234567Copy complete.Making disk bootable...Copying boot files...Copy complete.Done.","link":"/2018/04/07/mac-make-boot-usb-disk-for-mac/"},{"title":"Mac--苹果笔记本安装Win","text":"Mac–苹果笔记本安装Win(价值200块)为什么说是价值200块呢？ 是因为你拿着你的mac去任何一个电脑店让老板给您装Windows系统，应该会找你要200。 另外本文主要讲述的Windows系统为最新版的Win10 1709版本。 1、因为他们都觉得买得起mac的不差这200块钱。 2、还有一个原因就是因为mac贵，所以我提供的服务也贵。 3、以上两条都是为了坑点钱，其实给mac装Win系统很简单。 比我给windows装mac简单多了。 首先下载一个Windows的ISO镜像文件如果不会参看如何下载Windows系统 使用bootcamp把系统写入到U盘 请注意，下载好的系统最好放在mac上 这里你需要一个最小8GB的U盘，里面要是空的，因为要格式化，有数据的注意备份。 然后插U盘到MAC上。 打开bootcamp(新版系统叫 启动转换助理 ) 继续 勾选三个钩（win7第一个可以不钩） 继续 选择你刚才下载好的ISO系统文件 继续 等 分区，大小可以用鼠标挪动 重启就开始安装了 安装Windows具体步骤参看【UEFI引导安装Win10】 注意 选择安装盘的这一步具体操作如下： 选择带有bootcamp的分区，应该是第三个 或者 第四个（选择完成之后下方会有警告提示：不能安装到当前分区。。。。。。） 然后点击下方格式化（请确认上一步硬盘是否选错） 格式化之后，第一步的警告提示就应该消失了 下一步 其他步骤基本无异 再次重启进入Windows之后，打开U盘中的bootcamp.exe安装上去。这个文件是苹果电脑的驱动支持软件，不装的话估计你连网都没有哦。 是不是很简单完！","link":"/2018/03/11/mac-ping-guo-bi-ji-ben-an-zhuang-win/"},{"title":"多站点配置SSH-Key","text":"多站点配置SSH-Key相信很多用mac在开发的同学都会遇见一个问题：会根据业务不同往不同的git服务器上提交代码。这些库有私有的有公有的，这时候就需要配置SSH_Key了。 生成SSH-Key打开终端 （terminal） gitee(码云) · 秘钥对使用以下命令生成gitee的秘钥对【注意】emailaddress 填写自己的邮件地址 1ssh-keygen -t rsa -C &quot;emailaddress&quot; -f ~/.ssh/gitee_id_rsa github · 秘钥对使用以下命令生成github的秘钥对【注意】emailaddress 填写自己的邮件地址 1ssh-keygen -t rsa -C &quot;emailaddress&quot; -f ~/.ssh/github_id_rsa 添加私钥这个步骤是把私钥添加到当前设备，本地的不需要网络 添加 gitee 私钥 1ssh-add ~/.ssh/gitee_id_rsa 添加 github 私钥 1ssh-add ~/.ssh/github_id_rsa 添加公钥 和私钥不一样的是公钥是添加到git服务器的，所以这操作主要是在网页上进行的 添加 gitee 公钥显示出gitee的公钥 1cat ~/.ssh/gitee_id_rsa.pub 将展示出的以ssh-rsa开头，然后以刚才你输入的emailaddress结尾的内容全部复制 添加至gitee的SSHKey公钥 添加 github 公钥显示出github的公钥 1cat ~/.ssh/github_id_rsa.pub 将展示出的以ssh-rsa开头，然后以刚才你输入的emailaddress结尾的内容全部复制 添加至github的SSHKey公钥 创建Config在 ~/.ssh/目录下创建一个配置文件，来为秘钥使用做配置 1cd ~/.ssh/ 使用vim命令进行config文件的创建和编辑 1vim config 然后文件写入以下内容 添加以下内容1234567891011# giteeHost gitee.com HostName gitee.com PreferredAuthentications publickey IdentityFile ~/.ssh/gitee_id_rsa# githubHost github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/github_id_rsa 然后配对秘钥主要测试当前秘钥是否可用 配对gitee秘钥1ssh -T git@gitee.com gitee的测试会让输入 yes 连接gitee成功之后会显示以下信息 Welcome to Gitee.com, yourName! 配对github秘钥1ssh -T git@github.com 连接github成功之后会显示以下信息 Hi yourName! You’ve successfully authenticated, but GitHub does not provide shell access.","link":"/2018/03/14/multwwwconfigssh-key/"},{"title":"解除百度网盘下载限速","text":"众所周知的百度网盘为了迫使用户花钱，对用户的下载速度做出了限制。今天我就来分享一个破解限制的好办法，这个也是网上扒来的。 准备工作1、下载相关资料，也就是两个文件：http://pan.baidu.com/s/1nuPgpNN 2、安装chrome浏览器 3、安装下载的Aria2GUI 1.3.7.dmg 4、安装chrome插件BaiduExporter.zip 解压这个zip文件，然后打开chrome， 使用1、打开刚刚安装的Aria2GUI客户端 2、在chrome里面打开百度云网页,插件安装成功网页上就会多出一个“导出下载”的按钮 3、找到你要下载的文件，并且勾选文件（这里最好先把文件存入自己的网盘目录）,然后点击ARIA2 RPC下载任务就会被客户端执行 4、看一下速度 ATTENSION！！！本项目是MAC OS专用的，windows的目前不清楚安装chrome插件之后,插件原文件就不能移动位置,更不能删除,否则插件就会失效.","link":"/2017/08/09/release-baidunetdisk-downloading-speed-limit/"},{"title":"如何下载Windows系统","text":"本文主要讲述如何下载原版系统，所谓的原版系统就是微软服务器上的系统镜像，而不是国内各大论坛的GHOST版本，个人并不推荐GHOST以及其他任何第三方封装过的系统。以下载win10 1511中文简体64位为例子 第1步 进入MSDN 网址为http://msdn.itellyou.cn/ 第2步 选择操作系统 第3步 选择你需要的系统版本 windows 10，Version 1511 中文-简体 64位 （X64） 第4步 复制ed2k链接 第5步 打开下载工具，新建一个下载任务，链接就是用刚才复制的链接 下载中最好不要暂停 下载完了之后记得验证SHA1值","link":"/2018/04/01/windows-download-windows-image/"},{"title":"Windows--如何修改IP地址","text":"Windows–如何修改IP地址本文主要讲述windows 7如何修改电脑的**IP地址**。其他的例如win8 win8.1，win10 基本都一样，如果找不到那么就去搜索控制面板，然后进入网络与Internet 进入网络与共享中心 进入网络适配器页面 进入连接属性 进入ipv4协议属性 手动填写IP地址 这里面的东西如何填写需要根据你的路由器来决定的，基本上家里的设置都是192.168.1.* (* 号填写100-254) 子网掩码 基本都是255.255.255.0 网关也是根据路由器来 192.168.1.1 DNS 第一行也可以根据路由器来：192.168.1.1 或者 指定固定的DNS，比如114.114.114.114 第二行随意 保存","link":"/2018/01/11/windows-how-to-change-ip-address/"},{"title":"Windows--验证SHA1 MD5值","text":"日常使用电脑过程中，难免会下载很多文件，比如游戏，软件等等，很多人在下载一个耗时长而又速度不稳定的文件之后，都可能遇见打开文件的时候显示文件被损坏的情况，这时候我们就需要在下载完成之后对文件就行数据完整性校验了。 举个例子，以验证系统的记事本程序的Hash值为例，程序文件的路径为C:\\Windows\\notepad.exe。如果我们想要校验它的MD5值，Win7 可运行： MD5 1certutil -hashfile C:\\Windows\\notepad.exe MD5 SHA1 1certutil -hashfile C:\\Windows\\notepad.exe SHA1 SHA256 1certutil -hashfile C:\\Windows\\notepad.exe SHA256 上面MD5 SHA1 SHA256请不要小写，除了文件路径，其他的要和上面一模一样 Win10 可运行如下命令： Get-FileHash C:\\Windows\\notepad.exe -Algorithm MD5| Format-List 如果想要校验它的SHA1值，则运行如下命令： Get-FileHash C:\\Windows\\notepad.exe -Algorithm SHA1| Format-List 如果想要校验SHA256值，则不需要带-Algorithm参数即可，命令如下： Get-FileHash C:\\Windows\\notepad.exe | Format-List 上面这个文件的路径是可以直接由鼠标拖进去的","link":"/2018/04/01/windows-how-to-verify-the-sha1-md5-value/"},{"title":"Windows电脑U盘启动盘制作","text":"写在前面本文是博主鉴于当前任然后很大一部分电脑玩家经常为不会给爱机装系统而创作，本博主是一个精通电脑硬件性能以及软件使用的IT人士。 Windows的启动盘分为两类:(随便选择一种方法制作就OK了) 普通BIOS启动的PE类 UEFI启动的EFI类 无论是哪一类大家都不用担心，都有相对应的傻瓜式软件来帮我们完成，我们需要做的就是一下： 找一个U盘，最好是空的（因为无论是哪一种制作方式都可能会格式化这个U盘） U盘的大小最好是8GB左右的（第一种的方式大小无所谓，主要是第二种的方式会占用大量空间） 一台能联网的电脑（这个么有难度吧） 普通BIOS启动的PE类以下将简单介绍如何给Windows电脑制作一个普通BIOS启动的PE类U盘启动盘 准备工作下载U盘启动盘制作工具可以选的种类有很多个：老毛桃，U深度，大白菜，电脑店。。。。下面介绍的是电脑店。 下载地址：http://u.diannaodian.com/down 进入如图页面： 点击下载： 推荐点击本地下载： 然后就是等待下载完毕。。。。。。 在这个时候我们就可以开始对U盘做一些操作了(如果你的U盘不是空的话，如果里面没有东西，这一步可以跳过)，把U盘里面的所有东西都挪到电脑上（除了C盘的任何位置，只要你找的到就行）。 OK下载完了，开始安装：这个软件的安装很简单，就是单纯的吧这个下载的ZIP文件解压而已：我解压到了我的软件盘，盘符为D，如下图： 然后就是插上U盘，这时软件上面的U盘选择项就会出现你的U盘名称： 然后选择启动模式：（个人建议不要动保持USB-HDD模式） 然后选择U盘格式：（个人建议NTFS，因为Fat32有着文件大小的限制，单个文件的大小不得超过4GB） 都选择完了之后，那就点一下鼠标，点击全新制作：接下来就是等了。。。等。。。应该会很快完成之后：点击模拟启动，选择BIOS 至此，U盘启动盘已经制作完成。 UEFI启动的EFI类准备工作下载软碟通 百度就有： 安装： 接受协议，下一步。。。 注意改一下安装路径：（建议不要装在C盘，我的是在D盘） 一直下一步，知道结束 启动 选择继续试用： 选择上方工具栏的文件–打开：（选择你的系统镜像） 然后如图： 选择工具–写入磁盘镜像，插入U盘 点击写入：（没有合适的U盘 所以我这里是不能点的） 注意本类U盘启动盘只能以UEFI模式启动 请设置自己电脑的相关BIOS设置","link":"/2017/08/19/windows-make-pe-boot-usb-disk/"},{"title":"如何将硬盘分区表转换为GUID(GPT)分区表","text":"如何将硬盘分区表转换为GUID(GPT)分区表如果不知道自己的硬盘分区表类型可以参看 Windows–如何查看硬盘分区表类型 1、使用PE 制作U盘PE启动盘 进入PE 在PE里打开磁盘精灵 （DG） 右键磁盘 菜单中有转换为GUID分区表 2、在安装Win的时候 制作UEFI启动盘 进入UEFI安装的界面 shift + F10 （打开终端） 输入diskpart 回车 （进入diskpart） list disk (显示磁盘列表，注意这里你只能用大小来区分你的硬盘了) sel disk 0 (这个编号你自己看着你的来) clean （清除数据）（可选） convert gpt (转换为GPT分区表，好像是会清除磁盘上数据的) 同理，GPT转换至MBR上述方法同样适用","link":"/2018/02/26/windows-the-hard-disk-partition-table-type-changge-to-guid-gpt/"},{"title":"Windows--UEFI引导安装Win10","text":"Windows–UEFI引导安装Win10本文主要讲述如何使用普通U盘UEFI引导启动盘安装Windows系统 注意此方法只能安装于**GPT(GUID)**分区表的硬盘 准备工作 找一个8GB或更大的U盘 USB3.0更好 这样更快 下载官方ISO系统文件镜像（随便找一个不是C盘的目录放着就行，建议直接扔在D盘根目录） 然后新建一个文件夹叫 WindowsImage 解压这个ISO文件到 WindowsImage文件夹 首先制作UEFI启动盘 U盘格式化为Fat32文件系统（有些主板也支持NTFS，比如我的华硕Z170AR） 将解压好的 WindowsImage文件夹下面的所有文件放入U盘跟目录 注意现在的U盘打开之后应该有好几个文件夹，如下图 选择U盘启动 U盘插在需要装系统的电脑上，然后开机 笔记本：自己去百度你的这个型号如何从U盘启动 台式机：去百度你这个电脑主板的U盘启动方法 看图了正式安装系统下一步 现在安装 随便选一个版本 接受 （不然你还想怎样） 自定义 ： 分区自己看着选这一步建议大家把电脑上除了需要装系统的硬盘 其他的都拆下来 没区分的自己分区 没有引导分区会额外自动创建 点击确定 选择系统安装的盘符 基本就是第一个主分区 下一步 等 还是等 重启的时候就可以把U盘拔下来了，因为U盘的作用已经完了 重启 系统设置中国 随便选 我选拼音 随便 我选跳过 等 针对个人使用 下一步 如果不使用微软账号 就找到左下角 脱机账户 否 名字自己起 密码 填不填都可以 我不喜欢 我选否 我就这样配置 等咯 接着等 这不就OK了 完","link":"/2018/02/03/windows-uefi-boot-installation-win10/"},{"title":"Windows--如何使用PE安装官方ISO镜像","text":"Windows–如何使用PE安装官方ISO镜像本文主要讲述如何使用普通U盘启动盘安装Windows重装系统,注意此方法只能安装于MBR分区表的硬盘 准备工作 制作U盘启动盘–普通PE类 下载官方ISO系统文件镜像（随便找一个不是C盘的目录放着就行，建议直接扔在D盘根目录） 然后新建一个文件夹叫 WindowsImage 解压这个ISO文件到 WindowsImage文件夹 首先 将制作好的U盘插入电脑的usb接口，然后开机 选择U盘启动 笔记本：自己去百度你的这个型号如何从U盘启动 台式机：去百度你这个电脑主板的U盘启动方法 进入PE 出现如下图所示的界面 选择带有运行******x86 或者 *******x64 或者 windwos2003等字样的任何一个启动 进入PE 开始启动了 PE启动完成，现在可以操作了 安装windows系统 打开桌面上的windows安装器 点击install.wim文件的位置一项的选择 找到刚才解压的那个文件夹WindowsImage下的sources文件夹里面的install.wim文件（按大小排序按后最大的那个） 引导磁盘的位置—-选择C（最好自己去看看自己电脑现在在PE下的盘符，看一下你那个系统盘分区的盘符叫什么这里就选什么） 安装磁盘的位置—-选择C（最好自己去看看自己电脑现在在PE下的盘符，看一下你那个系统盘分区的盘符叫什么这里就选什么） 然后点击开始安装 如有对话框，则选择自动重新启动（对win10版本好像没用，需要手动重启）。不选保留原来的windows版本 确定 等待进度条完成 简书：http://www.jianshu.com/p/163b64432e97CSDN：http://blog.csdn.net/ZuoWeiXiaoDuZuoZuo/article/details/78958115 完","link":"/2018/01/03/windows-use-pe-installation-windwos-iso-image/"},{"title":"Windows--如何查看硬盘分区表类型","text":"如何查看硬盘分区表类型1、什么是硬盘分区表人们在使用电脑时，有时由于异常操作，有时由于病毒侵袭，会导致某个分区消失或硬盘无法启动。究其原因，就是硬盘分区表受损。硬盘分区表可以说是支持硬盘正常工作的骨架。操作系统正是通过它把硬盘划分为若干个分区，然后再在每个分区里面创建文件系统，写入数据文件。本文主要讲述的是分区表的位置，结构以及各个分区表是如何链接起来的。当掌握了这些知识后，即使分区表受到破坏，一样也可以根据残存的数据手工修复分区表，从而修复分区。 2、都有什么类型目前在用的 分区表类型主要有了两个： GUID （也叫 GPT）一种由基于 Itanium 计算机中的可扩展固件接口 (EFI) 使用的磁盘分区架构。与主启动记录(MBR) 分区方法相比，GPT 具有更多的优点，因为它允许每个磁盘有多达 128 个分区，支持高达 18 千兆兆字节的卷大小，允许将主磁盘分区表和备份磁盘分区表用于冗余，还支持唯一的磁盘和分区 ID (GUID）。与支持最大卷为 2 TB (terabytes) 并且每个磁盘最多有 4 个主分区（或 3 个主分区，1 个扩展分区和无限制的逻辑驱动器）的主启动记录(MBR)磁盘分区的样式相比，GUID分区表 (GPT) 磁盘分区样式支持最大卷为 18 EB (exabytes) 并且每磁盘最多有 128 个分区。与MBR分区的磁盘不同，至关重要的平台操作数据位于分区，而不是位于非分区或隐藏扇区。另外，GPT 分区磁盘有多余的主要及备份分区表来提高分区数据结构的完整性。 MBR传统的分区方案（称为MBR分区方案）是将分区信息保存到磁盘的第一个扇区（MBR扇区）中的64个字节中，每个分区项占用16个字节，这16个字节中存有活动状态标志、文件系统标识、起止柱面号、磁头号、扇区号、隐含扇区数目（4个字节）、分区总扇区数目（4个字节）等内容。由于MBR扇区只有64个字节用于分区表，所以只能记录4个分区的信息。这就是硬盘主分区数目不能超过4个的原因。后来为了支持更多的分区，引入了扩展分区及逻辑分区的概念。但每个分区项仍用16个字节存储。MBR分区方案不是用得好好的吗？为什么要提出新的方案呢？那就让我们看看MBR分区方案有什么问题。前面已经提到了主分区数目不能超过4个的限制，这是其一，很多时候，4个主分区并不能满足需要。另外最关键的是MBR分区方案无法支持超过2TB容量的磁盘。因为这一方案用4个字节存储分区的总扇区数，最大能表示2的32次方的扇区个数，按每扇区512字节计算，每个分区最大不能超过2TB。磁盘容量超过2TB以后，分区的起始位置也就无法表示了。在硬盘容量突飞猛进的今天，2TB的限制将很快被突破。由此可见，MBR分区方案已经无法满足需要了。 3、怎么查看自己的硬盘分区表桌面–&gt;计算机图标–&gt;右键–&gt;管理–&gt;磁盘管理–&gt;选择一个磁盘（注意是磁盘不是分区）–&gt;右键–&gt;属性–&gt;鼠标左键点击“卷”–&gt;查看“磁盘分区形式”","link":"/2018/02/24/windows-view-the-hard-disk-partition-table-type/"},{"title":"Xcode下载地址大全","text":"Xcode下载——绝对的官方地址下载方式简单粗暴：第一种、点击Xcode版本名称稍等几秒即可开始下载另一种、右键复制链接地址，打开下载软件，新建任务把复制的链接粘贴在地址输入框即可开始下载本文中涉及到的下载地址均为苹果官方下载地址 Xcode 2Xcode_2.3.dmg 915.0MBXcode_2.4.dmg 938.2MBXcode_2.4.1.dmg 923.2MB Xcode 3Xcode_3.0.dmg 1.1GBXcode_3.2.dmg 748.7MBXcode_3.2.3_and_ios_sdk_4.0.1.dmg 2.2GBXcode_3.2.3_and_ios_sdk_4.0.2.dmg 2.4GBXcode_3.2.4_and_ios_sdk_4.1.dmg 2.9GBXcode_3.2.5_and_ios_sdk_4.2.dmg 3.5GBXcode_3.2.6_and_ios_sdk_4.3.dmg 4.1GB Xcode 4Xcode_4_and_ios_sdk_4.3.dmg 4.2GBXcode_4.0.1_and_ios_sdk_4.3.dmg 4.2GBXcode_4.0.2_and_ios_sdk_4.3.dmg 4.2GBXcode_4.1_for_snow_leopard.dmg 4.3GBXcode_4.1_for_lion.dmg 2.9GBXcode_4.2_for_snow_leopard.dmg 1.6GBXcode_4.2_for_lion.dmg 1.6GBXcode_4.2.1_for_lion.dmg 1.6GBXcode_4.3_for_lion.dmg 1.4GBXcode_4.3.1_for_lion.dmg 1.4GBXcode_4.3.2_for_lion.dmg 1.8GBXcode_4.3.3_for_lion.dmg 1.8GBXcode_4.4.dmg 1.8GBXcode_4.4.1.dmg 1.8GBXcode_4.5.dmg 1.5GBXcode_4.5.1.dmg 1.5GBXcode_4.5.2.dmg 1.5GBXcode_4.6.dmg 1.6GBXcode_4.6.1.dmg 1.6GBXcode_4.6.2.dmg 1.6GBXcode_4.6.3.dmg 1.6GB Xcode 5Xcode_5.dmg 1.9GBXcode_5.0.1.dmg 2.0GBXcode_5.0.2.dmg 2.0GBXcode_5.1.dmg 2.1GBXcode_5.1.1.dmg 2.1GB Xcode 6Xcode_6.0.1.dmg 2.1GBXcode_6.1.dmg 2.5GBXcode_6.1.1.dmg 2.5GBXcode_6.2.dmg 2.5GBXcode_6.3.dmg 2.5GBXcode_6.3.1.dmg 2.5GBXcode_6.3.2.dmg 2.5GBXcode_6.4.dmg 2.6GB Xcode 7Xcode_7.dmg 3.5GBXcode_7.0.1.dmg 3.5GBXcode_7.1.dmg 4.2GBXcode_7.1.1.dmg 4.2GBXcode_7.2.dmg 4.4GBXcode_7.2.1.dmg 4.4GBXcode_7.3.dmg 4.8GBXcode_7.3.1.dmg 4.8GB Xcode 8Xcode_8.xip 4.1GBXcode_8.1.xip 4.1GBXcode_8.2.xip 4.2GBXcode_8.2.1.xip 4.2GBXcode_8.3.xip 4.1GBXcode_8.3.1.xip 4.1GBXcode_8.3.2.xip4.1GB","link":"/2017/07/14/xcode-xia-zai-di-zhi-da-quan/"},{"title":"简单封装AFNetworking","text":"由于本人在工作中经常会进行网络请求，实在是不想一直写那段请求代码，就自己封装了一个LiynNet类。其中使用代理完成方法回调。 这里面涉及到了GET/POST方法。废话不多说直接上代码 下面是.h文件的内容:代理回调协议方法 1234@protocol LiynNetDelegate &lt;NSObject&gt;- (void)netFinsh:(id)object;- (void)netError:(id)errorMsg;@end 这里只有一个属性delegate，用于建立代理关系；这里向外暴露了五个方法，其中第一个类方法用来初始化一个网络请求类的实例化对象，这个对象是一个单例对象，因为网络请求对象，不存储数据，只作为一个单纯的工具类，所以这个对象只需要存在一个就可以。 12345678910@interface LiynNet : NSObject@property (nonatomic, weak) id&lt;LiynNetDelegate&gt; delegate;#pragma mark: method+ (LiynNet *)defaultNet;- (void)uploadPOST:(NSString *)URLString Parameters:(id)parameters UploadDictionary:(NSDictionary*)uploadInfo;- (void)POST:(NSString *)URLString Parameters:(id)parameters;- (void)GET:(NSString *)URLString Parameters:(id)parameters;- (void)GETPic:(NSString *)URLString Parameters:(id)parameters Path:(NSString *)path;@end 下面是.m文件的内容创建单例对象 123456789+(LiynNet *)defaultNet{ static LiynNet *net = nil; if (net == nil) { net = [[LiynNet alloc] init]; net.manager = [AFHTTPSessionManager manager]; net.manager.responseSerializer = [AFHTTPResponseSerializer serializer]; } return net;} 以下是网络请求在这里我就想了定制，因为有时候需要判断返回数据的类型，例如：当一个页面进行多种数据请求时，代理方法只有一个，那么我们就需要一个标记变量来区别这次返回的数据类型是什么。所以这里的parameters字典里需要一个字段msgType来区别。 一般POST下载请求1234567891011- (void)POST:(NSString *)URLString Parameters:(id)parameters{ NSString *msgType = parameters[@&quot;msgType&quot;]; NSLog(@&quot;{\\nmethod:POST \\nURL:%@ \\nParameters:%@&quot;,URLString,parameters); [self.manager POST:URLString parameters:parameters[@&quot;msg&quot;] progress:^(NSProgress * _Nonnull uploadProgress) { } success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { [self success:@{@&quot;msgType&quot;:msgType,@&quot;msg&quot;:responseObject}]; } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) { [self failure:@{@&quot;msgType&quot;:msgType,@&quot;error&quot;:error}]; }];} 一般的GET下载请求1234567891011- (void)GET:(NSString *)URLString Parameters:(id)parameters{ NSString *msgType = parameters[@&quot;msgType&quot;]; NSLog(@&quot;method:GET URL:%@ Parameters:%@&quot;,URLString,parameters); [self.manager GET:URLString parameters:parameters progress:^(NSProgress * _Nonnull downloadProgress) { } success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { [self success:responseObject]; } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) { [self failure:@{@&quot;msgType&quot;:msgType,@&quot;error&quot;:error}]; }];} 一般的POST上传请求注意上传的字段是服务器给定的，传入的字典uploadInfo内@”uploadParameter”对应的值。 123456789101112131415161718192021222324- (void)uploadPOST:(NSString *)URLString Parameters:(id)parameters UploadDictionary:(NSDictionary*)uploadInfo{ NSString *msgType = parameters[@&quot;msgType&quot;]; NSLog(@&quot;{\\nmethod:POST \\nURL:%@ \\nParametersCid:%@&quot;,URLString,parameters[@&quot;msg&quot;]); NSDictionary *dict = parameters[@&quot;msg&quot;]; [self.manager POST: URLString parameters:dict constructingBodyWithBlock:^(id _Nonnull formData) { NSData *rightData = UIImageJPEGRepresentation(uploadInfo[@&quot;image&quot;], 0.7); [formData appendPartWithFileData:rightData name: uploadInfo[@&quot;uploadParameter&quot;] fileName:@&quot;IDRight.png&quot; mimeType:@&quot;image/jpeg&quot;]; } progress:^(NSProgress * _Nonnull uploadProgress) { NSLog(@&quot;%f&quot;,1.0 * uploadProgress.completedUnitCount/uploadProgress.totalUnitCount); } success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { NSDictionary *dict = [NSJSONSerialization JSONObjectWithData:responseObject options:NSJSONReadingMutableContainers error:nil]; [self success:@{@&quot;msgType&quot;:msgType,@&quot;msg&quot;:dict}]; } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) { [self failure:@{@&quot;msgType&quot;:msgType,@&quot;error&quot;:error}]; }];} 两个私有方法请求数据成功12345- (void)success:(id)responseObject{ if (_delegate &amp;&amp; [_delegate respondsToSelector:@selector(netFinsh:)]) { [_delegate netFinsh:responseObject]; }} 请求数据失败12345- (void)failure:(id)error{ if (_delegate &amp;&amp; [_delegate respondsToSelector:@selector(netError:)]) { [_delegate netError:error]; }} 这个类是基于AFNetworking的，所以在使用的时候必须要先倒入AFNetworking的第三方库，建议使用CocoaPods来导入，如果有人不会使用的可以自行百度。 1pod 'AFNetworking', '~&gt; 3.1.0' 首先在使用的类里遵循协议 1&lt;LiynNetDelegate&gt; 声明一个全局的LiynNet类的对象（这个全局只是建议 不全局也可以） 123{ LiynNet *_net;} 或者定义一个属性 1@property (nonatomic, strong) LiynNet *net; 实例化这个LiynNet对象并建立代理关系 12345678#pragma mark - 懒加载-(LiynNet *)net{ if (_net == nil) { _net = [LiynNet defaultNet]; _net.delegate = self; } return _net;} 实现协议的方法在这里你就可以操作返回的数据了 123- (void)netFinsh:(id)object{ NSLog(@&quot;msgType %@\\n msg %@&quot;,object[@&quot;msgType&quot;],object[@&quot;msg&quot;]);} 这里你就需要慢慢查找原因了 1234- (void)netError:(id)errorMsg{ NSLog(@&quot;msgType %@\\n msg %@&quot;, errorMsg[@&quot;msgType&quot;], errorMsg[@&quot;msg&quot;]);}","link":"/2017/07/14/ios-custom-afnetworking/"},{"title":"iOS自定义多选相册","text":"自定义多选相册一个项目需要类似于安卓的多选相册，而iOS自带的Piker只能单选，所以就想到了自定义，自定义的过程是辛苦的，结果出来之后是高兴的。 &lt;!--more--&gt; 写在前面本代码只展示了iOS默认的相册内容，如果读者有其他想法的欢迎再本代码基础上修改。 获取系统默认的相册1234567-(PHFetchResult *)smartAlbums{ if (_smartAlbums == nil) { _smartAlbums = [PHAssetCollection fetchAssetCollectionsWithType:PHAssetCollectionTypeSmartAlbum subtype:PHAssetCollectionSubtypeSmartAlbumUserLibrary options:nil]; } return _smartAlbums;} 获取系统相册中的相片默认的照片排序是时间先后顺序，这里我也规定了按照文件创建的先后顺序来排序呢，为了避免同时引用过多的image导致内存暴增，这里使用的都是缩略图，而且只允许引用前20项。 1234567891011121314151617181920212223242526272829303132333435- (void)initPhotoData{ [self.photoArray removeAllObjects]; __weak typeof(self) weakSelf = self; for (PHCollection * obj in self.smartAlbums) { if ([obj isKindOfClass:[PHAssetCollection class]]) { PHAssetCollection *collection = (PHAssetCollection *)obj; PHFetchOptions *options = [[PHFetchOptions alloc] init]; options.sortDescriptors = @[[NSSortDescriptor sortDescriptorWithKey:@&quot;creationDate&quot; ascending:NO]]; PHFetchResult *fetchReuslt = [PHAsset fetchAssetsInAssetCollection:collection options:options]; NSLog(@&quot;count - %ld&quot;,(unsigned long)fetchReuslt.count); if (fetchReuslt.count == 0) { continue; } NSInteger count = 20&lt;fetchReuslt.count?20:fetchReuslt.count; __block NSInteger _index = 0; for (NSInteger i = 0 ;i&lt;count;i++) { PHAsset *asset = fetchReuslt[i]; //使用PHImageManager从PHAsset中请求图片 NSInteger index = _index; MyImageManager *imageManager = [MyImageManager defaultManager]; [imageManager requestImageForAsset:asset targetSize:CGSizeMake(ItemWidth()*2-2, ItemHieght()*2-2) contentMode:PHImageContentModeAspectFill options:self.requestOption Index:index resultHandler:^(UIImage *result, NSDictionary *info, NSInteger index) { NSInteger IDKey = [info[@&quot;PHImageResultRequestIDKey&quot;] integerValue]; NSLog(@&quot;%@,%ld,%ld,%ld&quot;,result,(long)IDKey,index,IDKey-index); [weakSelf.photoArray addObject:result]; }]; _index++; } }else{ NSLog(@&quot;NO&quot;); NSAssert1(NO, @&quot;Fetch Collect Not PHCollection:%@&quot;, obj); } } NSLog(@&quot;initPhotoDataDone&quot;);} 将获取到的缩略图展示到CollectionView上 这个项目在码云的git库上有，地址为https://git.oschina.net/LiynXu/PhotoDemo.git。 如果有任何意见或者建议，或者发现bug(应该是有的),请移步值git库下给予指导，3Q。","link":"/2017/08/18/ios-custom-ablum/"},{"title":"iOS实例化对象转换为JSON数据","text":"如何将自定义类的实例化对象转换为JSON数据 我所用的方法是通过Runtime的相关方法，先后两步来实现的。具体往下看： 新建一个类命名为《UserClass》 展示.h文件UserClass.h 1234567891011121314// UserClass.h// MyPickerView// Created by LiynXu on 16/3/7.// Copyright © 2016年 LiynXu. All rights reserved.#import &lt;Foundation/Foundation.h&gt;@interface UserClass : NSObject@property (nonatomic,strong) NSString *name;@property (nonatomic,strong) NSString *password;@property (nonatomic,assign) NSInteger age;@property (nonatomic,strong) NSString *sex;- (instancetype)initWithName:(NSString *)name Password:(NSString *)password;- (NSDictionary *)convertToDictWithObject:(NSObject *)object;//主要使用这个方法得到一个字典@end 由上面的头文件可以看出我所建立的类有4个属性：name，password，age，sex。并且包含一个初始化方法，和对象转字典的方法(了解过Runtime，所以知道了Runtime可以在运行时某个对象的所有属性，以及属性的相关值) 具体实现方法 第一步将自定义类的实例化对象转为字典，这一步需要结合Runtime进行，所以我们需要做一个操作就是导入一个头文件 #import &lt;objc/runtime.h&gt;//当前需要使用使用运行时库 第二步使用第一部得到的字典转为JSON数据 1234567891011121314151617// UserClass.m// MyPickerView// Created by LiynXu on 16/3/7.// Copyright © 2016年 LiynXu. All rights reserved.#import &quot;UserClass.h&quot;#import &lt;objc/runtime.h&gt;//当前需要使用使用运行时库@implementation UserClass-(instancetype)initWithName:(NSString *)name Password:(NSString *)password{ self= [super init]; if (self) { _name = name; _password = password; } return self;} 上面的主要是一个初始化方法，重要的是下面，下面，下面！ 123456789101112131415161718- (NSDictionary *)convertToDictWithObject:(NSObject *)object{//获取当前对象的所有属性以及属性的值 NSMutableDictionary *Dict = [NSMutableDictionary dictionary]; unsigned int outCount, i; objc_property_t *properties = class_copyPropertyList([object class], &amp;outCount); //获取所有属性以及属性的值,并且转换为一个字典 for (i = 0; i&lt;outCount; i++){ objc_property_t property = properties[i]; const char* char_f =property_getName(property); NSString *propertyName = [NSString stringWithUTF8String:char_f]; id propertyValue = [self valueForKey:(NSString *)propertyName]; if (propertyValue) [Dict setObject:propertyValue forKey:propertyName]; } free(properties); return Dict;}@end 程序入口main.m 包含具体示例代码 123456789101112131415161718192021222324252627282930313233//// main.m// JsonCode//// Created by LiynXu on 16/3/7.// Copyright © 2016年 LiynXu. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;#import &quot;UserClass.h&quot;int main(int argc, const char * argv[]) { @autoreleasepool { UserClass *user = [[UserClass alloc] initWithName:@&quot;name&quot; Password:@&quot;password&quot;]; NSDictionary *codeDict = [user convertToDictWithObject:user];//对象转字典， NSLog(@&quot;%@&quot;,codeDict); NSData *jsonData = [NSJSONSerialization dataWithJSONObject:codeDict options:NSJSONWritingPrettyPrinted error:nil];//字典转json code NSLog(@&quot;%@&quot;,jsonData); NSFileManager *fileManager = [NSFileManager defaultManager]; NSString *path = [NSString stringWithFormat:@&quot;%@/Document/jsonData.json&quot;,NSHomeDirectory()]; BOOL res=[fileManager createFileAtPath:path contents:nil attributes:nil]; if (res) { NSLog(@&quot;文件创建成功: %@&quot; ,path); }else NSLog(@&quot;文件创建失败: %@&quot; ,path); NSString *jsonStrong = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding]; //json转字符串 NSLog(@&quot;%@&quot;,jsonStrong); NSDictionary *decodeDict = [NSJSONSerialization JSONObjectWithData:jsonData options:NSJSONReadingMutableContainers error:nil]; //json Decode NSLog(@&quot;%@&quot;,decodeDict); } return 0;}","link":"/2017/08/18/ios-custom-object-to-json-runtime/"},{"title":"获取iOS设备型号，目前所有iOS设备","text":"简介获取iOS设备型号，目前所有iOS设备皆可识别 下面是.h文件 声明这个返回值为NSString的类方法 1234567891011121314151617// GetDeviceModel.h// Created by LiynXu on 15/11/10.// Copyright © 2015年 LiynXu. All rights reserved.// xxl652170427@163.com#import &lt;Foundation/Foundation.h&gt;@interface GetDeviceModel : NSObject/* 获取设备描述 */+ (NSString *)getCurrentDeviceModelDescription;/* 由获取到的设备描述，来匹配设备型号 */+ (NSString *)getCurrentDeviceModel;@end 返回值为NSString的类方法 获取设备描述 12345678910111213141516+ (NSString *)getCurrentDeviceModelDescription{ int mib[2]; size_t len; char *machine; mib[0] = CTL_HW; mib[1] = HW_MACHINE; sysctl(mib, 2, NULL, &amp;len, NULL, 0); machine = malloc(len); sysctl(mib, 2, machine, &amp;len, NULL, 0); NSString *platform = [NSString stringWithCString:machine encoding:NSASCIIStringEncoding]; free(machine); return platform;} 由获取到的设备描述，来匹配设备型号 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485+ (NSString *)getCurrentDeviceModel{ NSString *platform = [GetDeviceModel getCurrentDeviceModelDescription]; if ([platform isEqualToString:@&quot;iPhone1,1&quot;]) return @&quot;iPhone 2G&quot;; if ([platform isEqualToString:@&quot;iPhone1,2&quot;]) return @&quot;iPhone 3G&quot;; if ([platform isEqualToString:@&quot;iPhone2,1&quot;]) return @&quot;iPhone 3GS&quot;; if ([platform isEqualToString:@&quot;iPhone3,1&quot;]) return @&quot;iPhone 4&quot;; if ([platform isEqualToString:@&quot;iPhone3,2&quot;]) return @&quot;iPhone 4&quot;; if ([platform isEqualToString:@&quot;iPhone3,3&quot;]) return @&quot;iPhone 4&quot;; if ([platform isEqualToString:@&quot;iPhone4,1&quot;]) return @&quot;iPhone 4S&quot;; if ([platform isEqualToString:@&quot;iPhone5,1&quot;]) return @&quot;iPhone 5&quot;; if ([platform isEqualToString:@&quot;iPhone5,2&quot;]) return @&quot;iPhone 5&quot;; if ([platform isEqualToString:@&quot;iPhone5,3&quot;]) return @&quot;iPhone 5c&quot;; if ([platform isEqualToString:@&quot;iPhone5,4&quot;]) return @&quot;iPhone 5c&quot;; if ([platform isEqualToString:@&quot;iPhone6,1&quot;]) return @&quot;iPhone 5s&quot;; if ([platform isEqualToString:@&quot;iPhone6,2&quot;]) return @&quot;iPhone 5s&quot;; if ([platform isEqualToString:@&quot;iPhone7,1&quot;]) return @&quot;iPhone 6 Plus&quot;; if ([platform isEqualToString:@&quot;iPhone7,2&quot;]) return @&quot;iPhone 6&quot;; if ([platform isEqualToString:@&quot;iPhone8,1&quot;]) return @&quot;iPhone 6S&quot;; if ([platform isEqualToString:@&quot;iPhone8,2&quot;]) return @&quot;iPhone 6S Plus&quot;; if ([platform isEqualToString:@&quot;iPhone9,1&quot;]) return @&quot;iPhone 7 A1660&quot;; if ([platform isEqualToString:@&quot;iPhone9,2&quot;]) return @&quot;iPhone 7 Plus A1661&quot;; if ([platform isEqualToString:@&quot;iPhone9,3&quot;]) return @&quot;iPhone 7 A1778&quot;; if ([platform isEqualToString:@&quot;iPhone9,4&quot;]) return @&quot;iPhone 7 Plus A1784&quot;; if ([platform isEqualToString:@&quot;iPod1,1&quot;]) return @&quot;iPod Touch 1G&quot;; if ([platform isEqualToString:@&quot;iPod2,1&quot;]) return @&quot;iPod Touch 2G&quot;; if ([platform isEqualToString:@&quot;iPod3,1&quot;]) return @&quot;iPod Touch 3G&quot;; if ([platform isEqualToString:@&quot;iPod4,1&quot;]) return @&quot;iPod Touch 4G&quot;; if ([platform isEqualToString:@&quot;iPod5,1&quot;]) return @&quot;iPod Touch 5G&quot;; if ([platform isEqualToString:@&quot;iPad1,1&quot;]) return @&quot;iPad 1G&quot;; if ([platform isEqualToString:@&quot;iPad2,1&quot;]) return @&quot;iPad 2&quot;; if ([platform isEqualToString:@&quot;iPad2,2&quot;]) return @&quot;iPad 2&quot;; if ([platform isEqualToString:@&quot;iPad2,3&quot;]) return @&quot;iPad 2&quot;; if ([platform isEqualToString:@&quot;iPad2,4&quot;]) return @&quot;iPad 2&quot;; if ([platform isEqualToString:@&quot;iPad2,5&quot;]) return @&quot;iPad Mini 1G&quot;; if ([platform isEqualToString:@&quot;iPad2,6&quot;]) return @&quot;iPad Mini 1G&quot;; if ([platform isEqualToString:@&quot;iPad2,7&quot;]) return @&quot;iPad Mini 1G&quot;; if ([platform isEqualToString:@&quot;iPad3,1&quot;]) return @&quot;iPad 3&quot;; if ([platform isEqualToString:@&quot;iPad3,2&quot;]) return @&quot;iPad 3&quot;; if ([platform isEqualToString:@&quot;iPad3,3&quot;]) return @&quot;iPad 3&quot;; if ([platform isEqualToString:@&quot;iPad3,4&quot;]) return @&quot;iPad 4&quot;; if ([platform isEqualToString:@&quot;iPad3,5&quot;]) return @&quot;iPad 4&quot;; if ([platform isEqualToString:@&quot;iPad3,6&quot;]) return @&quot;iPad 4&quot;; if ([platform isEqualToString:@&quot;iPad4,1&quot;]) return @&quot;iPad Air&quot;; if ([platform isEqualToString:@&quot;iPad4,2&quot;]) return @&quot;iPad Air&quot;; if ([platform isEqualToString:@&quot;iPad4,3&quot;]) return @&quot;iPad Air&quot;; if ([platform isEqualToString:@&quot;iPad4,4&quot;]) return @&quot;iPad Mini 2G &quot;; if ([platform isEqualToString:@&quot;iPad4,5&quot;]) return @&quot;iPad Mini 2G &quot;; if ([platform isEqualToString:@&quot;iPad4,6&quot;]) return @&quot;iPad Mini 2G &quot;; if ([platform isEqualToString:@&quot;iPad4,7&quot;]) return @&quot;iPad Mini 3 &quot;; if ([platform isEqualToString:@&quot;iPad4,8&quot;]) return @&quot;iPad Mini 3 &quot;; if ([platform isEqualToString:@&quot;iPad4,9&quot;]) return @&quot;iPad Mini 3 &quot;; if ([platform isEqualToString:@&quot;iPad5,1&quot;]) return @&quot;iPad Mini 4 WiFi &quot;; if ([platform isEqualToString:@&quot;iPad5,2&quot;]) return @&quot;iPad Mini 4 WiFi+Cellular &quot;; if ([platform isEqualToString:@&quot;iPad5,3&quot;]) return @&quot;iPad Air2 &quot;; if ([platform isEqualToString:@&quot;iPad5,4&quot;]) return @&quot;iPad Air2 &quot;; if ([platform isEqualToString:@&quot;iPad6,7&quot;]) return @&quot;iPad Pro WiFi 12.7-inch&quot;; if ([platform isEqualToString:@&quot;iPad6,8&quot;]) return @&quot;iPad Pro WiFi+Cellular 12.7-inch&quot;; if ([platform isEqualToString:@&quot;iPad6,3&quot;]) return @&quot;iPad Pro WiFi 9.7-inch&quot;; if ([platform isEqualToString:@&quot;iPad6,4&quot;]) return @&quot;iPad Pro WiFi+Cellular 9.7-inch&quot;; if ([platform isEqualToString:@&quot;i386&quot;]) return @&quot;iPhone Simulator&quot;; if ([platform isEqualToString:@&quot;x86_64&quot;]) return @&quot;iPhone Simulator&quot;; return platform;} 如何使用首先在.m文件中导入以下两个头文件 12#import &quot;GetDeviceModel.h&quot;#import &lt;sys/sysctl.h&gt; 然后在需要获取设备型号地方这样写,用一个NSString类型的对象接收 12NSString *string = [GetDeviceModel getCurrentDeviceModel];NSLog(@&quot;设备型号:%@&quot;,string); 也可以给当前app的AppDelegate添加一个DeviceModel属性,一下是AppDelegate的.h文件内容 1234567#import &lt;UIKit/UIKit.h&gt;@interface AppDelegate : UIResponder &lt;UIApplicationDelegate&gt;@property (strong, nonatomic) UIWindow *window;@property (nonatomic,copy) NSString *DeviceModel;@end 然后直接想下面这样用就行了 1self.DeviceModel = [GetDeviceModel getCurrentDeviceModel]; 完整代码演示：https://git.oschina.net/LiynXu/GetDeviceModel.git 欢迎访问！效果展示：","link":"/2017/08/18/ios-get-ios-device-model/"},{"title":"iOS HealthKit简单介绍","text":"HealthKit简单介绍目前很多App都会有访问健康数据的需求，那么我们就不得不使用HealthKit。HealthKit框架提供了一个结构，应用可以使用它来分享健康和健身数据。HealthKit管理从不同来源获得的数据，并根据用户的偏好设置，自动将不同来源的所有数据合并起来。应用还可以获取每个来源的原始数据，然后执行自己的数据合并。 如何在项目中集成HealthKit这一个部分我们将一步一步的在项目中集成HealthKit。 第一步添加HealthKit1、进入项目设置–&gt;Capabilities–&gt;HealthKit，然后如下图打开就可以了，如果下面几个选项前都打上了勾的话，那么就代表OK了，一般也不会出现X。 2、如果上面的步骤完成了的话那么在工程目录下会多一个文件，这个文件以工程名命名，后缀名为entitlements，如下图： 3、并且在Frameworks目录下会多一个HealthKit.framework文件： 项目中的使用首先要在需要访问健康数据的地方，使用import导入HealthKit头文件： 1#import &lt;HealthKit/HealthKit.h&gt; 然后写一个属性： 1@property (nonatomic, strong) HKHealthStore *healthStore; 1、这一步为你的应用实例化一个 HKHealthStore 对象。每个应用只需要一个HealthKit存储实例。这个存储实例就是你和HealthKit数据库交互的主要接口。 1self.healthStore = [[HKHealthStore alloc] init]; 2、 调用 isHealthDataAvailable 方法来查看HealthKit在该设备上是否可用。HealthKit在iPad上不可用。 123if ([HKHealthStore isHealthDataAvailable]) { NSLog(@&quot;HealthDataAvailable&quot;); } 3、在项目中具体代码： 123456789101112131415161718192021222324//创建想要获取的数据类型 HKObjectType *stepCpunt = [HKObjectType quantityTypeForIdentifier:HKQuantityTypeIdentifierStepCount];//步数 HKObjectType *Height = [HKObjectType quantityTypeForIdentifier:HKQuantityTypeIdentifierHeight];//身高 HKObjectType *BodyMass = [HKObjectType quantityTypeForIdentifier:HKQuantityTypeIdentifierBodyMass];//体重 HKObjectType *DistanceWalkingRunning = [HKObjectType quantityTypeForIdentifier:HKQuantityTypeIdentifierDistanceWalkingRunning];//步行+跑步距离 HKObjectType *DistanceCycling = [HKObjectType quantityTypeForIdentifier:HKQuantityTypeIdentifierDistanceCycling];//骑行距离 //一个集合，数据类型 NSSet *healthSet = [NSSet setWithObjects:stepCpunt,Height,BodyMass,DistanceWalkingRunning,DistanceCycling,nil]; //[self.healthStore requestAuthorizationToShareTypes:nil readTypes:healthSet completion:nil]; //向系统的健康APP请求数据，并回调结果 [self.healthStore requestAuthorizationToShareTypes:nil readTypes:healthSet completion:^(BOOL success, NSError * _Nullable error) { if (success) { NSLog(@&quot;requestAuthorization success&quot;); [self readHealthData:HKQuantityTypeIdentifierStepCount]; [self readHealthData:HKQuantityTypeIdentifierDistanceWalkingRunning]; [self readHealthData:HKQuantityTypeIdentifierDistanceCycling]; [self readHealthData:HKQuantityTypeIdentifierHeight]; [self readHealthData:HKQuantityTypeIdentifierBodyMass]; }else{ NSLog(@&quot;requestAuthorization error&quot;); } }]; 具体的数据获的操作 123456789101112131415161718192021222324252627282930313233//查询数据- (void)readHealthData:(NSString* )HKQuantityTypeIdentifierType{ //查询采样信息 HKSampleType *sampleType = [HKQuantityType quantityTypeForIdentifier:HKQuantityTypeIdentifierType]; //NSSortDescriptors用来告诉healthStore怎么样将结果排序。 NSSortDescriptor *start = [NSSortDescriptor sortDescriptorWithKey:HKSampleSortIdentifierStartDate ascending:NO]; NSSortDescriptor *end = [NSSortDescriptor sortDescriptorWithKey:HKSampleSortIdentifierEndDate ascending:NO]; /* 查询的基类是HKQuery，这是一个抽象类，能够实现每一种查询目标，这里我们需要查询的步数是一个 HKSample类所以对应的查询类就是HKSampleQuery。 下面的limit参数传1表示查询最近一条数据,查询多条数据只要设置limit的参数值就可以了 在这里我们需要定义block里面执行哪些语句 */ HKSampleQuery *sampleQuery = [[HKSampleQuery alloc] initWithSampleType:sampleType predicate:nil limit:2 sortDescriptors:@[start,end] resultsHandler:^(HKSampleQuery * _Nonnull query, NSArray&lt;__kindof HKSample *&gt; * _Nullable results, NSError * _Nullable error) { //打印查询结果 NSLog(@&quot;resultCount = %ld result = %@&quot;,results.count,results); //把结果装换成字符串类型 if (results.count!=0) { HKQuantitySample *result = results[0]; HKQuantity *quantity = result.quantity; NSString *stepStr = (NSString *)quantity; [[NSOperationQueue mainQueue] addOperationWithBlock:^{ //查询是在多线程中进行的，如果要对UI进行刷新，要回到主线程中 NSLog(@&quot;最新数据：%@&quot;,stepStr); }]; }else{ NSLog(@&quot;没有健康数据&quot;); } }]; //执行查询 [self.healthStore executeQuery:sampleQuery];} 运行结果在这里","link":"/2017/08/18/ios-healthkit/"},{"title":"通过assetURL获取到视频","text":"首先导入头文件 1#import &lt;Photos/Photos.h&gt; iOS中assetURL样式： 1assets-library://asset/asset.mov?id=F2E6E143-4343-4B57-87F9-346936E0EDB3&amp;ext=mov 使用当前的URL过滤到我们想要的数据 1234567891011121314151617181920212223242526272829303132PHFetchResult *result = [PHAsset fetchAssetsWithALAssetURLs:@[assetUrl] options:nil]; PHAsset * PHAsset = result.firstObject; /// 包含该视频的基础信息 PHAssetResource * resource = [[PHAssetResource assetResourcesForAsset: PHAsset] firstObject]; NSLog(@&quot;%@&quot;,resource); /* type: originalFilename: */ PHImageRequestOptions * options = [[PHImageRequestOptions alloc] init]; options.version = PHImageRequestOptionsVersionCurrent; options.deliveryMode = PHImageRequestOptionsDeliveryModeHighQualityFormat; options.synchronous = YES; __block NSData *videoData = nil; [[PHImageManager defaultManager] requestImageDataForAsset: PHAsset options: options resultHandler: ^(NSData * imageData, NSString * dataUTI, UIImageOrientation orientation, NSDictionary * info) { NSLog(@&quot;%@&quot;,imageData); //这里的imageData就是视频数据; }];","link":"/2017/12/14/ios-use-asseturl-get-vedio/"},{"title":"水波纹-OC-iOS","text":"简介使用iOS原生CoreGraphic框架完成，主要内容就是在给定的路径上绘制出图形，水波纹的实现是按照三角函数的sin函数来实现的，利用sin函数计算出大量的点，然后做颜色填充。 实现方法首先一个波纹需要一个layer来进行渲染，越底层的波纹要越早绘制，本Demo只实现了双波纹交错。水波纹基本属性： 不需要对外暴露的属性 12345678@interface WaterRippleView(){ float _currentLinePointY;}@property (nonatomic, strong)CADisplayLink *rippleDisplayLink;//苹果的垂直同步@property (nonatomic, strong)CAShapeLayer *mainRippleLayer;//主波图层@property (nonatomic, strong)CAShapeLayer *minorRippleLayer;//次波图层@property (nonatomic, assign)CGFloat rippleWidth;//波浪宽度@end 可以对外暴露的属性 1234567@property (nonatomic, strong)UIColor *mainRippleColor;//主波填充颜色@property (nonatomic, strong)UIColor *minorRippleColor;//次波填充颜色@property (nonatomic, assign)CGFloat mainRippleoffsetX;//主波偏移量@property (nonatomic, assign)CGFloat minorRippleoffsetX;//次波偏移量@property (nonatomic, assign)CGFloat rippleSpeed;//波浪速度@property (nonatomic, assign)CGFloat ripplePosition;//波浪Y轴位置@property (nonatomic, assign)float rippleAmplitude;//波浪振幅 各属性的默认值设置 12345678self.mainRippleColor = [UIColor colorWithRed:255/255.0f green:127/255.0f blue:80/255.0f alpha:1];self.minorRippleColor = [UIColor whiteColor];self.mainRippleoffsetX = 1;self.minorRippleoffsetX = 2;self.rippleSpeed = .5f;self.rippleWidth = frame.size.width;self.ripplePosition = frame.size.height-10.0f;self.rippleAmplitude = 5; 对外暴露的方法 1234//设置frame 主波填充颜色 次波填充颜色- (instancetype)initWithFrame:(CGRect)frame mainRippleColor:(UIColor *)mainRippleColor minorRippleColor:(UIColor *)minorRippleColor;//设置frame 主波填充颜色 次波填充颜色 主波偏移量 次波偏移量 波浪速度 波浪Y轴位置 波浪振幅- (instancetype)initWithFrame:(CGRect)frame mainRippleColor:(UIColor *)mainRippleColor minorRippleColor:(UIColor *)minorRippleColor mainRippleoffsetX:(float)mainRippleoffsetX minorRippleoffsetX:(float)minorRippleoffsetX rippleSpeed:(float)rippleSpeed ripplePosition:(float)ripplePosition rippleAmplitude:(float)rippleAmplitude; 在view中需要绘制图形时，要在自带的dramRect：方法中编写相关代码 123456789101112131415- (void)drawRect:(CGRect)rect { /* *创建两个layer */ self.mainRippleLayer = [CAShapeLayer layer]; self.mainRippleLayer.fillColor = self.mainRippleColor.CGColor; [self.layer addSublayer:self.mainRippleLayer]; self.minorRippleLayer = [CAShapeLayer layer]; self.minorRippleLayer.fillColor = self.minorRippleColor.CGColor; [self.layer addSublayer:self.minorRippleLayer]; self.rippleDisplayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(getCurrentRipple)]; [self.rippleDisplayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];} 下面是绘制代码：主波 123456789101112131415- (void)drawMainRipple{ self.mainRippleoffsetX += self.rippleSpeed; CGMutablePathRef path = CGPathCreateMutable(); CGPathMoveToPoint(path, nil, 0, self.ripplePosition); CGFloat y = 0.f; for (float x = 0.f; x &lt;= self.rippleWidth ; x++) { y = self.rippleAmplitude * sin(1.2 * M_PI/ self.rippleWidth * x - self.mainRippleoffsetX *M_PI/180) + self.ripplePosition; CGPathAddLineToPoint(path, nil, x, y); } CGPathAddLineToPoint(path, nil, self.rippleWidth, self.frame.size.height); CGPathAddLineToPoint(path, nil, 0, self.frame.size.height); CGPathCloseSubpath(path); self.mainRippleLayer.path = path; CGPathRelease(path);} 次波 12345678910111213141516- (void)drawMinorRipple{ self.minorRippleoffsetX += self.rippleSpeed+0.1f; CGMutablePathRef minorRipple = CGPathCreateMutable(); CGPathMoveToPoint(minorRipple, nil, 0, self.ripplePosition); CGFloat y = 0.f; for (float x = 0.f; x &lt;= self.rippleWidth ; x++) { y = self.rippleAmplitude * sin(1.2 * M_PI/ self.rippleWidth * x - self.minorRippleoffsetX*M_PI/360 ) + self.ripplePosition; CGPathAddLineToPoint(minorRipple, nil, x, y); } CGPathAddLineToPoint(minorRipple, nil, self.rippleWidth, self.frame.size.height); CGPathAddLineToPoint(minorRipple, nil, 0, self.frame.size.height); CGPathCloseSubpath(minorRipple); self.minorRippleLayer.path = minorRipple; CGPathRelease(minorRipple);} 实现效果 最后本Demo的git库地址：https://git.oschina.net/LiynXu/waterripple.git欢迎访问","link":"/2017/07/14/ios-water-ripple-oc/"},{"title":"斐讯K2刷华硕固件","text":"写在前面斐讯K2是一款处于1200Mbps(300+867Mbps)无线速率段的双频802.11ac路由器，2.4G+5G双频并发，PA+LNA强强组合，智能管理轻松控制，斐讯K2完美诠释了“家再大，隔墙再多，WiFi信号不受阻隔”的上网体验。斐讯K2路由器可以在京东免费撸，很多朋友撸回家发现固件太垃圾，各种不好用，因此想把斐讯K2刷成华硕固件。 中关村斐讯K2 重要说明 据说，这种方法支持斐讯K2的固件版本为： 22.3.15.128 22.3.15.232 22.3.17.148 22.4.2.8 22.4.2.9 如果目前你的斐讯K2路由器的固件版本高于或者低于这几个版本，可以进行升级或者降级操作，然后按照。下面我会提供相关文件的下载地址，方便大家下载后进行升级和降级操作。点击 百度网盘或者复制链接: https://pan.baidu.com/s/1gfssXUz 密码: qdke 第一步：——自带固件降级—–降级分为两个版本，一个是老版本22.5.9，另外一个是22.5.11，因为在.11版本降级会出现提示，非法固件而不允许刷机，那么我们就是用另外一种方法来进行刷机 首先22.5.9版本降级第1步a、进入系统设置，找到手动升级，选择k2_163_v11_breed.bin ，然后升级 第2步a、升级完成后，断开路由器电源。 b、按住复位键，插上电源，等待7秒钟后松开复位键。 第3步 a、进入breed web设置页面 22.5.11版本降级第1步1、安装Firefox浏览器。 2、用网线连接电脑和路由器的Lan口（WAN口无所谓，联不联网无所谓），K1、K2默认登录密码修改为admin。 第2步、开启telnet工作1、打开Firefox浏览器登陆斐讯路由器，选择右上角的“定时重启路由器”，如图。 2、点击指定重启时间，将鼠标箭头放到05上，右键选择“查看元素”。注意一定要放在05上； 3、在查看器中将鼠标移到”05”上（找不到05的话刷新一下网页），点击鼠标右键，选择“编程HTML”。 4、将”05”改成”01:00 | telnetd -l /bin/login.sh”（复制粘贴即可），然后鼠标移动到黑框之外的空白处点击鼠标左键，就可以完成编辑了。 5、在定时重启路由器页面上选择05之后（注意现在回变成1：00…..），点击“保存”。 那么现在就完成了开启K2路由器telnet服务的工作。6、下载目录内breed Web助手（3.4版本）–&gt;关闭防火墙，退出杀毒软件–&gt;找到这个文件“路由器刷breed Web助手通用版v3.0”–&gt;右键以管理员身份运行 7、如图刷机方案选择：”通用方案[需要开启路由器telnet或ssh]”，然后点击开始刷机； 8、完成后这样就完成了斐讯路由器刷入不死Breed。 第二步： a、进入breed界面 b、在菜单固件更新中，选择文件哪一行，选择SW_K2_703004657_V22.4.2.8.bin 固件 c、等待上传完成 e、请等待升级完成，自动重启后。然后按住复位键7秒，等待重启后。 到此你的路由器固件成功降级到了22.4.2.8 f、注意右下角的固件版本号 ——刷入华硕固件—–第1步–刷入breed和ssh a、点击“高级设置”——&gt;“备份恢复”——&gt;“浏览”找到刚才下载的：tianbaoha_breed_ssh.dat文件——&gt;“恢复备份”。 b、路由器会自动重启，等待重启完成 c、验证 斐讯K2重启完成后，重新在浏览器中输入p.to或者192.168.2.1，打开登录界面，管理密码用：tianbaoha 。如果可以登录到设置界面，说明breed和ssh已经刷入成功。 第2步a、管理密码用：tianbaoha 登录到K2的设置界面后，点击“高级设置”——&gt;“系统设置”——&gt;“手动升级”——&gt;点击 下载备份EEPROM，如下图所示。 第3步–刷写华硕固件**登录地址：192.168.123.1 ****管理账号：admin/admin **默认wifi密码：1234567890 a、点击“高级设置”——&gt;“系统设置”——&gt;“手动升级”——&gt;点击“浏览”，找到刚才下载的华硕固件:RT-AC54U-GPIO-1-PSG1208-64M_3.4.3.9-099.trx b、点击“升级”。 第4步 a、等待路由器重启。 b、在浏览器中输入：192.168.123.1 打开登录界面——&gt;用户名和密码用：admin/admin，登录到界面了 结束","link":"/2017/08/18/fei-xun-k2-shua-hua-shuo-gu-jian/"},{"title":"iOS10富文本推送--NotificationContentExtension","text":"NotificationContentExtension文件根据以下ContentExtension Info.plist文件中的配置决定category的设置，两者必须一致： NSExtensionPrincipalClass对应的值是你展示视图的controller（这里就是NotificationViewController） 宏定义采用下列代码： 12345678910111213141516//推送相关设置#define Action_Category_Identifier_Image @&quot;Image_Category&quot; //图片类别标识符#define Action_Category_Identifier_Audio @&quot;Audio_Category&quot; //音频类别标识符#define Action_Category_Identifier_Movie @&quot;Movie_Category&quot; //视频类别标识符#define Action_Identifier_Image_Confirm @&quot;imageConfirmAction&quot; //图片确认按钮#define Action_Identifier_Image_Concel @&quot;imageConcelAction&quot; //图片取消按钮#define Action_Identifier_Audio_Confirm @&quot;audioConfirmAction&quot; //音频确认按钮#define Action_Identifier_Audio_Concel @&quot;audioConcelAction&quot; //音频取消按钮#define Action_Identifier_Movie_Confirm @&quot;movieConfirmAction&quot; //视频确认按钮#define Action_Identifier_Movie_Concel @&quot;movieConcelAction&quot; //视频取消按钮#define Action_Title_Image_Confirm @&quot;查看&quot; //图片确认按钮标题#define Action_Title_Image_Concel @&quot;忽略&quot; //图片取消按钮标题#define Action_Title_Audio_Confirm @&quot;查看&quot; //音频确认按钮标题#define Action_Title_Audio_Concel @&quot;忽略&quot; //音频取消按钮标题#define Action_Title_Movie_Confirm @&quot;查看&quot; //视频确认按钮标题#define Action_Title_Movie_Concel @&quot;忽略&quot; //视频取消按钮标题 采用的是自定义布局，注意如果想使用这个布局的话，你必须提前在service里面设置好categoryIdentifier，它的值是你plist文件里面的任何一个 1234@interface NotificationViewController () &lt;UNNotificationContentExtension&gt;@property (nonatomic, strong)UIImageView *imageView;@property (nonatomic,strong)UILabel *label;@end LazyLoad 1234567-(UIImageView *)imageView{ if (_imageView == nil) { _imageView = [[UIImageView alloc] init]; _imageView.contentMode = UIViewContentModeScaleAspectFit; } return _imageView;} AddView 123456- (void)viewDidLoad { [super viewDidLoad]; [self.view addSubview:self.imageView]; // Do any required interface initialization here.} 取出多媒体资料并展示到视图上，下面为image 123456789101112131415161718- (void)didReceiveNotification:(UNNotification *)notification { NSLog(@&quot;notification.request.content.userInfo%@&quot;,notification.request.content.userInfo); UNNotificationContent * content = notification.request.content; CGFloat widthTime = 2; if ([UIScreen mainScreen].bounds.size.width&gt;375) { widthTime = 3.0; } UIImage *image = nil; if (content.attachments.count) { UNNotificationAttachment * attachment_img = content.attachments[0]; if (attachment_img.URL.startAccessingSecurityScopedResource) { image = [UIImage imageWithContentsOfFile:attachment_img.URL.path]; self.imageView.image = image; } } self.imageView.frame = self.view.frame; self.label.text = notification.request.content.body;} 响应相关Action 12345678910111213141516171819202122232425-(void)didReceiveNotificationResponse:(UNNotificationResponse *)response completionHandler:(void (^)(UNNotificationContentExtensionResponseOption))completion{ UNNotificationContent *content = [response.notification.request.content mutableCopy]; NSString *category = content.categoryIdentifier; NSString *actionIdentifier = [response.actionIdentifier copy]; if ([category isEqualToString:Action_Category_Identifier_Image]) { if ([actionIdentifier isEqualToString:Action_Identifier_Image_Confirm]) { completion(UNNotificationContentExtensionResponseOptionDismissAndForwardAction); }else{ completion(UNNotificationContentExtensionResponseOptionDismiss); } }else if ([category isEqualToString:Action_Category_Identifier_Audio]){ if ([actionIdentifier isEqualToString:Action_Identifier_Audio_Confirm]) { completion(UNNotificationContentExtensionResponseOptionDismissAndForwardAction); }else{ completion(UNNotificationContentExtensionResponseOptionDismiss); } }else{ if ([actionIdentifier isEqualToString:Action_Identifier_Movie_Confirm]) { completion(UNNotificationContentExtensionResponseOptionDismissAndForwardAction); }else{ completion(UNNotificationContentExtensionResponseOptionDismiss); } }}","link":"/2017/07/18/ios-notificationcontentextension/"},{"title":"iOS10富文本推送--NotificationServiceExtension","text":"添加http协议支持，没错，这里是支持http协议的，不像其他文章说的不支持配置在另外基础篇文章里面有，info.plist文件里修改一下就行了 NotificationService文件额外添加了一个文件管理器的字段，用来存储数据 123456789101112@interface NotificationService ()@property (nonatomic, strong) void (^contentHandler)(UNNotificationContent *contentToDeliver);@property (nonatomic, strong) UNMutableNotificationContent *bestAttemptContent;@property (nonatomic, strong) NSFileManager *fileMgr;@property (nonatomic, strong) NSURLSessionDownloadTask *download;@property (nonatomic, strong) NSURLSession *session;@property (nonatomic, strong) NSDictionary *userInfo;@property (nonatomic, strong) NSURL *attchUrl;@property (nonatomic, strong) NSString *imageExtension;@end 1@implementation NotificationService LazyLoad 123-(NSFileManager *)fileMgr{ return [NSFileManager defaultManager];} 网络session 123456-(NSURLSession *)session{ if (_session == nil) { _session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]]; } return _session;} 下载任务 123456789101112131415161718192021222324-(NSURLSessionDownloadTask *)download{ if (!_download) { _download = [self.session downloadTaskWithURL:self.attchUrl completionHandler:^(NSURL * _Nullable tempLocation, NSURLResponse * _Nullable response, NSError * _Nullable error) { if (!error) { NSURL *localURL = [NSURL fileURLWithPath:[tempLocation.path stringByAppendingString:self.imageExtension]]; [self.fileMgr moveItemAtURL:tempLocation toURL:localURL error:&amp;error]; NSError *attachmentError = nil; UNNotificationAttachment * attachment = [UNNotificationAttachment attachmentWithIdentifier:@&quot;photo&quot; URL:localURL options:nil error:&amp;attachmentError]; if (attachmentError) { NSLog(@&quot;attachmentError %@&quot;,attachmentError); }else if (attachment){ self.bestAttemptContent.attachments = @[attachment]; }else{ } }else{ NSLog(@&quot;downloadTaskerror %@&quot;,error.localizedDescription); } self.bestAttemptContent.categoryIdentifier = self.userInfo[@&quot;aps&quot;][@&quot;category&quot;]; self.contentHandler(self.bestAttemptContent); }]; } return _download;} 收到远程通知之后，在当前方法内进行处理，并生成attchment，最终回调给系统 12345678910111213- (void)didReceiveNotificationRequest:(UNNotificationRequest *)request withContentHandler:(void (^)(UNNotificationContent * _Nonnull))contentHandler { self.contentHandler = contentHandler; self.bestAttemptContent = [request.content mutableCopy]; self.resumeTime = 0; self.userInfo = [request.content.userInfo copy]; NSString * attchUrl = self.userInfo[@&quot;image&quot;]; self.imageExtension = [NSString stringWithFormat:@&quot;.%@&quot;,[[attchUrl componentsSeparatedByString:@&quot;.&quot;] lastObject]]; if (attchUrl) { self.attchUrl = [NSURL URLWithString:attchUrl]; [self resumeSession]; }} 开始执行下载多媒体资源任务 1234- (void)resumeSession{ [self.download resume];} 超时，异常时调用 123456789- (void)serviceExtensionTimeWillExpire { // Called just before the extension will be terminated by the system. // Use this as an opportunity to deliver your &quot;best attempt&quot; at modified content, otherwise the original push payload will be used. self.contentHandler(self.bestAttemptContent);}@end","link":"/2017/07/18/ios-notificationserviceextension/"},{"title":"iOS10富文本推送--UIMutableUserNotificationAction","text":"iOS10富文本推送–UIMutableUserNotificationAction AppDelagate文件添加action根据以下ContentExtension Info.plist文件中的配置决定category的设置，两者必须一致 宏定义采用下列代码： 12345678910111213141516//推送相关设置#define Action_Category_Identifier_Image @&quot;Image_Category&quot; //图片类别标识符#define Action_Category_Identifier_Audio @&quot;Audio_Category&quot; //音频类别标识符#define Action_Category_Identifier_Movie @&quot;Movie_Category&quot; //视频类别标识符#define Action_Identifier_Image_Confirm @&quot;imageConfirmAction&quot; //图片确认按钮#define Action_Identifier_Image_Concel @&quot;imageConcelAction&quot; //图片取消按钮#define Action_Identifier_Audio_Confirm @&quot;audioConfirmAction&quot; //音频确认按钮#define Action_Identifier_Audio_Concel @&quot;audioConcelAction&quot; //音频取消按钮#define Action_Identifier_Movie_Confirm @&quot;movieConfirmAction&quot; //视频确认按钮#define Action_Identifier_Movie_Concel @&quot;movieConcelAction&quot; //视频取消按钮#define Action_Title_Image_Confirm @&quot;查看&quot; //图片确认按钮标题#define Action_Title_Image_Concel @&quot;忽略&quot; //图片取消按钮标题#define Action_Title_Audio_Confirm @&quot;查看&quot; //音频确认按钮标题#define Action_Title_Audio_Concel @&quot;忽略&quot; //音频取消按钮标题#define Action_Title_Movie_Confirm @&quot;查看&quot; //视频确认按钮标题#define Action_Title_Movie_Concel @&quot;忽略&quot; //视频取消按钮标题 添加相应类别的aciton，一个类别必须对应一个category，在下面这个方法里面执行, 1- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//添加相应类别的aciton，一个类别必须对应一个category- (void)addNotificationAction{ //Image_Category UIMutableUserNotificationAction *imageConfirmAction = [self creatNotificationActionIdentifier:Action_Identifier_Image_Confirm title:Action_Title_Image_Confirm activationMode:UIUserNotificationActivationModeForeground]; imageConfirmAction.authenticationRequired = YES; imageConfirmAction.destructive = YES; UIMutableUserNotificationAction *imageConcelAction = [self creatNotificationActionIdentifier:Action_Identifier_Image_Concel title:Action_Title_Image_Concel activationMode:UIUserNotificationActivationModeBackground]; UIMutableUserNotificationCategory *ImageCategory = [self creatNotificationCategoryIdentifier:Action_Category_Identifier_Image setActions:@[imageConfirmAction,imageConcelAction] forContext:UIUserNotificationActionContextDefault]; //Audio_Category UIMutableUserNotificationAction *audioConfirmAction = [self creatNotificationActionIdentifier:Action_Identifier_Audio_Confirm title:Action_Title_Audio_Confirm activationMode:UIUserNotificationActivationModeForeground]; audioConfirmAction.authenticationRequired = YES; audioConfirmAction.destructive = YES; UIMutableUserNotificationAction *audioConcelAction = [self creatNotificationActionIdentifier:Action_Identifier_Audio_Concel title:Action_Title_Audio_Concel activationMode:UIUserNotificationActivationModeBackground]; UIMutableUserNotificationCategory *audioCategory = [self creatNotificationCategoryIdentifier:Action_Category_Identifier_Audio setActions:@[audioConfirmAction,audioConcelAction] forContext:UIUserNotificationActionContextDefault]; //Movie_Category UIMutableUserNotificationAction *movieConfirmAction = [self creatNotificationActionIdentifier:Action_Identifier_Movie_Confirm title:Action_Title_Movie_Confirm activationMode:UIUserNotificationActivationModeForeground]; movieConfirmAction.authenticationRequired = YES; movieConfirmAction.destructive = YES; UIMutableUserNotificationAction *movieConcelAction = [self creatNotificationActionIdentifier:Action_Identifier_Movie_Concel title:Action_Title_Movie_Concel activationMode:UIUserNotificationActivationModeBackground]; UIMutableUserNotificationCategory *movieCategory = [self creatNotificationCategoryIdentifier:Action_Category_Identifier_Movie setActions:@[movieConfirmAction,movieConcelAction] forContext:UIUserNotificationActionContextDefault]; NSSet *categories = [NSSet setWithObjects:ImageCategory,audioCategory,movieCategory,nil]; UIUserNotificationType types = (UIUserNotificationTypeAlert| UIUserNotificationTypeSound| UIUserNotificationTypeBadge); UIUserNotificationSettings *settings; settings = [UIUserNotificationSettings settingsForTypes:types categories:categories]; [[UIApplication sharedApplication] registerUserNotificationSettings:settings]; } 创建一个category 12345678910//创建一个category- (UIMutableUserNotificationCategory*)creatNotificationCategoryIdentifier:(NSString *)identifier setActions:(nullable NSArray&lt;UIUserNotificationAction *&gt; *)actions forContext:(UIUserNotificationActionContext)context{ UIMutableUserNotificationCategory *category = [[UIMutableUserNotificationCategory alloc] init]; category.identifier = identifier;//这组动作的唯一标示 [category setActions:actions forContext:context]; return category;} 创建一个action 123456789101112//创建一个action-(UIMutableUserNotificationAction *)creatNotificationActionIdentifier:(NSString *)identifier title:(NSString *)title activationMode:(UIUserNotificationActivationMode)activationMode{ UIMutableUserNotificationAction *action = [[UIMutableUserNotificationAction alloc] init]; //第二按钮 action.identifier = identifier; action.title = title; action.activationMode = activationMode; return action;}","link":"/2017/07/18/ios-uimutableusernotificationaction/"},{"title":"iOS10富文本推送--UNNotificationExtension--基础篇","text":"本文主要讲述如何集成富文本推送的相关扩展，另外还会有文章来详细展开 简介本地推送和远程推送同时都可支持附带Media Attachments。不过远程通知需要实现通知服务扩展（UNNotificationServiceExtension），在service extension里面去下载attachment，但是需要注意，service extension会限制下载的时间（30s），并且下载的文件大小也会同样被限制。这里毕竟是一个推送，而不是把所有的内容都推送给用户。所以你应该去推送一些缩小比例之后的版本。比如图片，推送里面附带缩略图，当用户打开app之后，再去下载完整的高清图。视频就附带视频的关键帧或者开头的几秒，当用户打开app之后再去下载完整视频。attachment支持图片，音频，视频，附件支持的类型及大小 准备工作添加Notification Service Extension在当前工程项目中添加新的Target–&gt; Notification Service先在Xcode 打开你的工程，File–&gt;New–&gt;Target然后添加这个Notification Service Extension： 添加Notification Content Extension在当前工程项目中添加新的Target–&gt; Notification Content先在Xcode 打开你的工程，File–&gt;New–&gt;Target然后添加这个Notification Content Extension： 添加扩展完成这样你的项目中就会有两个Extension Target 设置ServiceExtension Info.plist 添加http协议支持，没错，这里是支持http协议的，不像其他文章说的不支持 ContentExtension Info.plist 设置可以改变 如果不想使用故事版把NSExtensionMainStoryboard替换为NSExtensionPrincipalClass（我这里已经） ServiceExtension基本设置 当前Target的BundleID根据项目主Target的BundleID自动生成 格式”项目主Target的BundleID.-当前Target名称” 例如当前项目BundleID为 com.apple.NotificationDemo，ServiceExtension的名字是NotificationService 那么ServiceExtension的BundleID就是com.apple.NotificationDemo.-NotificationService Automatically manages signing 官方建议勾选 Deployment Target 必须设置为10.0以上，不能设置为10.0以下 ContentExtension基本设置 当前Target的BundleID根据项目主Target的BundleID自动生成 格式”项目主Target的BundleID.-当前Target名称” 例如当前项目BundleID为 com.apple.NotificationDemo，ContentExtension的名字是NotificationContent 那么ServiceExtension的BundleID就是com.apple.NotificationDemo.-NotificationContent Automatically manages signing 官方建议勾选 Deployment Target 必须设置为10.0以上，不能设置为10.0以下 如何使用 首先当前应用需要支持APNS,不支持的自己集成去吧服务器向设备发送通知这个通知消息的格式是有要求的，有以下几点需要注意： aps字段必须要有，不然收不到通知 aps字段下alert字段必须要有，不然也收不到通知 alert字段的值是字符串的时候，不可为空，不然的话你虽然收的到通知，但是是手机除了震动或者声音，没有任何提示 alert字段的值是字典的时候，下面这三个字段必须要有一个，不然和上面一样。就是一句话alert的值必须是可以使用的 mutable-content字段值最好是1，目前没见过其他值 如果你想在iOS10上展示位富文本的推送格式，category字段必须带，值必须在info.plist文件中能找的到的 1234567891011121314 { &quot;aps&quot;:{ &quot;alert&quot; : { &quot;title&quot; : &quot;iOS远程消息主标题！-title&quot;, &quot;subtitle&quot; : &quot;iOS远程消息副标题！-Subtitle&quot;, &quot;body&quot; : &quot;longge -body&quot; }, &quot;sound&quot; : &quot;default&quot;, &quot;badge&quot; : &quot;1&quot;, &quot;mutable-content&quot; : &quot;1&quot;, &quot;category&quot; : &quot;Image_Category&quot;, }, &quot;image&quot; : &quot;http://ot260qjni.bkt.clouddn.com/testOne.jpeg&quot;} 上面的测试图片好像不能用了（具体能不能用你们最好测试一下，直接浏览器打开能看到就可以用），我也不知道为啥 你们可以自己去找找先关的图床。","link":"/2017/07/14/ios-unnotificationextension-ji-chu-pian/"},{"title":"iOS 如何加载本地html文件","text":"iOS 如何加载本地html文件???? 其实很简单 如下图所示 1234-(void)loadLocalHtml{ NSURL *url = [[NSBundle mainBundle] URLForResource:@&quot;/sfa/html/index.html&quot; withExtension:nil]; [self.webView loadRequest:[NSURLRequest requestWithURL:url]];} 其中 1@&quot;/sfa/html/index.html&quot; 部分是你的html文件相对于整个工程的路径例如下面这个工程构成图： 相关文件最好以文件方式导入而不是group CSDN: iOS 如何加载本地html文件 简书: iOS 如何加载本地html文件","link":"/2017/12/18/ios-ru-he-jia-zai-ben-di-html-wen-jian/"},{"title":"iOS--如何计算出今天是周几","text":"iOS–如何计算出今天是周几？？ 很简单： 123456789NSCalendar *cal = [[NSCalendar alloc] initWithCalendarIdentifier:NSCalendarIdentifierRepublicOfChina];NSInteger comp = [cal component:NSCalendarUnitWeekday fromDate:[NSDate date]];NSLog(@&quot;%ld&quot;,comp);NSDateComponents *comps = [cal components:NSCalendarUnitWeekday fromDate:[NSDate date]];NSLog(@&quot;%@&quot;,comps);","link":"/2017/08/23/ios-ru-he-ji-suan-chu-jin-tian-shi-zhou-ji/"},{"title":"iOS日志本地化--日志重定向","text":"写在前面本文主要是给读者分享技术的，如何保存能控制台输出的log，以便于查找程序本身出现的问题。 我们该如何做 首先我们要判断，是不是模拟器 1234567#if !(TARGET_IPHONE_SIMULATOR)//真机 //连接xcode时可以从监视器中看日志 没连接时Log日志会输出到文件中， [self redirectNSLogToDocumentFolder]; NSLog(@&quot;真机&quot;);#else//模拟器 NSLog(@&quot;模拟器&quot;);#endif 其次我们还要接着判断是不是真机连接了Xcode，然后才开始进行日志本地化文件的生成 12345678910111213141516171819202122232425262728293031323334- (void)redirectNSLogToDocumentFolder{ //如果已经连接Xcode调试则不输出到文件 if(isatty(STDOUT_FILENO)) { return; } UIDevice *device = [UIDevice currentDevice]; if([[device model] hasSuffix:@&quot;Simulator&quot;]){ //在模拟器不保存到文件中 return; } //将NSlog打印信息保存到Document目录下的Log文件夹下 NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *logDirectory = [[paths objectAtIndex:0] stringByAppendingPathComponent:@&quot;Log&quot;]; NSFileManager *fileManager = [NSFileManager defaultManager]; BOOL fileExists = [fileManager fileExistsAtPath:logDirectory]; if (!fileExists) { [fileManager createDirectoryAtPath:logDirectory withIntermediateDirectories:YES attributes:nil error:nil]; } NSDateFormatter *formatter = [[NSDateFormatter alloc] init]; [formatter setLocale:[[NSLocale alloc] initWithLocaleIdentifier:@&quot;zh_CN&quot;]]; [formatter setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;]; //每次启动后都保存一个新的日志文件中 NSString *dateStr = [formatter stringFromDate:[NSDate date]]; self.filepath = [logDirectory stringByAppendingFormat:@&quot;/%@.log&quot;,dateStr]; // 将log输入到文件 freopen([self.filepath cStringUsingEncoding:NSASCIIStringEncoding], &quot;a+&quot;, stdout); freopen([self.filepath cStringUsingEncoding:NSASCIIStringEncoding], &quot;a+&quot;, stderr); //未捕获的Objective-C异常日志 NSSetUncaughtExceptionHandler (&amp;UncaughtExceptionHandler);} 最后这是一个报错的异常信息，也就是我们所说的崩溃信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344void UncaughtExceptionHandler(NSException* exception){ NSString* name = [ exception name ]; NSString* reason = [ exception reason ]; NSArray* symbols = [ exception callStackSymbols ]; // 异常发生时的调用栈 NSMutableString* strSymbols = [ [ NSMutableString alloc ] init ]; //将调用栈拼成输出日志的字符串 for ( NSString* item in symbols ) { [ strSymbols appendString: item ]; [ strSymbols appendString: @&quot;\\r\\n&quot; ]; } //将crash日志保存到Document目录下的Log文件夹下 NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *logDirectory = [[paths objectAtIndex:0] stringByAppendingPathComponent:@&quot;Log&quot;]; NSFileManager *fileManager = [NSFileManager defaultManager]; if (![fileManager fileExistsAtPath:logDirectory]) { [fileManager createDirectoryAtPath:logDirectory withIntermediateDirectories:YES attributes:nil error:nil]; } //NSString *logFilePath = [logDirectory stringByAppendingPathComponent:@&quot;UncaughtException.log&quot;]; NSDateFormatter *formatter = [[NSDateFormatter alloc] init]; [formatter setLocale:[[NSLocale alloc] initWithLocaleIdentifier:@&quot;zh_CN&quot;]]; [formatter setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;]; AppDelegate *app = [UIApplication sharedApplication].delegate; NSString *dateStr = [formatter stringFromDate:app.date]; NSString *crashString = [NSString stringWithFormat:@&quot;&lt;- %@ -&gt;[ Uncaught Exception ]\\r\\nName: %@, Reason: %@\\r\\n[ Fe Symbols Start ]\\r\\n%@[ Fe Symbols End ]\\r\\n\\r\\n&quot;, dateStr, name, reason, strSymbols]; //把错误日志写到文件中 if (![fileManager fileExistsAtPath:app.filepath]) { [crashString writeToFile:app.filepath atomically:YES encoding:NSUTF8StringEncoding error:nil]; }else{ NSFileHandle *outFile = [NSFileHandle fileHandleForWritingAtPath:app.filepath]; [outFile seekToEndOfFile]; [outFile writeData:[crashString dataUsingEncoding:NSUTF8StringEncoding]]; [outFile closeFile]; } //把错误日志发送到邮箱 NSString *urlStr = [NSString stringWithFormat:@&quot;mailto://邮箱账号?subject=bug报告&amp;body=感谢您的配合!错误详情:%@&quot;,crashString ]; NSURL *url = [NSURL URLWithString:[urlStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]]; [[UIApplication sharedApplication] openURL:url];} 使用在AppDelegate的这个方法中编写如下代码 12345678910- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {#if !(TARGET_IPHONE_SIMULATOR)//真机 //连接xcode时可以从监视器中看日志 没连接时Log日志会输出到文件中， [self redirectNSLogToDocumentFolder]; NSLog(@&quot;真机&quot;);#else//模拟器 NSLog(@&quot;模拟器&quot;);#endifreturn YES;}","link":"/2017/08/18/ios-ri-zhi-ben-di-hua-ri-zhi-chong-ding-xiang/"},{"title":"iOS时间工具类","text":"iOS时间工具类工作之余写的一个关于Unix时间的工具 1234567891011121314151617181920@interface UnixTime : NSObject@property (nonatomic,assign) double unixTimeInterval;//GMT时间戳 微秒级@property (nonatomic,strong) NSDate *unixDate;//GMT时间 2016-01-04 8:55:46 +0000@property (nonatomic,strong) NSString *LocalTimeZone;//本地时区 GMT-12 GMT+12@property (nonatomic,assign) NSInteger timeOffset;//时间偏移量 @property (nonatomic,assign) double unixTimestamp;//GMT+0 毫秒@property (nonatomic,assign) NSInteger unixZeroTimestamp;//当天零点 GMT+0 秒+ (UnixTime *)shareUnixTime;//单例 类方法- (void)getUnixTimestampAtNow;//Unix时间戳 若要获取某天的零时刻 必须先执行找个方法- (void)getSystemTimeZone;//本地时区- (NSString *)getTimeStringWithTime:(double)time;//字符串输出时间 设置日期格式带毫秒的 2016-01-04 16:55:46- (NSInteger)getUnixTimeWithDay:(NSInteger)day;// 某天的零时Unix时间戳- (NSInteger)getUnixTimeWithDay:(NSInteger)day AndClock:(NSInteger)clock; // 某天的特定时刻Unix时间戳- (NSInteger)gettimestampWithDateFormatString:(NSString *)dateFormatString;- (NSString *)formatTimeWithTime:(NSNumber *)time;//根据传入时间数值 返回hh:mm:ss格式的时间 这个是表示时间点的- (NSString *)formatHMWithTime:(NSNumber *)time;//根据传入时间数值 返回hh:mm格式的时间 这个时用来表示时间长短的- (NSString *)getTravelTimeWithStartTime:(NSNumber *)startTime andEndTime:(NSNumber *)endTime;//根据传入时间数值返回时间差值分钟 这个时用来表示时间长短的- (NSString *)getDayHourMinWithTimeStamp:(NSNumber *)time;@end UnixTime.m文件包含方法的具体实现，用法都在.h文件里写了 1234567891011121314#import &quot;UnixTime.h&quot;@implementation UnixTime+ (UnixTime *)shareUnixTime{ static UnixTime *unixTime = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ unixTime = [[UnixTime alloc]init]; }); return unixTime;} 123456789101112131415161718- (void)getUnixTimestampAtNow{ self.unixDate = [NSDate date]; NSLog(@&quot;GMT %@&quot;,self.unixDate); NSTimeInterval time=[self.unixDate timeIntervalSince1970]; self.unixTimeInterval =time; NSString *timeIntervalString = [NSString stringWithFormat:@&quot;%f&quot;,self.unixTimeInterval]; NSLog(@&quot;GMTTimeInterval %@&quot;,timeIntervalString); NSString *micSecondString = [timeIntervalString substringWithRange:NSMakeRange(timeIntervalString.length-6, 3)]; //NSLog(@&quot;micSec %@&quot;,micSecondString); NSInteger micSec = [micSecondString integerValue]; self.unixTimestamp = (NSInteger)time+micSec/1000.000; NSLog(@&quot;GMTTimestamp %ld&quot;,(long)self.unixTimestamp); [self getUnixZeroTimestamp]; [self getSystemTimeZone]; [self getTimeOffset];} 12345678910111213- (void)getSystemTimeZone{ NSTimeZone *timezone = [NSTimeZone systemTimeZone]; //NSLog(@&quot;timeZone%@&quot;,timezone); NSString *timeAbbreviation = timezone.abbreviation; self.LocalTimeZone = timeAbbreviation; if ([timeAbbreviation isEqualToString:@&quot;GMT&quot;]) { self.LocalTimeZone = @&quot;GMT+0&quot;; } // NSLog(@&quot;TimeZone.abb: %@&quot;,self.LocalTimeZone);} 12345678910111213- (void)getTimeOffset{ NSString *str1 = [self.LocalTimeZone substringWithRange:NSMakeRange(3, 1)]; NSString *str2 = [self.LocalTimeZone substringWithRange:NSMakeRange(4, self.LocalTimeZone.length-4)]; NSInteger timeZoneOffset = [str2 integerValue]; if ([str1 isEqualToString:@&quot;+&quot;]) { self.timeOffset = timeZoneOffset*3600; }else if ([str1 isEqualToString:@&quot;-&quot;]){ self.timeOffset = -timeZoneOffset*3600; } //NSLog(@&quot;timeOffSet %ld&quot;,(long)self.timeOffset);} 123456789- (void)getUnixZeroTimestamp{ self.unixZeroTimestamp = (NSInteger)(self.unixTimestamp/86400)*86400; NSInteger days = self.unixZeroTimestamp/86400 ; NSLog(@&quot;GMTZeroTimestamp %ld&quot;,self.unixZeroTimestamp); NSLog(@&quot;days %ld&quot;,days);} 123456789101112- (NSString *)getTimeStringWithTime:(double)time{ NSDate *date = [NSDate dateWithTimeIntervalSince1970:time]; NSDateFormatter *dateFormat = [[NSDateFormatter alloc] init]; [dateFormat setDateFormat:@&quot;YYYY-MM-dd HH:mm:ss&quot;]; // 设置日期格式带秒的 2016-01-04 16:55:46 //NSLog(@&quot;date %@&quot;,date); NSString *timeString = [dateFormat stringFromDate:date]; //NSLog(@&quot;time %@&quot;,timeString); return timeString;} 12345678910- (NSInteger)gettimestampWithDateFormatString:(NSString *)dateFormatString{ NSDateFormatter *dateFormat = [[NSDateFormatter alloc] init]; [dateFormat setDateFormat:@&quot;YYYY-MM-dd HH:mm:ss&quot;]; NSDate *date = [dateFormat dateFromString:dateFormatString]; NSInteger time= [date timeIntervalSince1970]; NSLog(@&quot;time %ld&quot;,time); return time;} 12345678- (NSInteger)getUnixTimeWithDay:(NSInteger)day{ NSInteger unixTime = self.unixZeroTimestamp-(day-1)*86400-self.timeOffset; NSLog(@&quot;unixTime %ld&quot;,unixTime); NSLog(@&quot;%@&quot;,[self getTimeStringWithTime:unixTime]); return unixTime;} 12345678910111213141516171819- (NSInteger)getUnixTimeWithDay:(NSInteger)day AndClock:(NSInteger)clock{//特定时刻的Unix时间戳 if (clock&lt;0||clock&gt;24) {//为了避免传入数据不正确 进行换算 增强可靠性 clock = clock%24; if (clock&lt;0) { clock=clock+24; }else{ clock=clock; } }else{ clock=clock; } NSInteger unixTime = self.unixZeroTimestamp-(day-1)*86400+3600*clock;//-self.timeOffset; //NSLog(@&quot;unixTime %ld&quot;,unixTime); return unixTime;} 123456789101112131415161718192021- (NSString *)formatTimeWithTime:(NSNumber *)time{ float _time_2 = [time floatValue]; NSInteger _time_1 = [time integerValue]; NSInteger sec = (NSInteger)((_time_2-_time_1)*60); NSInteger hour; NSInteger min; if (_time_1&gt;=1 &amp;&amp; _time_1&lt;60) { min = _time_1%60; return [NSString stringWithFormat:@&quot;%ld:%.2ld&quot;,min,sec]; } if (_time_1&gt;=60) { hour = _time_1/60; min = _time_1%60; return [NSString stringWithFormat:@&quot;%ld:%.2ld:%.2ld&quot;,hour,min,sec]; } return [NSString stringWithFormat:@&quot;0:%.2ld&quot;,sec];} 1234567891011121314- (NSString *)formatHMWithTime:(NSNumber *)time{ UnixTime *unixtime = [UnixTime shareUnixTime]; NSString *string = [unixtime getTimeStringWithTime:[time integerValue]]; NSArray *firArray = [string componentsSeparatedByString:@&quot; &quot;]; NSString *firstring = firArray[1]; NSMutableArray *secArray = [NSMutableArray arrayWithArray:[firstring componentsSeparatedByString:@&quot;:&quot;]]; [secArray removeLastObject]; return [secArray componentsJoinedByString:@&quot;:&quot;]; } 1234567891011- (NSString *)getTravelTimeWithStartTime:(NSNumber *)startTime andEndTime:(NSNumber *)endTime{ NSInteger _startTime = [startTime integerValue]; NSInteger _endTime = [endTime integerValue]; NSInteger travelTime = (_endTime - _startTime)/60+1; return [NSString stringWithFormat:@&quot;%ld&quot;,travelTime];} 12345678910111213141516- (NSString *)getDayHourMinWithTimeStamp:(NSNumber *)time{ NSInteger _time = [time integerValue]; NSDate *date = [NSDate dateWithTimeIntervalSince1970:_time]; NSDateFormatter *dateFormat = [[NSDateFormatter alloc] init]; [dateFormat setDateFormat:@&quot;YYYY-MM-dd HH:mm&quot;]; // 设置日期格式 2016-01-04 16:55:46 //NSLog(@&quot;date %@&quot;,date); NSString *timeString = [dateFormat stringFromDate:date]; //NSLog(@&quot;time %@&quot;,timeString); return timeString;}@end","link":"/2017/07/14/ios-shi-jian-gong-ju-lei/"},{"title":"iOS自定义相机的实现","text":"iOS自定义相机的实现本文主要介绍iOS系统上的自定义相机的实现，其实并不难主要包含了，拍摄设备，输入端，输出端，以及抓取图像，保存图像的操作。 ###简单介绍组要控件 上方功能区 取消按钮 闪光灯按钮 相机切换按钮 下方功能区 拍照按钮 重新拍照按钮 选择照片按钮 图像展示视图 主要代码展示头文件内容展示 定了一个block，用于传输照片信息 1234567#import &lt;UIKit/UIKit.h&gt;typedef void(^ImageBlock)(NSDictionary *imageDictionary);@interface CameraViewController : UIViewController@property (nonatomic, copy) ImageBlock imageblock;-(void)setImageblock:(void(^)(NSDictionary *imageDictionary))imageblock;@end 视图控件代码，逻辑代码展示 当前视图需要的主要空控件，为了方便操作全部定义为属性 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@interface CameraViewController ()&lt;AVCaptureMetadataOutputObjectsDelegate,UIAlertViewDelegate,CAAnimationDelegate&gt;//捕获设备，通常是前置摄像头，后置摄像头，麦克风（音频输入）@property(nonatomic)AVCaptureDevice *device;//AVCaptureDeviceInput 代表输入设备，他使用AVCaptureDevice 来初始化@property(nonatomic)AVCaptureDeviceInput *input;//当启动摄像头开始捕获输入@property(nonatomic)AVCaptureMetadataOutput *output;//输出@property (nonatomic)AVCaptureStillImageOutput *ImageOutPut;//session：由他把输入输出结合在一起，并开始启动捕获设备（摄像头）@property(nonatomic)AVCaptureSession *session;//图像预览层，实时显示捕获的图像@property(nonatomic)AVCaptureVideoPreviewLayer *previewLayer;//设备@property (nonatomic, strong)AVCaptureDevice *deveice;//拍照@property (nonatomic, strong) UIButton *PhotoButton;//闪光灯@property (nonatomic, strong) UIButton *flashButton;//取消@property (nonatomic, strong) UIButton *cancleButton;//切换摄像头@property (nonatomic, strong) UIButton *changeButton;//确定选择当前照片@property (nonatomic, strong) UIButton *selectButton;//重新拍照@property (nonatomic, strong) UIButton *reCamButton;//照片加载视图@property (nonatomic, strong) UIImageView *imageView;//对焦区域@property (nonatomic, strong) UIImageView *focusView;//上方功能区@property (nonatomic, strong) UIView *topView;//下方功能区@property (nonatomic, strong) UIView *bottomView;//闪光灯状态@property (nonatomic, assign) BOOL isflashOn;//拍到的照片@property (nonatomic, strong) UIImage *image;//照片的信息@property (nonatomic, strong) NSDictionary *imageDict;//是否可以拍照@property (nonatomic, assign) BOOL canCa;//闪光灯模式@property (nonatomic, assign) AVCaptureFlashMode flahMode;//前后摄像头@property (nonatomic, assign) AVCaptureDevicePosition cameraPosition;//模糊视图@property (nonatomic, strong) UIVisualEffectView *effectView;@end 使用懒加载，减少主要函数中的代码，看起来更为清爽。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164@implementation CameraViewController#pragma mark - 更改摄像头-(UIVisualEffectView *)effectView{ if (_effectView == nil) { UIBlurEffect *effect = [UIBlurEffect effectWithStyle:UIBlurEffectStyleLight]; _effectView = [[UIVisualEffectView alloc] initWithEffect:effect]; _effectView.frame = CGRectMake(0, 0, ScreenWidth(), ScreenHieght()); _effectView.alpha = 1; } return _effectView;} #pragma mark - 更改闪光灯状态-(void)setIsflashOn:(BOOL)isflashOn{ _isflashOn = isflashOn; [[NSUserDefaults standardUserDefaults] setObject:@(_isflashOn) forKey:@&quot;flashMode&quot;]; if (_isflashOn) { [self.flashButton setBackgroundImage:[UIImage imageNamed:@&quot;flash_on&quot;] forState:UIControlStateNormal]; }else{ [self.flashButton setBackgroundImage:[UIImage imageNamed:@&quot;flash_off&quot;] forState:UIControlStateNormal]; }}#pragma mark - 上方功能区-(UIView *)topView{ if (!_topView ) { _topView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, ScreenWidth(), 50)]; _topView.backgroundColor = [UIColor colorWithRed:1 green:1 blue:1 alpha:0.2]; [_topView addSubview:self.cancleButton]; [_topView addSubview:self.flashButton]; [_topView addSubview:self.changeButton]; } return _topView;}#pragma mark - 取消-(UIButton *)cancleButton{ if (_cancleButton == nil) { _cancleButton = [UIButton buttonWithType:UIButtonTypeCustom]; _cancleButton.frame = CGRectMake(20, 10, 60, 30); [_cancleButton setTitle:@&quot;取消&quot; forState:UIControlStateNormal]; [_cancleButton addTarget:self action:@selector(cancle) forControlEvents:UIControlEventTouchUpInside]; } return _cancleButton ;}#pragma mark - 闪光灯-(UIButton *)flashButton{ if (_flashButton == nil) { _flashButton = [UIButton buttonWithType:UIButtonTypeCustom]; _flashButton.frame = CGRectMake((ScreenWidth()-30)/2.0, 10, 30, 30); [_flashButton addTarget:self action:@selector(FlashOn) forControlEvents:UIControlEventTouchUpInside]; } return _flashButton;}#pragma mark - 切换摄像头-(UIButton *)changeButton{ if (_changeButton == nil) { _changeButton = [UIButton buttonWithType:UIButtonTypeCustom]; _changeButton.frame = CGRectMake(ScreenWidth()-40, 10, 30, 30); [_changeButton setBackgroundImage:[UIImage imageNamed:@&quot;cam&quot;] forState:UIControlStateNormal]; [_changeButton addTarget:self action:@selector(changeCamera) forControlEvents:UIControlEventTouchUpInside]; } return _changeButton;}#pragma mark - 下方功能区-(UIView *)bottomView{ if (!_bottomView) { _bottomView = [[UIView alloc] initWithFrame:CGRectMake(0, ScreenHieght()-80, ScreenWidth(), 80)]; _bottomView.backgroundColor = [UIColor colorWithRed:1 green:1 blue:1 alpha:0.4]; [_bottomView addSubview:self.reCamButton]; [_bottomView addSubview:self.PhotoButton]; [_bottomView addSubview:self.selectButton]; } return _bottomView;}-(UIButton *)reCamButton{ if (_reCamButton == nil) { _reCamButton = [UIButton buttonWithType:UIButtonTypeCustom]; _reCamButton.frame = CGRectMake(40, 25, 80, 30); [_reCamButton addTarget:self action:@selector(reCam) forControlEvents:UIControlEventTouchUpInside]; [_reCamButton setTitle:@&quot;重新拍照&quot; forState:UIControlStateNormal]; [_reCamButton setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal]; _reCamButton.alpha = 0; } return _reCamButton;}-(UIButton *)PhotoButton{ if (_PhotoButton == nil) { _PhotoButton = [UIButton buttonWithType:UIButtonTypeCustom]; _PhotoButton.frame = CGRectMake(ScreenWidth()/2.0-30, 10, 60, 60); [_PhotoButton setImage:[UIImage imageNamed:@&quot;photograph&quot;] forState: UIControlStateNormal]; [_PhotoButton setImage:[UIImage imageNamed:@&quot;photograph_Select&quot;] forState:UIControlStateNormal]; [_PhotoButton addTarget:self action:@selector(shutterCamera) forControlEvents:UIControlEventTouchUpInside]; } return _PhotoButton;}-(UIButton *)selectButton{ if (_selectButton == nil) { _selectButton = [UIButton buttonWithType:UIButtonTypeCustom]; _selectButton.frame = CGRectMake(ScreenWidth()-120, 25, 80, 30); [_selectButton addTarget:self action:@selector(selectImage) forControlEvents:UIControlEventTouchUpInside]; [_selectButton setTitle:@&quot;选择照片&quot; forState:UIControlStateNormal]; [_selectButton setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal]; _selectButton.alpha = 0; } return _selectButton;}#pragma mark - 加载照片的视图-(UIImageView *)imageView{ if (_imageView == nil) { _imageView = [[UIImageView alloc]initWithFrame:self.previewLayer.frame]; _imageView.layer.masksToBounds = YES; _imageView.image = _image; } return _imageView;}#pragma mark - 对焦区域-(UIImageView *)focusView{ if (_focusView == nil) { _focusView = [[UIImageView alloc]initWithFrame:CGRectMake(0, 0, 80, 80)]; _focusView.backgroundColor = [UIColor clearColor]; _focusView.image = [UIImage imageNamed:@&quot;foucs80pt&quot;]; } return _focusView;}#pragma mark - 使用self.session，初始化预览层，self.session负责驱动input进行信息的采集，layer负责把图像渲染显示-(AVCaptureVideoPreviewLayer *)previewLayer{ if (_previewLayer == nil) { _previewLayer = [[AVCaptureVideoPreviewLayer alloc]initWithSession:self.session]; _previewLayer.frame = CGRectMake(0, 0, ScreenWidth(), ScreenHieght()); _previewLayer.videoGravity = AVLayerVideoGravityResizeAspectFill; } return _previewLayer;}-(AVCaptureStillImageOutput *)ImageOutPut{ if (_ImageOutPut == nil) { _ImageOutPut = [[AVCaptureStillImageOutput alloc] init]; } return _ImageOutPut;}#pragma mark - 初始化输入-(AVCaptureDeviceInput *)input{ if (_input == nil) { _input = [[AVCaptureDeviceInput alloc]initWithDevice:self.device error:nil]; } return _input;}#pragma mark - 初始化输出-(AVCaptureMetadataOutput *)output{ if (_output == nil) { _output = [[AVCaptureMetadataOutput alloc]init]; } return _output;}#pragma mark - 使用AVMediaTypeVideo 指明self.device代表视频，默认使用后置摄像头进行初始化-(AVCaptureDevice *)device{ if (_device == nil) { _device = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo]; } return _device;} 主要逻辑代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#pragma mark - 当前视图控制器的初始化- (instancetype)init{ self = [super init]; if (self) { _canCa = [self canUserCamear]; } return self;}-(void)setImageblock:(void (^)(NSDictionary *))imageblock{ _imageblock = imageblock;}#pragma mark - 检查相机权限- (BOOL)canUserCamear{ AVAuthorizationStatus authStatus = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeVideo]; if (authStatus == AVAuthorizationStatusDenied) { UIAlertView *alertView = [[UIAlertView alloc]initWithTitle:@&quot;请打开相机权限&quot; message:@&quot;设置-隐私-相机&quot; delegate:self cancelButtonTitle:@&quot;确定&quot; otherButtonTitles:@&quot;取消&quot;, nil]; alertView.tag = 100; [alertView show]; return NO; } else{ return YES; } return YES;}#pragma mark - 视图加载- (void)viewDidLoad { [super viewDidLoad]; self.view.backgroundColor = [UIColor clearColor]; if (_canCa) { [self customCamera]; [self customUI]; [self FlashOn]; }else{ return; } // Do any additional setup after loading the view, typically from a nib.}#pragma mark - 自定义视图- (void)customUI{ [self.view addSubview:self.topView]; [self.view addSubview:self.bottomView]; [self.view addSubview:self.focusView]; UITapGestureRecognizer *tapGesture = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(focusGesture:)]; [self.view addGestureRecognizer:tapGesture]; }#pragma mark - 自定义相机- (void)customCamera{ //生成会话，用来结合输入输出 self.session = [[AVCaptureSession alloc]init]; if ([self.session canSetSessionPreset:AVCaptureSessionPresetPhoto]) { self.session.sessionPreset = AVCaptureSessionPresetPhoto; } if ([self.session canAddInput:self.input]) { [self.session addInput:self.input]; } if ([self.session canAddOutput:self.ImageOutPut]) { [self.session addOutput:self.ImageOutPut]; } [self.view.layer addSublayer:self.previewLayer]; //开始启动 [self.session startRunning]; if ([self.device lockForConfiguration:nil]) { if ([self.device isFlashModeSupported:AVCaptureFlashModeAuto]) { [self.device setFlashMode:AVCaptureFlashModeAuto]; } //自动白平衡 if ([self.device isWhiteBalanceModeSupported:AVCaptureWhiteBalanceModeAutoWhiteBalance]) { [self.device setWhiteBalanceMode:AVCaptureWhiteBalanceModeAutoWhiteBalance]; } [self.device unlockForConfiguration]; } [self focusAtPoint:self.view.center];} *闪光灯 1234567891011121314151617181920#pragma 闪光灯- (void)FlashOn{ if ([self.device lockForConfiguration:nil]) { if (self.isflashOn) { if ([self.device isFlashModeSupported:AVCaptureFlashModeOff]) { [self.device setFlashMode:AVCaptureFlashModeOff]; self.isflashOn = NO; //[self.flashButton setTitle:@&quot;关&quot; forState:UIControlStateNormal]; } }else{ if ([self.device isFlashModeSupported:AVCaptureFlashModeAuto]) { [self.device setFlashMode:AVCaptureFlashModeAuto]; self.isflashOn = YES; //[self.flashButton setTitle:@&quot;开&quot; forState:UIControlStateNormal]; } } [self.device unlockForConfiguration]; }} 双摄像头切换，切换时使用高斯模糊对试图进行处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#pragma mark - 相机切换- (void)changeCamera{ NSUInteger cameraCount = [[AVCaptureDevice devicesWithMediaType:AVMediaTypeVideo] count]; if (cameraCount &gt; 1) { self.changeButton.userInteractionEnabled = NO; [self cutoff]; NSError *error; CATransition *animation = [CATransition animation]; animation.duration = 1; animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]; animation.type = @&quot;oglFlip&quot;; animation.delegate = self; AVCaptureDevice *newCamera = nil; AVCaptureDeviceInput *newInput = nil; AVCaptureDevicePosition position = [[self.input device] position]; if (position == AVCaptureDevicePositionFront){ newCamera = [self cameraWithPosition:AVCaptureDevicePositionBack]; animation.subtype = kCATransitionFromLeft; self.cameraPosition = AVCaptureDevicePositionBack; }else { newCamera = [self cameraWithPosition:AVCaptureDevicePositionFront]; animation.subtype = kCATransitionFromRight; self.cameraPosition = AVCaptureDevicePositionFront; } newInput = [AVCaptureDeviceInput deviceInputWithDevice:newCamera error:nil]; [self.previewLayer addAnimation:animation forKey:nil]; /* 高斯模糊 */ [self.imageView addSubview:self.effectView]; [self.view insertSubview:self.imageView belowSubview:self.topView]; // if (newInput != nil) { [self.session beginConfiguration]; [self.session removeInput:self.input]; if ([self.session canAddInput:newInput]) { [self.session addInput:newInput]; self.input = newInput; } else { [self.session addInput:self.input]; } [self.session commitConfiguration]; } else if (error) { NSLog(@&quot;toggle carema failed, error = %@&quot;, error); } //[self.session startRunning]; }}- (AVCaptureDevice *)cameraWithPosition:(AVCaptureDevicePosition)position{ NSArray *devices = [AVCaptureDevice devicesWithMediaType:AVMediaTypeVideo]; for ( AVCaptureDevice *device in devices ) if ( device.position == position ) return device; return nil;}-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag{ self.changeButton.userInteractionEnabled = YES; [self.effectView removeFromSuperview]; [self.imageView removeFromSuperview]; if (self.cameraPosition == AVCaptureDevicePositionFront) { self.flashButton.alpha = 0; }else if (self.cameraPosition == AVCaptureDevicePositionBack){ self.flashButton.alpha = 1; } [self.session startRunning];} 摄像头对焦 1234567891011121314151617181920212223242526272829303132333435363738#pragma mark - 聚焦- (void)focusGesture:(UITapGestureRecognizer*)gesture{ CGPoint point = [gesture locationInView:gesture.view]; [self focusAtPoint:point];}- (void)focusAtPoint:(CGPoint)point{ CGSize size = self.view.bounds.size; CGPoint focusPoint = CGPointMake( point.y /size.height ,1-point.x/size.width ); NSError *error; if ([self.device lockForConfiguration:&amp;error]) { if ([self.device isFocusModeSupported:AVCaptureFocusModeAutoFocus]) { [self.device setFocusPointOfInterest:focusPoint]; [self.device setFocusMode:AVCaptureFocusModeAutoFocus]; } if ([self.device isExposureModeSupported:AVCaptureExposureModeAutoExpose ]) { [self.device setExposurePointOfInterest:focusPoint]; [self.device setExposureMode:AVCaptureExposureModeAutoExpose]; } [self.device unlockForConfiguration]; self.focusView.center = point; //[self startFocusAnimation]; self.focusView.alpha = 1; [UIView animateWithDuration:0.2 animations:^{ self.focusView.transform = CGAffineTransformMakeScale(1.25f, 1.25f); } completion:^(BOOL finished) { [UIView animateWithDuration:0.3 animations:^{ self.focusView.transform = CGAffineTransformMakeScale(1.0f, 1.0f); } completion:^(BOOL finished) { [self hiddenFocusAnimation]; }]; }]; } } 主要功能按钮 拍照按钮123456789101112131415161718192021222324252627#pragma mark - 拍照- (void)shutterCamera{ AVCaptureConnection * videoConnection = [self.ImageOutPut connectionWithMediaType:AVMediaTypeVideo]; if (!videoConnection) { NSLog(@&quot;take photo failed!&quot;); return; } [self.ImageOutPut captureStillImageAsynchronouslyFromConnection:videoConnection completionHandler:^(CMSampleBufferRef imageDataSampleBuffer, NSError *error) { if (imageDataSampleBuffer == NULL) { return; } NSData * imageData = [AVCaptureStillImageOutput jpegStillImageNSDataRepresentation:imageDataSampleBuffer]; self.image = [UIImage imageWithData:imageData]; self.imageDict = @{@&quot;image&quot;:self.image,@&quot;info&quot;:@{@&quot;PHImageFileUTIKey&quot;:@&quot;.jpeg&quot;}}; [self.session stopRunning]; //[self.view insertSubview:self.imageView belowSubview:self.PhotoButton]; [self.view insertSubview:self.imageView aboveSubview:self.topView]; NSLog(@&quot;image size = %@&quot;,NSStringFromCGSize(self.image.size)); self.topView.alpha = 0; self.PhotoButton.alpha = 0; self.reCamButton.alpha = 1; self.selectButton.alpha = 1; }];} 保存至相册 12345678910111213141516171819#pragma - 保存至相册- (void)saveImageToPhotoAlbum:(UIImage*)savedImage{ UIImageWriteToSavedPhotosAlbum(savedImage, self, @selector(image:didFinishSavingWithError:contextInfo:), NULL); }// 指定回调方法- (void)image: (UIImage *) image didFinishSavingWithError: (NSError *) error contextInfo: (void *) contextInfo{ if(error != NULL){ UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;保存图片结果提示&quot; message:@&quot;保存图片失败&quot; delegate:self cancelButtonTitle:@&quot;确定&quot; otherButtonTitles:nil]; [alert show]; }} 取消 返回上级 12345678910111213141516171819#pragma mark - 取消 返回上级-(void)cancle{ [self.imageView removeFromSuperview]; [self.session stopRunning]; [self.navigationController popViewControllerAnimated:YES];}- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex{ if (buttonIndex == 0 &amp;&amp; alertView.tag == 100) { NSURL * url = [NSURL URLWithString:UIApplicationOpenSettingsURLString]; if([[UIApplication sharedApplication] canOpenURL:url]) { [[UIApplication sharedApplication] openURL:url]; } }} 重新拍照 12345678910#pragma mark - 重新拍照- (void)reCam{ self.imageView.image = nil; [self.imageView removeFromSuperview]; [self.session startRunning]; self.topView.alpha = 1; self.PhotoButton.alpha = 1; self.reCamButton.alpha = 0; self.selectButton.alpha = 0;} 选择照片 返回上级 123456789101112131415#pragma mark - 选择照片 返回上级- (void)selectImage{ [self saveImageToPhotoAlbum:self.image]; self.imageblock(self.image); [self.navigationController popViewControllerAnimated:YES];}-(void)viewDidDisappear:(BOOL)animated{ }- (void)focusDidFinsh{ self.focusView.hidden = YES; self.focusView.transform = CGAffineTransformMakeScale(1.0f, 1.0f); //self.focusView.transform=CGAffineTransformMakeScale(0.7f, 0.7f);} 对焦框动画123456789101112131415161718192021222324252627- (void)startFocusAnimation{ self.focusView.hidden = NO; self.focusView.transform = CGAffineTransformMakeScale(1.25f, 1.25f);//将要显示的view按照正常比例显示出来 [UIView beginAnimations:nil context:UIGraphicsGetCurrentContext()]; //[UIView setAnimationCurve:UIViewAnimationCurveEaseInOut]; //InOut 表示进入和出去时都启动动画 //[UIView setAnimationWillStartSelector:@selector(hiddenFoucsView)]; [UIView setAnimationDidStopSelector:@selector(hiddenFocusAnimation)]; [UIView setAnimationDuration:0.5f];//动画时间 self.focusView.transform = CGAffineTransformIdentity;//先让要显示的view最小直至消失 [UIView commitAnimations]; //启动动画 //相反如果想要从小到大的显示效果，则将比例调换 }- (void)hiddenFocusAnimation{ [UIView beginAnimations:nil context:UIGraphicsGetCurrentContext()]; //NSDate *DATE = [NSDate date]; //[UIView setAnimationStartDate:[NSDate date]]; [UIView setAnimationDelay:3]; self.focusView.alpha = 0; [UIView setAnimationDuration:0.5f];//动画时间 [UIView commitAnimations]; }- (void)hiddenFoucsView{ self.focusView.alpha = !self.focusView.alpha;} 写在最后 第一次自定义一个相机，代码写的可能不太好理解。 这个项目在码云的git库上有，地址为https://git.oschina.net/LiynXu/PhotoDemo.git。 如果有任何意见或者建议，或者发现bug(应该是有的),请移步值git库下给予指导，3Q。","link":"/2017/08/18/ios-zi-ding-yi-xiang-ji-de-shi-xian/"},{"title":"hexo 4.5","text":"","link":"/2021/10/15/hexo-4-5/"}],"tags":[{"name":"转载","slug":"转载","link":"/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"原创分享","slug":"原创分享","link":"/tags/%E5%8E%9F%E5%88%9B%E5%88%86%E4%BA%AB/"},{"name":"分享","slug":"分享","link":"/tags/%E5%88%86%E4%BA%AB/"}],"categories":[]}